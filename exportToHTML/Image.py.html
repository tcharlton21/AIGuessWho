<html>
<head>
<title>Image.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Image.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># The Python Imaging Library.</span>
<span class="s0"># $Id$</span>
<span class="s0">#</span>
<span class="s0"># the Image class wrapper</span>
<span class="s0">#</span>
<span class="s0"># partial release history:</span>
<span class="s0"># 1995-09-09 fl   Created</span>
<span class="s0"># 1996-03-11 fl   PIL release 0.0 (proof of concept)</span>
<span class="s0"># 1996-04-30 fl   PIL release 0.1b1</span>
<span class="s0"># 1999-07-28 fl   PIL release 1.0 final</span>
<span class="s0"># 2000-06-07 fl   PIL release 1.1</span>
<span class="s0"># 2000-10-20 fl   PIL release 1.1.1</span>
<span class="s0"># 2001-05-07 fl   PIL release 1.1.2</span>
<span class="s0"># 2002-03-15 fl   PIL release 1.1.3</span>
<span class="s0"># 2003-05-10 fl   PIL release 1.1.4</span>
<span class="s0"># 2005-03-28 fl   PIL release 1.1.5</span>
<span class="s0"># 2006-12-02 fl   PIL release 1.1.6</span>
<span class="s0"># 2009-11-15 fl   PIL release 1.1.7</span>
<span class="s0">#</span>
<span class="s0"># Copyright (c) 1997-2009 by Secret Labs AB.  All rights reserved.</span>
<span class="s0"># Copyright (c) 1995-2009 by Fredrik Lundh.</span>
<span class="s0">#</span>
<span class="s0"># See the README file for information on usage and redistribution.</span>
<span class="s0">#</span>

<span class="s2">import </span><span class="s1">atexit</span>
<span class="s2">import </span><span class="s1">builtins</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">tempfile</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">MutableMapping</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">IntEnum</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">defusedxml.ElementTree </span><span class="s2">as </span><span class="s1">ElementTree</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">ElementTree = </span><span class="s2">None</span>

<span class="s0"># VERSION was removed in Pillow 6.0.0.</span>
<span class="s0"># PILLOW_VERSION was removed in Pillow 9.0.0.</span>
<span class="s0"># Use __version__ instead.</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ExifTags</span><span class="s2">,</span>
    <span class="s1">ImageMode</span><span class="s2">,</span>
    <span class="s1">TiffTags</span><span class="s2">,</span>
    <span class="s1">UnidentifiedImageError</span><span class="s2">,</span>
    <span class="s1">__version__</span><span class="s2">,</span>
    <span class="s1">_plugins</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">._binary </span><span class="s2">import </span><span class="s1">i32le</span><span class="s2">, </span><span class="s1">o32be</span><span class="s2">, </span><span class="s1">o32le</span>
<span class="s2">from </span><span class="s1">._deprecate </span><span class="s2">import </span><span class="s1">deprecate</span>
<span class="s2">from </span><span class="s1">._util </span><span class="s2">import </span><span class="s1">DeferredError</span><span class="s2">, </span><span class="s1">is_path</span>


<span class="s2">def </span><span class="s1">__getattr__(name):</span>
    <span class="s1">categories = {</span><span class="s3">&quot;NORMAL&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;SEQUENCE&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;CONTAINER&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">categories:</span>
        <span class="s1">deprecate(</span><span class="s3">&quot;Image categories&quot;</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s3">&quot;is_animated&quot;</span><span class="s2">, </span><span class="s1">plural=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">categories[name]</span>
    <span class="s1">old_resampling = {</span>
        <span class="s3">&quot;LINEAR&quot;</span><span class="s1">: </span><span class="s3">&quot;BILINEAR&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;CUBIC&quot;</span><span class="s1">: </span><span class="s3">&quot;BICUBIC&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;ANTIALIAS&quot;</span><span class="s1">: </span><span class="s3">&quot;LANCZOS&quot;</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">old_resampling:</span>
        <span class="s1">deprecate(</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">old_resampling[name]</span><span class="s2">} </span><span class="s3">or Resampling.</span><span class="s2">{</span><span class="s1">old_resampling[name]</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">Resampling[old_resampling[name]]</span>
    <span class="s1">msg = </span><span class="s3">f&quot;module '</span><span class="s2">{</span><span class="s1">__name__</span><span class="s2">}</span><span class="s3">' has no attribute '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">'&quot;</span>
    <span class="s2">raise </span><span class="s1">AttributeError(msg)</span>


<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s2">class </span><span class="s1">DecompressionBombWarning(RuntimeWarning):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">DecompressionBombError(Exception):</span>
    <span class="s2">pass</span>


<span class="s0"># Limit to around a quarter gigabyte for a 24-bit (3 bpp) image</span>
<span class="s1">MAX_IMAGE_PIXELS = int(</span><span class="s4">1024 </span><span class="s1">* </span><span class="s4">1024 </span><span class="s1">* </span><span class="s4">1024 </span><span class="s1">// </span><span class="s4">4 </span><span class="s1">// </span><span class="s4">3</span><span class="s1">)</span>


<span class="s2">try</span><span class="s1">:</span>
    <span class="s0"># If the _imaging C module is not present, Pillow will not load.</span>
    <span class="s0"># Note that other modules should not refer to _imaging directly;</span>
    <span class="s0"># import Image and use the Image.core variable instead.</span>
    <span class="s0"># Also note that Image.core is not a publicly documented interface,</span>
    <span class="s0"># and should be considered private and subject to change.</span>
    <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">_imaging </span><span class="s2">as </span><span class="s1">core</span>

    <span class="s2">if </span><span class="s1">__version__ != getattr(core</span><span class="s2">, </span><span class="s3">&quot;PILLOW_VERSION&quot;</span><span class="s2">, None</span><span class="s1">):</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;The _imaging extension was built for another version of Pillow or PIL:</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">f&quot;Core version: </span><span class="s2">{</span><span class="s1">getattr(core</span><span class="s2">, </span><span class="s3">'PILLOW_VERSION'</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">}\n</span><span class="s3">&quot;</span>
            <span class="s3">f&quot;Pillow version: </span><span class="s2">{</span><span class="s1">__version__</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">ImportError(msg)</span>

<span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">v:</span>
    <span class="s1">core = DeferredError(ImportError(</span><span class="s3">&quot;The _imaging C module is not installed.&quot;</span><span class="s1">))</span>
    <span class="s0"># Explanations for ways that we know we might have an import error</span>
    <span class="s2">if </span><span class="s1">str(v).startswith(</span><span class="s3">&quot;Module use of python&quot;</span><span class="s1">):</span>
        <span class="s0"># The _imaging C module is present, but not compiled for</span>
        <span class="s0"># the right version (windows only).  Print a warning, if</span>
        <span class="s0"># possible.</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;The _imaging extension was built for another version of Python.&quot;</span><span class="s2">,</span>
            <span class="s1">RuntimeWarning</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">str(v).startswith(</span><span class="s3">&quot;The _imaging extension&quot;</span><span class="s1">):</span>
        <span class="s1">warnings.warn(str(v)</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>
    <span class="s0"># Fail here anyway. Don't let people run with a mostly broken Pillow.</span>
    <span class="s0"># see docs/porting.rst</span>
    <span class="s2">raise</span>


<span class="s0"># works everywhere, win for pypy, not cpython</span>
<span class="s1">USE_CFFI_ACCESS = hasattr(sys</span><span class="s2">, </span><span class="s3">&quot;pypy_version_info&quot;</span><span class="s1">)</span>
<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">cffi</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">cffi = </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">isImageType(t):</span>
    <span class="s5">&quot;&quot;&quot; 
    Checks if an object is an image object. 
 
    .. warning:: 
 
       This function is for internal use only. 
 
    :param t: object to check if it's an image 
    :returns: True if the object is an image 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">hasattr(t</span><span class="s2">, </span><span class="s3">&quot;im&quot;</span><span class="s1">)</span>


<span class="s0">#</span>
<span class="s0"># Constants</span>

<span class="s0"># transpose</span>
<span class="s2">class </span><span class="s1">Transpose(IntEnum):</span>
    <span class="s1">FLIP_LEFT_RIGHT = </span><span class="s4">0</span>
    <span class="s1">FLIP_TOP_BOTTOM = </span><span class="s4">1</span>
    <span class="s1">ROTATE_90 = </span><span class="s4">2</span>
    <span class="s1">ROTATE_180 = </span><span class="s4">3</span>
    <span class="s1">ROTATE_270 = </span><span class="s4">4</span>
    <span class="s1">TRANSPOSE = </span><span class="s4">5</span>
    <span class="s1">TRANSVERSE = </span><span class="s4">6</span>


<span class="s0"># transforms (also defined in Imaging.h)</span>
<span class="s2">class </span><span class="s1">Transform(IntEnum):</span>
    <span class="s1">AFFINE = </span><span class="s4">0</span>
    <span class="s1">EXTENT = </span><span class="s4">1</span>
    <span class="s1">PERSPECTIVE = </span><span class="s4">2</span>
    <span class="s1">QUAD = </span><span class="s4">3</span>
    <span class="s1">MESH = </span><span class="s4">4</span>


<span class="s0"># resampling filters (also defined in Imaging.h)</span>
<span class="s2">class </span><span class="s1">Resampling(IntEnum):</span>
    <span class="s1">NEAREST = </span><span class="s4">0</span>
    <span class="s1">BOX = </span><span class="s4">4</span>
    <span class="s1">BILINEAR = </span><span class="s4">2</span>
    <span class="s1">HAMMING = </span><span class="s4">5</span>
    <span class="s1">BICUBIC = </span><span class="s4">3</span>
    <span class="s1">LANCZOS = </span><span class="s4">1</span>


<span class="s1">_filters_support = {</span>
    <span class="s1">Resampling.BOX: </span><span class="s4">0.5</span><span class="s2">,</span>
    <span class="s1">Resampling.BILINEAR: </span><span class="s4">1.0</span><span class="s2">,</span>
    <span class="s1">Resampling.HAMMING: </span><span class="s4">1.0</span><span class="s2">,</span>
    <span class="s1">Resampling.BICUBIC: </span><span class="s4">2.0</span><span class="s2">,</span>
    <span class="s1">Resampling.LANCZOS: </span><span class="s4">3.0</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s0"># dithers</span>
<span class="s2">class </span><span class="s1">Dither(IntEnum):</span>
    <span class="s1">NONE = </span><span class="s4">0</span>
    <span class="s1">ORDERED = </span><span class="s4">1  </span><span class="s0"># Not yet implemented</span>
    <span class="s1">RASTERIZE = </span><span class="s4">2  </span><span class="s0"># Not yet implemented</span>
    <span class="s1">FLOYDSTEINBERG = </span><span class="s4">3  </span><span class="s0"># default</span>


<span class="s0"># palettes/quantizers</span>
<span class="s2">class </span><span class="s1">Palette(IntEnum):</span>
    <span class="s1">WEB = </span><span class="s4">0</span>
    <span class="s1">ADAPTIVE = </span><span class="s4">1</span>


<span class="s2">class </span><span class="s1">Quantize(IntEnum):</span>
    <span class="s1">MEDIANCUT = </span><span class="s4">0</span>
    <span class="s1">MAXCOVERAGE = </span><span class="s4">1</span>
    <span class="s1">FASTOCTREE = </span><span class="s4">2</span>
    <span class="s1">LIBIMAGEQUANT = </span><span class="s4">3</span>


<span class="s1">module = sys.modules[__name__]</span>
<span class="s2">for </span><span class="s1">enum </span><span class="s2">in </span><span class="s1">(Transpose</span><span class="s2">, </span><span class="s1">Transform</span><span class="s2">, </span><span class="s1">Resampling</span><span class="s2">, </span><span class="s1">Dither</span><span class="s2">, </span><span class="s1">Palette</span><span class="s2">, </span><span class="s1">Quantize):</span>
    <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">enum:</span>
        <span class="s1">setattr(module</span><span class="s2">, </span><span class="s1">item.name</span><span class="s2">, </span><span class="s1">item.value)</span>


<span class="s2">if </span><span class="s1">hasattr(core</span><span class="s2">, </span><span class="s3">&quot;DEFAULT_STRATEGY&quot;</span><span class="s1">):</span>
    <span class="s1">DEFAULT_STRATEGY = core.DEFAULT_STRATEGY</span>
    <span class="s1">FILTERED = core.FILTERED</span>
    <span class="s1">HUFFMAN_ONLY = core.HUFFMAN_ONLY</span>
    <span class="s1">RLE = core.RLE</span>
    <span class="s1">FIXED = core.FIXED</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Registries</span>

<span class="s1">ID = []</span>
<span class="s1">OPEN = {}</span>
<span class="s1">MIME = {}</span>
<span class="s1">SAVE = {}</span>
<span class="s1">SAVE_ALL = {}</span>
<span class="s1">EXTENSION = {}</span>
<span class="s1">DECODERS = {}</span>
<span class="s1">ENCODERS = {}</span>

<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Modes</span>

<span class="s1">_ENDIAN = </span><span class="s3">&quot;&lt;&quot; </span><span class="s2">if </span><span class="s1">sys.byteorder == </span><span class="s3">&quot;little&quot; </span><span class="s2">else </span><span class="s3">&quot;&gt;&quot;</span>


<span class="s2">def </span><span class="s1">_conv_type_shape(im):</span>
    <span class="s1">m = ImageMode.getmode(im.mode)</span>
    <span class="s1">shape = (im.height</span><span class="s2">, </span><span class="s1">im.width)</span>
    <span class="s1">extra = len(m.bands)</span>
    <span class="s2">if </span><span class="s1">extra != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">shape += (extra</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">m.typestr</span>


<span class="s1">MODES = [</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;CMYK&quot;</span><span class="s2">, </span><span class="s3">&quot;F&quot;</span><span class="s2">, </span><span class="s3">&quot;HSV&quot;</span><span class="s2">, </span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;LAB&quot;</span><span class="s2">, </span><span class="s3">&quot;P&quot;</span><span class="s2">, </span><span class="s3">&quot;RGB&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBX&quot;</span><span class="s2">, </span><span class="s3">&quot;YCbCr&quot;</span><span class="s1">]</span>

<span class="s0"># raw modes that may be memory mapped.  NOTE: if you change this, you</span>
<span class="s0"># may have to modify the stride calculation in map.c too!</span>
<span class="s1">_MAPMODES = (</span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;P&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBX&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s3">&quot;CMYK&quot;</span><span class="s2">, </span><span class="s3">&quot;I;16&quot;</span><span class="s2">, </span><span class="s3">&quot;I;16L&quot;</span><span class="s2">, </span><span class="s3">&quot;I;16B&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">getmodebase(mode):</span>
    <span class="s5">&quot;&quot;&quot; 
    Gets the &quot;base&quot; mode for given mode.  This function returns &quot;L&quot; for 
    images that contain grayscale data, and &quot;RGB&quot; for images that 
    contain color data. 
 
    :param mode: Input mode. 
    :returns: &quot;L&quot; or &quot;RGB&quot;. 
    :exception KeyError: If the input mode was not a standard mode. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">ImageMode.getmode(mode).basemode</span>


<span class="s2">def </span><span class="s1">getmodetype(mode):</span>
    <span class="s5">&quot;&quot;&quot; 
    Gets the storage type mode.  Given a mode, this function returns a 
    single-layer mode suitable for storing individual bands. 
 
    :param mode: Input mode. 
    :returns: &quot;L&quot;, &quot;I&quot;, or &quot;F&quot;. 
    :exception KeyError: If the input mode was not a standard mode. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">ImageMode.getmode(mode).basetype</span>


<span class="s2">def </span><span class="s1">getmodebandnames(mode):</span>
    <span class="s5">&quot;&quot;&quot; 
    Gets a list of individual band names.  Given a mode, this function returns 
    a tuple containing the names of individual bands (use 
    :py:method:`~PIL.Image.getmodetype` to get the mode used to store each 
    individual band. 
 
    :param mode: Input mode. 
    :returns: A tuple containing band names.  The length of the tuple 
        gives the number of bands in an image of the given mode. 
    :exception KeyError: If the input mode was not a standard mode. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">ImageMode.getmode(mode).bands</span>


<span class="s2">def </span><span class="s1">getmodebands(mode):</span>
    <span class="s5">&quot;&quot;&quot; 
    Gets the number of individual bands for this mode. 
 
    :param mode: Input mode. 
    :returns: The number of bands in this mode. 
    :exception KeyError: If the input mode was not a standard mode. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">len(ImageMode.getmode(mode).bands)</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Helpers</span>

<span class="s1">_initialized = </span><span class="s4">0</span>


<span class="s2">def </span><span class="s1">preinit():</span>
    <span class="s5">&quot;&quot;&quot;Explicitly load standard file format drivers.&quot;&quot;&quot;</span>

    <span class="s2">global </span><span class="s1">_initialized</span>
    <span class="s2">if </span><span class="s1">_initialized &gt;= </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">return</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">BmpImagePlugin</span>

        <span class="s2">assert </span><span class="s1">BmpImagePlugin</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s2">pass</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">GifImagePlugin</span>

        <span class="s2">assert </span><span class="s1">GifImagePlugin</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s2">pass</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">JpegImagePlugin</span>

        <span class="s2">assert </span><span class="s1">JpegImagePlugin</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s2">pass</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">PpmImagePlugin</span>

        <span class="s2">assert </span><span class="s1">PpmImagePlugin</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s2">pass</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">PngImagePlugin</span>

        <span class="s2">assert </span><span class="s1">PngImagePlugin</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s2">pass</span>
    <span class="s0"># try:</span>
    <span class="s0">#     import TiffImagePlugin</span>
    <span class="s0">#     assert TiffImagePlugin</span>
    <span class="s0"># except ImportError:</span>
    <span class="s0">#     pass</span>

    <span class="s1">_initialized = </span><span class="s4">1</span>


<span class="s2">def </span><span class="s1">init():</span>
    <span class="s5">&quot;&quot;&quot; 
    Explicitly initializes the Python Imaging Library. This function 
    loads all available file format drivers. 
    &quot;&quot;&quot;</span>

    <span class="s2">global </span><span class="s1">_initialized</span>
    <span class="s2">if </span><span class="s1">_initialized &gt;= </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">for </span><span class="s1">plugin </span><span class="s2">in </span><span class="s1">_plugins:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">logger.debug(</span><span class="s3">&quot;Importing %s&quot;</span><span class="s2">, </span><span class="s1">plugin)</span>
            <span class="s1">__import__(</span><span class="s3">f&quot;PIL.</span><span class="s2">{</span><span class="s1">plugin</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">globals()</span><span class="s2">, </span><span class="s1">locals()</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">logger.debug(</span><span class="s3">&quot;Image: failed to import %s: %s&quot;</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">e)</span>

    <span class="s2">if </span><span class="s1">OPEN </span><span class="s2">or </span><span class="s1">SAVE:</span>
        <span class="s1">_initialized = </span><span class="s4">2</span>
        <span class="s2">return </span><span class="s4">1</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Codec factories (used by tobytes/frombytes and ImageFile.load)</span>


<span class="s2">def </span><span class="s1">_getdecoder(mode</span><span class="s2">, </span><span class="s1">decoder_name</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">extra=()):</span>

    <span class="s0"># tweak arguments</span>
    <span class="s2">if </span><span class="s1">args </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">args = ()</span>
    <span class="s2">elif not </span><span class="s1">isinstance(args</span><span class="s2">, </span><span class="s1">tuple):</span>
        <span class="s1">args = (args</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">decoder = DECODERS[decoder_name]</span>
    <span class="s2">except </span><span class="s1">KeyError:</span>
        <span class="s2">pass</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">decoder(mode</span><span class="s2">, </span><span class="s1">*args + extra)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s0"># get decoder</span>
        <span class="s1">decoder = getattr(core</span><span class="s2">, </span><span class="s1">decoder_name + </span><span class="s3">&quot;_decoder&quot;</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s1">msg = </span><span class="s3">f&quot;decoder </span><span class="s2">{</span><span class="s1">decoder_name</span><span class="s2">} </span><span class="s3">not available&quot;</span>
        <span class="s2">raise </span><span class="s1">OSError(msg) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">return </span><span class="s1">decoder(mode</span><span class="s2">, </span><span class="s1">*args + extra)</span>


<span class="s2">def </span><span class="s1">_getencoder(mode</span><span class="s2">, </span><span class="s1">encoder_name</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">extra=()):</span>

    <span class="s0"># tweak arguments</span>
    <span class="s2">if </span><span class="s1">args </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">args = ()</span>
    <span class="s2">elif not </span><span class="s1">isinstance(args</span><span class="s2">, </span><span class="s1">tuple):</span>
        <span class="s1">args = (args</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">encoder = ENCODERS[encoder_name]</span>
    <span class="s2">except </span><span class="s1">KeyError:</span>
        <span class="s2">pass</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">encoder(mode</span><span class="s2">, </span><span class="s1">*args + extra)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s0"># get encoder</span>
        <span class="s1">encoder = getattr(core</span><span class="s2">, </span><span class="s1">encoder_name + </span><span class="s3">&quot;_encoder&quot;</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s1">msg = </span><span class="s3">f&quot;encoder </span><span class="s2">{</span><span class="s1">encoder_name</span><span class="s2">} </span><span class="s3">not available&quot;</span>
        <span class="s2">raise </span><span class="s1">OSError(msg) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">return </span><span class="s1">encoder(mode</span><span class="s2">, </span><span class="s1">*args + extra)</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Simple expression analyzer</span>


<span class="s2">def </span><span class="s1">coerce_e(value):</span>
    <span class="s1">deprecate(</span><span class="s3">&quot;coerce_e&quot;</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">value </span><span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">_E) </span><span class="s2">else </span><span class="s1">_E(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">value)</span>


<span class="s0"># _E(scale, offset) represents the affine transformation scale * x + offset.</span>
<span class="s0"># The &quot;data&quot; field is named for compatibility with the old implementation,</span>
<span class="s0"># and should be renamed once coerce_e is removed.</span>
<span class="s2">class </span><span class="s1">_E:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">self.scale = scale</span>
        <span class="s1">self.data = data</span>

    <span class="s2">def </span><span class="s1">__neg__(self):</span>
        <span class="s2">return </span><span class="s1">_E(-self.scale</span><span class="s2">, </span><span class="s1">-self.data)</span>

    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">_E):</span>
            <span class="s2">return </span><span class="s1">_E(self.scale + other.scale</span><span class="s2">, </span><span class="s1">self.data + other.data)</span>
        <span class="s2">return </span><span class="s1">_E(self.scale</span><span class="s2">, </span><span class="s1">self.data + other)</span>

    <span class="s1">__radd__ = __add__</span>

    <span class="s2">def </span><span class="s1">__sub__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self + -other</span>

    <span class="s2">def </span><span class="s1">__rsub__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">other + -self</span>

    <span class="s2">def </span><span class="s1">__mul__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">_E):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">_E(self.scale * other</span><span class="s2">, </span><span class="s1">self.data * other)</span>

    <span class="s1">__rmul__ = __mul__</span>

    <span class="s2">def </span><span class="s1">__truediv__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">_E):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">_E(self.scale / other</span><span class="s2">, </span><span class="s1">self.data / other)</span>


<span class="s2">def </span><span class="s1">_getscaleoffset(expr):</span>
    <span class="s1">a = expr(_E(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s2">return </span><span class="s1">(a.scale</span><span class="s2">, </span><span class="s1">a.data) </span><span class="s2">if </span><span class="s1">isinstance(a</span><span class="s2">, </span><span class="s1">_E) </span><span class="s2">else </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">a)</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Implementation wrapper</span>


<span class="s2">class </span><span class="s1">Image:</span>
    <span class="s5">&quot;&quot;&quot; 
    This class represents an image object.  To create 
    :py:class:`~PIL.Image.Image` objects, use the appropriate factory 
    functions.  There's hardly ever any reason to call the Image constructor 
    directly. 
 
    * :py:func:`~PIL.Image.open` 
    * :py:func:`~PIL.Image.new` 
    * :py:func:`~PIL.Image.frombytes` 
    &quot;&quot;&quot;</span>

    <span class="s1">format = </span><span class="s2">None</span>
    <span class="s1">format_description = </span><span class="s2">None</span>
    <span class="s1">_close_exclusive_fp_after_loading = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s0"># FIXME: take &quot;new&quot; parameters / other image?</span>
        <span class="s0"># FIXME: turn mode and size into delegating properties?</span>
        <span class="s1">self.im = </span><span class="s2">None</span>
        <span class="s1">self.mode = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">self._size = (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.palette = </span><span class="s2">None</span>
        <span class="s1">self.info = {}</span>
        <span class="s1">self._category = </span><span class="s4">0</span>
        <span class="s1">self.readonly = </span><span class="s4">0</span>
        <span class="s1">self.pyaccess = </span><span class="s2">None</span>
        <span class="s1">self._exif = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;category&quot;</span><span class="s1">:</span>
            <span class="s1">deprecate(</span><span class="s3">&quot;Image categories&quot;</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s3">&quot;is_animated&quot;</span><span class="s2">, </span><span class="s1">plural=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">self._category</span>
        <span class="s2">raise </span><span class="s1">AttributeError(name)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">width(self):</span>
        <span class="s2">return </span><span class="s1">self.size[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">height(self):</span>
        <span class="s2">return </span><span class="s1">self.size[</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">size(self):</span>
        <span class="s2">return </span><span class="s1">self._size</span>

    <span class="s2">def </span><span class="s1">_new(self</span><span class="s2">, </span><span class="s1">im):</span>
        <span class="s1">new = Image()</span>
        <span class="s1">new.im = im</span>
        <span class="s1">new.mode = im.mode</span>
        <span class="s1">new._size = im.size</span>
        <span class="s2">if </span><span class="s1">im.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;P&quot;</span><span class="s2">, </span><span class="s3">&quot;PA&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">self.palette:</span>
                <span class="s1">new.palette = self.palette.copy()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImagePalette</span>

                <span class="s1">new.palette = ImagePalette.ImagePalette()</span>
        <span class="s1">new.info = self.info.copy()</span>
        <span class="s2">return </span><span class="s1">new</span>

    <span class="s0"># Context manager support</span>
    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;fp&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s3">&quot;_exclusive_fp&quot;</span><span class="s2">, False</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s3">&quot;_fp&quot;</span><span class="s2">, False</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">self._fp != self.fp:</span>
                    <span class="s1">self._fp.close()</span>
                <span class="s1">self._fp = DeferredError(ValueError(</span><span class="s3">&quot;Operation on closed image&quot;</span><span class="s1">))</span>
            <span class="s2">if </span><span class="s1">self.fp:</span>
                <span class="s1">self.fp.close()</span>
        <span class="s1">self.fp = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Closes the file pointer, if possible. 
 
        This operation will destroy the image core and release its memory. 
        The image data will be unusable afterward. 
 
        This function is required to close images that have multiple frames or 
        have not had their file read and closed by the 
        :py:meth:`~PIL.Image.Image.load` method. See :ref:`file-handling` for 
        more information. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s3">&quot;_fp&quot;</span><span class="s2">, False</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">self._fp != self.fp:</span>
                    <span class="s1">self._fp.close()</span>
                <span class="s1">self._fp = DeferredError(ValueError(</span><span class="s3">&quot;Operation on closed image&quot;</span><span class="s1">))</span>
            <span class="s2">if </span><span class="s1">self.fp:</span>
                <span class="s1">self.fp.close()</span>
            <span class="s1">self.fp = </span><span class="s2">None</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">msg:</span>
            <span class="s1">logger.debug(</span><span class="s3">&quot;Error closing: %s&quot;</span><span class="s2">, </span><span class="s1">msg)</span>

        <span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s3">&quot;map&quot;</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s1">self.map = </span><span class="s2">None</span>

        <span class="s0"># Instead of simply setting to None, we're setting up a</span>
        <span class="s0"># deferred error that will better explain that the core image</span>
        <span class="s0"># object is gone.</span>
        <span class="s1">self.im = DeferredError(ValueError(</span><span class="s3">&quot;Operation on closed image&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_copy(self):</span>
        <span class="s1">self.load()</span>
        <span class="s1">self.im = self.im.copy()</span>
        <span class="s1">self.pyaccess = </span><span class="s2">None</span>
        <span class="s1">self.readonly = </span><span class="s4">0</span>

    <span class="s2">def </span><span class="s1">_ensure_mutable(self):</span>
        <span class="s2">if </span><span class="s1">self.readonly:</span>
            <span class="s1">self._copy()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.load()</span>

    <span class="s2">def </span><span class="s1">_dump(self</span><span class="s2">, </span><span class="s1">file=</span><span class="s2">None, </span><span class="s1">format=</span><span class="s2">None, </span><span class="s1">**options):</span>
        <span class="s1">suffix = </span><span class="s3">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">format:</span>
            <span class="s1">suffix = </span><span class="s3">&quot;.&quot; </span><span class="s1">+ format</span>

        <span class="s2">if not </span><span class="s1">file:</span>
            <span class="s1">f</span><span class="s2">, </span><span class="s1">filename = tempfile.mkstemp(suffix)</span>
            <span class="s1">os.close(f)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">filename = file</span>
            <span class="s2">if not </span><span class="s1">filename.endswith(suffix):</span>
                <span class="s1">filename = filename + suffix</span>

        <span class="s1">self.load()</span>

        <span class="s2">if not </span><span class="s1">format </span><span class="s2">or </span><span class="s1">format == </span><span class="s3">&quot;PPM&quot;</span><span class="s1">:</span>
            <span class="s1">self.im.save_ppm(filename)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.save(filename</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">**options)</span>

        <span class="s2">return </span><span class="s1">filename</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.__class__ </span><span class="s2">is </span><span class="s1">other.__class__</span>
            <span class="s2">and </span><span class="s1">self.mode == other.mode</span>
            <span class="s2">and </span><span class="s1">self.size == other.size</span>
            <span class="s2">and </span><span class="s1">self.info == other.info</span>
            <span class="s2">and </span><span class="s1">self._category == other._category</span>
            <span class="s2">and </span><span class="s1">self.getpalette() == other.getpalette()</span>
            <span class="s2">and </span><span class="s1">self.tobytes() == other.tobytes()</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;%s.%s image mode=%s size=%dx%d at 0x%X&gt;&quot; </span><span class="s1">% (</span>
            <span class="s1">self.__class__.__module__</span><span class="s2">,</span>
            <span class="s1">self.__class__.__name__</span><span class="s2">,</span>
            <span class="s1">self.mode</span><span class="s2">,</span>
            <span class="s1">self.size[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">self.size[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">id(self)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_repr_pretty_(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">cycle):</span>
        <span class="s5">&quot;&quot;&quot;IPython plain text display support&quot;&quot;&quot;</span>

        <span class="s0"># Same as __repr__ but without unpredictable id(self),</span>
        <span class="s0"># to keep Jupyter notebook `text/plain` output stable.</span>
        <span class="s1">p.text(</span>
            <span class="s3">&quot;&lt;%s.%s image mode=%s size=%dx%d&gt;&quot;</span>
            <span class="s1">% (</span>
                <span class="s1">self.__class__.__module__</span><span class="s2">,</span>
                <span class="s1">self.__class__.__name__</span><span class="s2">,</span>
                <span class="s1">self.mode</span><span class="s2">,</span>
                <span class="s1">self.size[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">self.size[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_repr_png_(self):</span>
        <span class="s5">&quot;&quot;&quot;iPython display hook support 
 
        :returns: png version of the image as bytes 
        &quot;&quot;&quot;</span>
        <span class="s1">b = io.BytesIO()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.save(b</span><span class="s2">, </span><span class="s3">&quot;PNG&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">msg = </span><span class="s3">&quot;Could not save to PNG for display&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">return </span><span class="s1">b.getvalue()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">__array_interface__(self):</span>
        <span class="s0"># numpy array interface support</span>
        <span class="s1">new = {}</span>
        <span class="s1">shape</span><span class="s2">, </span><span class="s1">typestr = _conv_type_shape(self)</span>
        <span class="s1">new[</span><span class="s3">&quot;shape&quot;</span><span class="s1">] = shape</span>
        <span class="s1">new[</span><span class="s3">&quot;typestr&quot;</span><span class="s1">] = typestr</span>
        <span class="s1">new[</span><span class="s3">&quot;version&quot;</span><span class="s1">] = </span><span class="s4">3</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;1&quot;</span><span class="s1">:</span>
                <span class="s0"># Binary images need to be extended from bits to bytes</span>
                <span class="s0"># See: https://github.com/python-pillow/Pillow/issues/350</span>
                <span class="s1">new[</span><span class="s3">&quot;data&quot;</span><span class="s1">] = self.tobytes(</span><span class="s3">&quot;raw&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new[</span><span class="s3">&quot;data&quot;</span><span class="s1">] = self.tobytes()</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">if not </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">(MemoryError</span><span class="s2">, </span><span class="s1">RecursionError)):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">import </span><span class="s1">numpy</span>
                    <span class="s2">from </span><span class="s1">packaging.version </span><span class="s2">import </span><span class="s1">parse </span><span class="s2">as </span><span class="s1">parse_version</span>
                <span class="s2">except </span><span class="s1">ImportError:</span>
                    <span class="s2">pass</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">parse_version(numpy.__version__) &lt; parse_version(</span><span class="s3">&quot;1.23&quot;</span><span class="s1">):</span>
                        <span class="s1">warnings.warn(e)</span>
            <span class="s2">raise</span>
        <span class="s2">return </span><span class="s1">new</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s2">return </span><span class="s1">[self.info</span><span class="s2">, </span><span class="s1">self.mode</span><span class="s2">, </span><span class="s1">self.size</span><span class="s2">, </span><span class="s1">self.getpalette()</span><span class="s2">, </span><span class="s1">self.tobytes()]</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state):</span>
        <span class="s1">Image.__init__(self)</span>
        <span class="s1">info</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">palette</span><span class="s2">, </span><span class="s1">data = state</span>
        <span class="s1">self.info = info</span>
        <span class="s1">self.mode = mode</span>
        <span class="s1">self._size = size</span>
        <span class="s1">self.im = core.new(mode</span><span class="s2">, </span><span class="s1">size)</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;P&quot;</span><span class="s2">, </span><span class="s3">&quot;PA&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">palette:</span>
            <span class="s1">self.putpalette(palette)</span>
        <span class="s1">self.frombytes(data)</span>

    <span class="s2">def </span><span class="s1">tobytes(self</span><span class="s2">, </span><span class="s1">encoder_name=</span><span class="s3">&quot;raw&quot;</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return image as a bytes object. 
 
        .. warning:: 
 
            This method returns the raw image data from the internal 
            storage.  For compressed image data (e.g. PNG, JPEG) use 
            :meth:`~.save`, with a BytesIO parameter for in-memory 
            data. 
 
        :param encoder_name: What encoder to use.  The default is to 
                             use the standard &quot;raw&quot; encoder. 
 
                             A list of C encoders can be seen under 
                             codecs section of the function array in 
                             :file:`_imaging.c`. Python encoders are 
                             registered within the relevant plugins. 
        :param args: Extra arguments to the encoder. 
        :returns: A :py:class:`bytes` object. 
        &quot;&quot;&quot;</span>

        <span class="s0"># may pass tuple instead of argument list</span>
        <span class="s2">if </span><span class="s1">len(args) == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">isinstance(args[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s1">args = args[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">encoder_name == </span><span class="s3">&quot;raw&quot; </span><span class="s2">and </span><span class="s1">args == ():</span>
            <span class="s1">args = self.mode</span>

        <span class="s1">self.load()</span>

        <span class="s2">if </span><span class="s1">self.width == </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">self.height == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s6">b&quot;&quot;</span>

        <span class="s0"># unpack data</span>
        <span class="s1">e = _getencoder(self.mode</span><span class="s2">, </span><span class="s1">encoder_name</span><span class="s2">, </span><span class="s1">args)</span>
        <span class="s1">e.setimage(self.im)</span>

        <span class="s1">bufsize = max(</span><span class="s4">65536</span><span class="s2">, </span><span class="s1">self.size[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">4</span><span class="s1">)  </span><span class="s0"># see RawEncode.c</span>

        <span class="s1">data = []</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">l</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">d = e.encode(bufsize)</span>
            <span class="s1">data.append(d)</span>
            <span class="s2">if </span><span class="s1">s:</span>
                <span class="s2">break</span>
        <span class="s2">if </span><span class="s1">s &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">f&quot;encoder error </span><span class="s2">{</span><span class="s1">s</span><span class="s2">} </span><span class="s3">in tobytes&quot;</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(msg)</span>

        <span class="s2">return </span><span class="s6">b&quot;&quot;</span><span class="s1">.join(data)</span>

    <span class="s2">def </span><span class="s1">tobitmap(self</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;image&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the image converted to an X11 bitmap. 
 
        .. note:: This method only works for mode &quot;1&quot; images. 
 
        :param name: The name prefix to use for the bitmap variables. 
        :returns: A string containing an X11 bitmap. 
        :raises ValueError: If the mode is not &quot;1&quot; 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>
        <span class="s2">if </span><span class="s1">self.mode != </span><span class="s3">&quot;1&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;not a bitmap&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s1">data = self.tobytes(</span><span class="s3">&quot;xbm&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s6">b&quot;&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">f&quot;#define </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">_width </span><span class="s2">{</span><span class="s1">self.size[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">}\n</span><span class="s3">&quot;</span><span class="s1">.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">f&quot;#define </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">_height </span><span class="s2">{</span><span class="s1">self.size[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">}\n</span><span class="s3">&quot;</span><span class="s1">.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">f&quot;static char </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">_bits[] = </span><span class="s2">{{\n</span><span class="s3">&quot;</span><span class="s1">.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">data</span><span class="s2">,</span>
                <span class="s6">b&quot;};&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">frombytes(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">decoder_name=</span><span class="s3">&quot;raw&quot;</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s5">&quot;&quot;&quot; 
        Loads this image with pixel data from a bytes object. 
 
        This method is similar to the :py:func:`~PIL.Image.frombytes` function, 
        but loads data into this image instead of creating a new image object. 
        &quot;&quot;&quot;</span>

        <span class="s0"># may pass tuple instead of argument list</span>
        <span class="s2">if </span><span class="s1">len(args) == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">isinstance(args[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s1">args = args[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s0"># default format</span>
        <span class="s2">if </span><span class="s1">decoder_name == </span><span class="s3">&quot;raw&quot; </span><span class="s2">and </span><span class="s1">args == ():</span>
            <span class="s1">args = self.mode</span>

        <span class="s0"># unpack data</span>
        <span class="s1">d = _getdecoder(self.mode</span><span class="s2">, </span><span class="s1">decoder_name</span><span class="s2">, </span><span class="s1">args)</span>
        <span class="s1">d.setimage(self.im)</span>
        <span class="s1">s = d.decode(data)</span>

        <span class="s2">if </span><span class="s1">s[</span><span class="s4">0</span><span class="s1">] &gt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;not enough image data&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s2">if </span><span class="s1">s[</span><span class="s4">1</span><span class="s1">] != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;cannot decode image data&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s2">def </span><span class="s1">load(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Allocates storage for the image and loads the pixel data.  In 
        normal cases, you don't need to call this method, since the 
        Image class automatically loads an opened image when it is 
        accessed for the first time. 
 
        If the file associated with the image was opened by Pillow, then this 
        method will close it. The exception to this is if the image has 
        multiple frames, in which case the file will be left open for seek 
        operations. See :ref:`file-handling` for more information. 
 
        :returns: An image access object. 
        :rtype: :ref:`PixelAccess` or :py:class:`PIL.PyAccess` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.im </span><span class="s2">is not None and </span><span class="s1">self.palette </span><span class="s2">and </span><span class="s1">self.palette.dirty:</span>
            <span class="s0"># realize palette</span>
            <span class="s1">mode</span><span class="s2">, </span><span class="s1">arr = self.palette.getdata()</span>
            <span class="s1">self.im.putpalette(mode</span><span class="s2">, </span><span class="s1">arr)</span>
            <span class="s1">self.palette.dirty = </span><span class="s4">0</span>
            <span class="s1">self.palette.rawmode = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s3">&quot;transparency&quot; </span><span class="s2">in </span><span class="s1">self.info </span><span class="s2">and </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;PA&quot;</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">isinstance(self.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">int):</span>
                    <span class="s1">self.im.putpalettealpha(self.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.im.putpalettealphas(self.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">])</span>
                <span class="s1">self.palette.mode = </span><span class="s3">&quot;RGBA&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">palette_mode = </span><span class="s3">&quot;RGBA&quot; </span><span class="s2">if </span><span class="s1">mode.startswith(</span><span class="s3">&quot;RGBA&quot;</span><span class="s1">) </span><span class="s2">else </span><span class="s3">&quot;RGB&quot;</span>
                <span class="s1">self.palette.mode = palette_mode</span>
                <span class="s1">self.palette.palette = self.im.getpalette(palette_mode</span><span class="s2">, </span><span class="s1">palette_mode)</span>

        <span class="s2">if </span><span class="s1">self.im </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">cffi </span><span class="s2">and </span><span class="s1">USE_CFFI_ACCESS:</span>
                <span class="s2">if </span><span class="s1">self.pyaccess:</span>
                    <span class="s2">return </span><span class="s1">self.pyaccess</span>
                <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">PyAccess</span>

                <span class="s1">self.pyaccess = PyAccess.new(self</span><span class="s2">, </span><span class="s1">self.readonly)</span>
                <span class="s2">if </span><span class="s1">self.pyaccess:</span>
                    <span class="s2">return </span><span class="s1">self.pyaccess</span>
            <span class="s2">return </span><span class="s1">self.im.pixel_access(self.readonly)</span>

    <span class="s2">def </span><span class="s1">verify(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Verifies the contents of a file. For data read from a file, this 
        method attempts to determine if the file is broken, without 
        actually decoding the image data.  If this method finds any 
        problems, it raises suitable exceptions.  If you need to load 
        the image after using this method, you must reopen the image 
        file. 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">convert(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">mode=</span><span class="s2">None, </span><span class="s1">matrix=</span><span class="s2">None, </span><span class="s1">dither=</span><span class="s2">None, </span><span class="s1">palette=Palette.WEB</span><span class="s2">, </span><span class="s1">colors=</span><span class="s4">256</span>
    <span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns a converted copy of this image. For the &quot;P&quot; mode, this 
        method translates pixels through the palette.  If mode is 
        omitted, a mode is chosen so that all information in the image 
        and the palette can be represented without a palette. 
 
        The current version supports all possible conversions between 
        &quot;L&quot;, &quot;RGB&quot; and &quot;CMYK&quot;. The ``matrix`` argument only supports &quot;L&quot; 
        and &quot;RGB&quot;. 
 
        When translating a color image to greyscale (mode &quot;L&quot;), 
        the library uses the ITU-R 601-2 luma transform:: 
 
            L = R * 299/1000 + G * 587/1000 + B * 114/1000 
 
        The default method of converting a greyscale (&quot;L&quot;) or &quot;RGB&quot; 
        image into a bilevel (mode &quot;1&quot;) image uses Floyd-Steinberg 
        dither to approximate the original image luminosity levels. If 
        dither is ``None``, all values larger than 127 are set to 255 (white), 
        all other values to 0 (black). To use other thresholds, use the 
        :py:meth:`~PIL.Image.Image.point` method. 
 
        When converting from &quot;RGBA&quot; to &quot;P&quot; without a ``matrix`` argument, 
        this passes the operation to :py:meth:`~PIL.Image.Image.quantize`, 
        and ``dither`` and ``palette`` are ignored. 
 
        When converting from &quot;PA&quot;, if an &quot;RGBA&quot; palette is present, the alpha 
        channel from the image will be used instead of the values from the palette. 
 
        :param mode: The requested mode. See: :ref:`concept-modes`. 
        :param matrix: An optional conversion matrix.  If given, this 
           should be 4- or 12-tuple containing floating point values. 
        :param dither: Dithering method, used when converting from 
           mode &quot;RGB&quot; to &quot;P&quot; or from &quot;RGB&quot; or &quot;L&quot; to &quot;1&quot;. 
           Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG` 
           (default). Note that this is not used when ``matrix`` is supplied. 
        :param palette: Palette to use when converting from mode &quot;RGB&quot; 
           to &quot;P&quot;.  Available palettes are :data:`Palette.WEB` or 
           :data:`Palette.ADAPTIVE`. 
        :param colors: Number of colors to use for the :data:`Palette.ADAPTIVE` 
           palette. Defaults to 256. 
        :rtype: :py:class:`~PIL.Image.Image` 
        :returns: An :py:class:`~PIL.Image.Image` object. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>

        <span class="s1">has_transparency = self.info.get(</span><span class="s3">&quot;transparency&quot;</span><span class="s1">) </span><span class="s2">is not None</span>
        <span class="s2">if not </span><span class="s1">mode </span><span class="s2">and </span><span class="s1">self.mode == </span><span class="s3">&quot;P&quot;</span><span class="s1">:</span>
            <span class="s0"># determine default mode</span>
            <span class="s2">if </span><span class="s1">self.palette:</span>
                <span class="s1">mode = self.palette.mode</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">mode = </span><span class="s3">&quot;RGB&quot;</span>
            <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;RGB&quot; </span><span class="s2">and </span><span class="s1">has_transparency:</span>
                <span class="s1">mode = </span><span class="s3">&quot;RGBA&quot;</span>
        <span class="s2">if not </span><span class="s1">mode </span><span class="s2">or </span><span class="s1">(mode == self.mode </span><span class="s2">and not </span><span class="s1">matrix):</span>
            <span class="s2">return </span><span class="s1">self.copy()</span>

        <span class="s2">if </span><span class="s1">matrix:</span>
            <span class="s0"># matrix conversion</span>
            <span class="s2">if </span><span class="s1">mode </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;RGB&quot;</span><span class="s1">):</span>
                <span class="s1">msg = </span><span class="s3">&quot;illegal conversion&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s1">im = self.im.convert_matrix(mode</span><span class="s2">, </span><span class="s1">matrix)</span>
            <span class="s1">new = self._new(im)</span>
            <span class="s2">if </span><span class="s1">has_transparency </span><span class="s2">and </span><span class="s1">self.im.bands == </span><span class="s4">3</span><span class="s1">:</span>
                <span class="s1">transparency = new.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span>

                <span class="s2">def </span><span class="s1">convert_transparency(m</span><span class="s2">, </span><span class="s1">v):</span>
                    <span class="s1">v = m[</span><span class="s4">0</span><span class="s1">] * v[</span><span class="s4">0</span><span class="s1">] + m[</span><span class="s4">1</span><span class="s1">] * v[</span><span class="s4">1</span><span class="s1">] + m[</span><span class="s4">2</span><span class="s1">] * v[</span><span class="s4">2</span><span class="s1">] + m[</span><span class="s4">3</span><span class="s1">] * </span><span class="s4">0.5</span>
                    <span class="s2">return </span><span class="s1">max(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">min(</span><span class="s4">255</span><span class="s2">, </span><span class="s1">int(v)))</span>

                <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;L&quot;</span><span class="s1">:</span>
                    <span class="s1">transparency = convert_transparency(matrix</span><span class="s2">, </span><span class="s1">transparency)</span>
                <span class="s2">elif </span><span class="s1">len(mode) == </span><span class="s4">3</span><span class="s1">:</span>
                    <span class="s1">transparency = tuple(</span>
                        <span class="s1">convert_transparency(matrix[i * </span><span class="s4">4 </span><span class="s1">: i * </span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">transparency)</span>
                        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">len(transparency))</span>
                    <span class="s1">)</span>
                <span class="s1">new.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">] = transparency</span>
            <span class="s2">return </span><span class="s1">new</span>

        <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;P&quot; </span><span class="s2">and </span><span class="s1">self.mode == </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.quantize(colors)</span>

        <span class="s1">trns = </span><span class="s2">None</span>
        <span class="s1">delete_trns = </span><span class="s2">False</span>
        <span class="s0"># transparency handling</span>
        <span class="s2">if </span><span class="s1">has_transparency:</span>
            <span class="s2">if </span><span class="s1">(self.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;I&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">)) </span><span class="s2">or </span><span class="s1">(</span>
                <span class="s1">self.mode == </span><span class="s3">&quot;RGB&quot; </span><span class="s2">and </span><span class="s1">mode == </span><span class="s3">&quot;RGBA&quot;</span>
            <span class="s1">):</span>
                <span class="s0"># Use transparent conversion to promote from transparent</span>
                <span class="s0"># color to an alpha channel.</span>
                <span class="s1">new_im = self._new(</span>
                    <span class="s1">self.im.convert_transparent(mode</span><span class="s2">, </span><span class="s1">self.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">])</span>
                <span class="s1">)</span>
                <span class="s2">del </span><span class="s1">new_im.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span>
                <span class="s2">return </span><span class="s1">new_im</span>
            <span class="s2">elif </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;RGB&quot;</span><span class="s2">, </span><span class="s3">&quot;P&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;RGB&quot;</span><span class="s2">, </span><span class="s3">&quot;P&quot;</span><span class="s1">):</span>
                <span class="s1">t = self.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">bytes):</span>
                    <span class="s0"># Dragons. This can't be represented by a single color</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s3">&quot;Palette images with Transparency expressed in bytes should be &quot;</span>
                        <span class="s3">&quot;converted to RGBA images&quot;</span>
                    <span class="s1">)</span>
                    <span class="s1">delete_trns = </span><span class="s2">True</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s0"># get the new transparency color.</span>
                    <span class="s0"># use existing conversions</span>
                    <span class="s1">trns_im = Image()._new(core.new(self.mode</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)))</span>
                    <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;P&quot;</span><span class="s1">:</span>
                        <span class="s1">trns_im.putpalette(self.palette)</span>
                        <span class="s2">if </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">tuple):</span>
                            <span class="s1">err = </span><span class="s3">&quot;Couldn't allocate a palette color for transparency&quot;</span>
                            <span class="s2">try</span><span class="s1">:</span>
                                <span class="s1">t = trns_im.palette.getcolor(t</span><span class="s2">, </span><span class="s1">self)</span>
                            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
                                <span class="s2">if </span><span class="s1">str(e) == </span><span class="s3">&quot;cannot allocate more than 256 colors&quot;</span><span class="s1">:</span>
                                    <span class="s0"># If all 256 colors are in use,</span>
                                    <span class="s0"># then there is no need for transparency</span>
                                    <span class="s1">t = </span><span class="s2">None</span>
                                <span class="s2">else</span><span class="s1">:</span>
                                    <span class="s2">raise </span><span class="s1">ValueError(err) </span><span class="s2">from </span><span class="s1">e</span>
                    <span class="s2">if </span><span class="s1">t </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">trns = </span><span class="s2">None</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">trns_im.putpixel((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">t)</span>

                        <span class="s2">if </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;RGB&quot;</span><span class="s1">):</span>
                            <span class="s1">trns_im = trns_im.convert(mode)</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s0"># can't just retrieve the palette number, got to do it</span>
                            <span class="s0"># after quantization.</span>
                            <span class="s1">trns_im = trns_im.convert(</span><span class="s3">&quot;RGB&quot;</span><span class="s1">)</span>
                        <span class="s1">trns = trns_im.getpixel((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>

            <span class="s2">elif </span><span class="s1">self.mode == </span><span class="s3">&quot;P&quot; </span><span class="s2">and </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;PA&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">):</span>
                <span class="s1">t = self.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span>
                <span class="s1">delete_trns = </span><span class="s2">True</span>

                <span class="s2">if </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">bytes):</span>
                    <span class="s1">self.im.putpalettealphas(t)</span>
                <span class="s2">elif </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">int):</span>
                    <span class="s1">self.im.putpalettealpha(t</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">msg = </span><span class="s3">&quot;Transparency for P mode should be bytes or int&quot;</span>
                    <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;P&quot; </span><span class="s2">and </span><span class="s1">palette == Palette.ADAPTIVE:</span>
            <span class="s1">im = self.im.quantize(colors)</span>
            <span class="s1">new = self._new(im)</span>
            <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImagePalette</span>

            <span class="s1">new.palette = ImagePalette.ImagePalette(</span><span class="s3">&quot;RGB&quot;</span><span class="s2">, </span><span class="s1">new.im.getpalette(</span><span class="s3">&quot;RGB&quot;</span><span class="s1">))</span>
            <span class="s2">if </span><span class="s1">delete_trns:</span>
                <span class="s0"># This could possibly happen if we requantize to fewer colors.</span>
                <span class="s0"># The transparency would be totally off in that case.</span>
                <span class="s2">del </span><span class="s1">new.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">trns </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">new.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">] = new.palette.getcolor(trns</span><span class="s2">, </span><span class="s1">new)</span>
                <span class="s2">except </span><span class="s1">Exception:</span>
                    <span class="s0"># if we can't make a transparent color, don't leave the old</span>
                    <span class="s0"># transparency hanging around to mess us up.</span>
                    <span class="s2">del </span><span class="s1">new.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span>
                    <span class="s1">warnings.warn(</span><span class="s3">&quot;Couldn't allocate palette entry for transparency&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">new</span>

        <span class="s2">if </span><span class="s3">&quot;LAB&quot; </span><span class="s2">in </span><span class="s1">(self.mode</span><span class="s2">, </span><span class="s1">mode):</span>
            <span class="s1">other_mode = mode </span><span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;LAB&quot; </span><span class="s2">else </span><span class="s1">self.mode</span>
            <span class="s2">if </span><span class="s1">other_mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;RGB&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBX&quot;</span><span class="s1">):</span>
                <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImageCms</span>

                <span class="s1">srgb = ImageCms.createProfile(</span><span class="s3">&quot;sRGB&quot;</span><span class="s1">)</span>
                <span class="s1">lab = ImageCms.createProfile(</span><span class="s3">&quot;LAB&quot;</span><span class="s1">)</span>
                <span class="s1">profiles = [lab</span><span class="s2">, </span><span class="s1">srgb] </span><span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;LAB&quot; </span><span class="s2">else </span><span class="s1">[srgb</span><span class="s2">, </span><span class="s1">lab]</span>
                <span class="s1">transform = ImageCms.buildTransform(</span>
                    <span class="s1">profiles[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">profiles[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.mode</span><span class="s2">, </span><span class="s1">mode</span>
                <span class="s1">)</span>
                <span class="s2">return </span><span class="s1">transform.apply(self)</span>

        <span class="s0"># colorspace conversion</span>
        <span class="s2">if </span><span class="s1">dither </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dither = Dither.FLOYDSTEINBERG</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">im = self.im.convert(mode</span><span class="s2">, </span><span class="s1">dither)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s0"># normalize source image and try again</span>
                <span class="s1">modebase = getmodebase(self.mode)</span>
                <span class="s2">if </span><span class="s1">modebase == self.mode:</span>
                    <span class="s2">raise</span>
                <span class="s1">im = self.im.convert(modebase)</span>
                <span class="s1">im = im.convert(mode</span><span class="s2">, </span><span class="s1">dither)</span>
            <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">msg = </span><span class="s3">&quot;illegal conversion&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s1">new_im = self._new(im)</span>
        <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;P&quot; </span><span class="s2">and </span><span class="s1">palette != Palette.ADAPTIVE:</span>
            <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImagePalette</span>

            <span class="s1">new_im.palette = ImagePalette.ImagePalette(</span><span class="s3">&quot;RGB&quot;</span><span class="s2">, </span><span class="s1">list(range(</span><span class="s4">256</span><span class="s1">)) * </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">delete_trns:</span>
            <span class="s0"># crash fail if we leave a bytes transparency in an rgb/l mode.</span>
            <span class="s2">del </span><span class="s1">new_im.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">trns </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">new_im.mode == </span><span class="s3">&quot;P&quot;</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">new_im.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">] = new_im.palette.getcolor(trns</span><span class="s2">, </span><span class="s1">new_im)</span>
                <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s2">del </span><span class="s1">new_im.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span>
                    <span class="s2">if </span><span class="s1">str(e) != </span><span class="s3">&quot;cannot allocate more than 256 colors&quot;</span><span class="s1">:</span>
                        <span class="s0"># If all 256 colors are in use,</span>
                        <span class="s0"># then there is no need for transparency</span>
                        <span class="s1">warnings.warn(</span>
                            <span class="s3">&quot;Couldn't allocate palette entry for transparency&quot;</span>
                        <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_im.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">] = trns</span>
        <span class="s2">return </span><span class="s1">new_im</span>

    <span class="s2">def </span><span class="s1">quantize(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">colors=</span><span class="s4">256</span><span class="s2">,</span>
        <span class="s1">method=</span><span class="s2">None,</span>
        <span class="s1">kmeans=</span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">palette=</span><span class="s2">None,</span>
        <span class="s1">dither=Dither.FLOYDSTEINBERG</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert the image to 'P' mode with the specified number 
        of colors. 
 
        :param colors: The desired number of colors, &lt;= 256 
        :param method: :data:`Quantize.MEDIANCUT` (median cut), 
                       :data:`Quantize.MAXCOVERAGE` (maximum coverage), 
                       :data:`Quantize.FASTOCTREE` (fast octree), 
                       :data:`Quantize.LIBIMAGEQUANT` (libimagequant; check support 
                       using :py:func:`PIL.features.check_feature` with 
                       ``feature=&quot;libimagequant&quot;``). 
 
                       By default, :data:`Quantize.MEDIANCUT` will be used. 
 
                       The exception to this is RGBA images. :data:`Quantize.MEDIANCUT` 
                       and :data:`Quantize.MAXCOVERAGE` do not support RGBA images, so 
                       :data:`Quantize.FASTOCTREE` is used by default instead. 
        :param kmeans: Integer 
        :param palette: Quantize to the palette of given 
                        :py:class:`PIL.Image.Image`. 
        :param dither: Dithering method, used when converting from 
           mode &quot;RGB&quot; to &quot;P&quot; or from &quot;RGB&quot; or &quot;L&quot; to &quot;1&quot;. 
           Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG` 
           (default). 
        :returns: A new image 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>

        <span class="s2">if </span><span class="s1">method </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># defaults:</span>
            <span class="s1">method = Quantize.MEDIANCUT</span>
            <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">:</span>
                <span class="s1">method = Quantize.FASTOCTREE</span>

        <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;RGBA&quot; </span><span class="s2">and </span><span class="s1">method </span><span class="s2">not in </span><span class="s1">(</span>
            <span class="s1">Quantize.FASTOCTREE</span><span class="s2">,</span>
            <span class="s1">Quantize.LIBIMAGEQUANT</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s0"># Caller specified an invalid mode.</span>
            <span class="s1">msg = (</span>
                <span class="s3">&quot;Fast Octree (method == 2) and libimagequant (method == 3) &quot;</span>
                <span class="s3">&quot;are the only valid methods for quantizing RGBA images&quot;</span>
            <span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s2">if </span><span class="s1">palette:</span>
            <span class="s0"># use palette from reference image</span>
            <span class="s1">palette.load()</span>
            <span class="s2">if </span><span class="s1">palette.mode != </span><span class="s3">&quot;P&quot;</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s3">&quot;bad mode for palette image&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s2">if </span><span class="s1">self.mode != </span><span class="s3">&quot;RGB&quot; </span><span class="s2">and </span><span class="s1">self.mode != </span><span class="s3">&quot;L&quot;</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s3">&quot;only RGB or L mode images can be quantized to a palette&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s1">im = self.im.convert(</span><span class="s3">&quot;P&quot;</span><span class="s2">, </span><span class="s1">dither</span><span class="s2">, </span><span class="s1">palette.im)</span>
            <span class="s1">new_im = self._new(im)</span>
            <span class="s1">new_im.palette = palette.palette.copy()</span>
            <span class="s2">return </span><span class="s1">new_im</span>

        <span class="s1">im = self._new(self.im.quantize(colors</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">kmeans))</span>

        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImagePalette</span>

        <span class="s1">mode = im.im.getpalettemode()</span>
        <span class="s1">palette = im.im.getpalette(mode</span><span class="s2">, </span><span class="s1">mode)[: colors * len(mode)]</span>
        <span class="s1">im.palette = ImagePalette.ImagePalette(mode</span><span class="s2">, </span><span class="s1">palette)</span>

        <span class="s2">return </span><span class="s1">im</span>

    <span class="s2">def </span><span class="s1">copy(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Copies this image. Use this method if you wish to paste things 
        into an image, but still retain the original. 
 
        :rtype: :py:class:`~PIL.Image.Image` 
        :returns: An :py:class:`~PIL.Image.Image` object. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.load()</span>
        <span class="s2">return </span><span class="s1">self._new(self.im.copy())</span>

    <span class="s1">__copy__ = copy</span>

    <span class="s2">def </span><span class="s1">crop(self</span><span class="s2">, </span><span class="s1">box=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns a rectangular region from this image. The box is a 
        4-tuple defining the left, upper, right, and lower pixel 
        coordinate. See :ref:`coordinate-system`. 
 
        Note: Prior to Pillow 3.4.0, this was a lazy operation. 
 
        :param box: The crop rectangle, as a (left, upper, right, lower)-tuple. 
        :rtype: :py:class:`~PIL.Image.Image` 
        :returns: An :py:class:`~PIL.Image.Image` object. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">box </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.copy()</span>

        <span class="s2">if </span><span class="s1">box[</span><span class="s4">2</span><span class="s1">] &lt; box[</span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s1">msg = </span><span class="s3">&quot;Coordinate 'right' is less than 'left'&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s2">elif </span><span class="s1">box[</span><span class="s4">3</span><span class="s1">] &lt; box[</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">msg = </span><span class="s3">&quot;Coordinate 'lower' is less than 'upper'&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">self.load()</span>
        <span class="s2">return </span><span class="s1">self._new(self._crop(self.im</span><span class="s2">, </span><span class="s1">box))</span>

    <span class="s2">def </span><span class="s1">_crop(self</span><span class="s2">, </span><span class="s1">im</span><span class="s2">, </span><span class="s1">box):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns a rectangular region from the core image object im. 
 
        This is equivalent to calling im.crop((x0, y0, x1, y1)), but 
        includes additional sanity checks. 
 
        :param im: a core image object 
        :param box: The crop rectangle, as a (left, upper, right, lower)-tuple. 
        :returns: A core image object. 
        &quot;&quot;&quot;</span>

        <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = map(int</span><span class="s2">, </span><span class="s1">map(round</span><span class="s2">, </span><span class="s1">box))</span>

        <span class="s1">absolute_values = (abs(x1 - x0)</span><span class="s2">, </span><span class="s1">abs(y1 - y0))</span>

        <span class="s1">_decompression_bomb_check(absolute_values)</span>

        <span class="s2">return </span><span class="s1">im.crop((x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1))</span>

    <span class="s2">def </span><span class="s1">draft(self</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">size):</span>
        <span class="s5">&quot;&quot;&quot; 
        Configures the image file loader so it returns a version of the 
        image that as closely as possible matches the given mode and 
        size. For example, you can use this method to convert a color 
        JPEG to greyscale while loading it. 
 
        If any changes are made, returns a tuple with the chosen ``mode`` and 
        ``box`` with coordinates of the original image within the altered one. 
 
        Note that this method modifies the :py:class:`~PIL.Image.Image` object 
        in place. If the image has already been loaded, this method has no 
        effect. 
 
        Note: This method is not implemented for most images. It is 
        currently implemented only for JPEG and MPO images. 
 
        :param mode: The requested mode. 
        :param size: The requested size in pixels, as a 2-tuple: 
           (width, height). 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_expand(self</span><span class="s2">, </span><span class="s1">xmargin</span><span class="s2">, </span><span class="s1">ymargin=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">ymargin </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ymargin = xmargin</span>
        <span class="s1">self.load()</span>
        <span class="s2">return </span><span class="s1">self._new(self.im.expand(xmargin</span><span class="s2">, </span><span class="s1">ymargin</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">filter(self</span><span class="s2">, </span><span class="s1">filter):</span>
        <span class="s5">&quot;&quot;&quot; 
        Filters this image using the given filter.  For a list of 
        available filters, see the :py:mod:`~PIL.ImageFilter` module. 
 
        :param filter: Filter kernel. 
        :returns: An :py:class:`~PIL.Image.Image` object.&quot;&quot;&quot;</span>

        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImageFilter</span>

        <span class="s1">self.load()</span>

        <span class="s2">if </span><span class="s1">isinstance(filter</span><span class="s2">, </span><span class="s1">Callable):</span>
            <span class="s1">filter = filter()</span>
        <span class="s2">if not </span><span class="s1">hasattr(filter</span><span class="s2">, </span><span class="s3">&quot;filter&quot;</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s3">&quot;filter argument should be ImageFilter.Filter instance or class&quot;</span>
            <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s1">multiband = isinstance(filter</span><span class="s2">, </span><span class="s1">ImageFilter.MultibandFilter)</span>
        <span class="s2">if </span><span class="s1">self.im.bands == </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">multiband:</span>
            <span class="s2">return </span><span class="s1">self._new(filter.filter(self.im))</span>

        <span class="s1">ims = []</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range(self.im.bands):</span>
            <span class="s1">ims.append(self._new(filter.filter(self.im.getband(c))))</span>
        <span class="s2">return </span><span class="s1">merge(self.mode</span><span class="s2">, </span><span class="s1">ims)</span>

    <span class="s2">def </span><span class="s1">getbands(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns a tuple containing the name of each band in this image. 
        For example, ``getbands`` on an RGB image returns (&quot;R&quot;, &quot;G&quot;, &quot;B&quot;). 
 
        :returns: A tuple containing band names. 
        :rtype: tuple 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">ImageMode.getmode(self.mode).bands</span>

    <span class="s2">def </span><span class="s1">getbbox(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Calculates the bounding box of the non-zero regions in the 
        image. 
 
        :returns: The bounding box is returned as a 4-tuple defining the 
           left, upper, right, and lower pixel coordinate. See 
           :ref:`coordinate-system`. If the image is completely empty, this 
           method returns None. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>
        <span class="s2">return </span><span class="s1">self.im.getbbox()</span>

    <span class="s2">def </span><span class="s1">getcolors(self</span><span class="s2">, </span><span class="s1">maxcolors=</span><span class="s4">256</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns a list of colors used in this image. 
 
        The colors will be in the image's mode. For example, an RGB image will 
        return a tuple of (red, green, blue) color values, and a P image will 
        return the index of the color in the palette. 
 
        :param maxcolors: Maximum number of colors.  If this number is 
           exceeded, this method returns None.  The default limit is 
           256 colors. 
        :returns: An unsorted list of (count, pixel) values. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>
        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;P&quot;</span><span class="s1">):</span>
            <span class="s1">h = self.im.histogram()</span>
            <span class="s1">out = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">256</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">h[i]:</span>
                    <span class="s1">out.append((h[i]</span><span class="s2">, </span><span class="s1">i))</span>
            <span class="s2">if </span><span class="s1">len(out) &gt; maxcolors:</span>
                <span class="s2">return None</span>
            <span class="s2">return </span><span class="s1">out</span>
        <span class="s2">return </span><span class="s1">self.im.getcolors(maxcolors)</span>

    <span class="s2">def </span><span class="s1">getdata(self</span><span class="s2">, </span><span class="s1">band=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the contents of this image as a sequence object 
        containing pixel values.  The sequence object is flattened, so 
        that values for line one follow directly after the values of 
        line zero, and so on. 
 
        Note that the sequence object returned by this method is an 
        internal PIL data type, which only supports certain sequence 
        operations.  To convert it to an ordinary sequence (e.g. for 
        printing), use ``list(im.getdata())``. 
 
        :param band: What band to return.  The default is to return 
           all bands.  To return a single band, pass in the index 
           value (e.g. 0 to get the &quot;R&quot; band from an &quot;RGB&quot; image). 
        :returns: A sequence-like object. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>
        <span class="s2">if </span><span class="s1">band </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.im.getband(band)</span>
        <span class="s2">return </span><span class="s1">self.im  </span><span class="s0"># could be abused</span>

    <span class="s2">def </span><span class="s1">getextrema(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Gets the minimum and maximum pixel values for each band in 
        the image. 
 
        :returns: For a single-band image, a 2-tuple containing the 
           minimum and maximum pixel value.  For a multi-band image, 
           a tuple containing one 2-tuple for each band. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>
        <span class="s2">if </span><span class="s1">self.im.bands &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">extrema = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.im.bands):</span>
                <span class="s1">extrema.append(self.im.getband(i).getextrema())</span>
            <span class="s2">return </span><span class="s1">tuple(extrema)</span>
        <span class="s2">return </span><span class="s1">self.im.getextrema()</span>

    <span class="s2">def </span><span class="s1">_getxmp(self</span><span class="s2">, </span><span class="s1">xmp_tags):</span>
        <span class="s2">def </span><span class="s1">get_name(tag):</span>
            <span class="s2">return </span><span class="s1">tag.split(</span><span class="s3">&quot;}&quot;</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">get_value(element):</span>
            <span class="s1">value = {get_name(k): v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">element.attrib.items()}</span>
            <span class="s1">children = list(element)</span>
            <span class="s2">if </span><span class="s1">children:</span>
                <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">children:</span>
                    <span class="s1">name = get_name(child.tag)</span>
                    <span class="s1">child_value = get_value(child)</span>
                    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">value:</span>
                        <span class="s2">if not </span><span class="s1">isinstance(value[name]</span><span class="s2">, </span><span class="s1">list):</span>
                            <span class="s1">value[name] = [value[name]]</span>
                        <span class="s1">value[name].append(child_value)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">value[name] = child_value</span>
            <span class="s2">elif </span><span class="s1">value:</span>
                <span class="s2">if </span><span class="s1">element.text:</span>
                    <span class="s1">value[</span><span class="s3">&quot;text&quot;</span><span class="s1">] = element.text</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">element.text</span>
            <span class="s2">return </span><span class="s1">value</span>

        <span class="s2">if </span><span class="s1">ElementTree </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s3">&quot;XMP data cannot be read without defusedxml dependency&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">{}</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">root = ElementTree.fromstring(xmp_tags)</span>
            <span class="s2">return </span><span class="s1">{get_name(root.tag): get_value(root)}</span>

    <span class="s2">def </span><span class="s1">getexif(self):</span>
        <span class="s2">if </span><span class="s1">self._exif </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._exif = Exif()</span>
            <span class="s1">self._exif._loaded = </span><span class="s2">False</span>
        <span class="s2">elif </span><span class="s1">self._exif._loaded:</span>
            <span class="s2">return </span><span class="s1">self._exif</span>
        <span class="s1">self._exif._loaded = </span><span class="s2">True</span>

        <span class="s1">exif_info = self.info.get(</span><span class="s3">&quot;exif&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">exif_info </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s3">&quot;Raw profile type exif&quot; </span><span class="s2">in </span><span class="s1">self.info:</span>
                <span class="s1">exif_info = bytes.fromhex(</span>
                    <span class="s3">&quot;&quot;</span><span class="s1">.join(self.info[</span><span class="s3">&quot;Raw profile type exif&quot;</span><span class="s1">].split(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)[</span><span class="s4">3</span><span class="s1">:])</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;tag_v2&quot;</span><span class="s1">):</span>
                <span class="s1">self._exif.bigtiff = self.tag_v2._bigtiff</span>
                <span class="s1">self._exif.endian = self.tag_v2._endian</span>
                <span class="s1">self._exif.load_from_fp(self.fp</span><span class="s2">, </span><span class="s1">self.tag_v2._offset)</span>
        <span class="s2">if </span><span class="s1">exif_info </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._exif.load(exif_info)</span>

        <span class="s0"># XMP tags</span>
        <span class="s2">if </span><span class="s4">0x0112 </span><span class="s2">not in </span><span class="s1">self._exif:</span>
            <span class="s1">xmp_tags = self.info.get(</span><span class="s3">&quot;XML:com.adobe.xmp&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">xmp_tags:</span>
                <span class="s1">match = re.search(</span><span class="s3">r'tiff:Orientation(=&quot;|&gt;)([0-9])'</span><span class="s2">, </span><span class="s1">xmp_tags)</span>
                <span class="s2">if </span><span class="s1">match:</span>
                    <span class="s1">self._exif[</span><span class="s4">0x0112</span><span class="s1">] = int(match[</span><span class="s4">2</span><span class="s1">])</span>

        <span class="s2">return </span><span class="s1">self._exif</span>

    <span class="s2">def </span><span class="s1">_reload_exif(self):</span>
        <span class="s2">if </span><span class="s1">self._exif </span><span class="s2">is None or not </span><span class="s1">self._exif._loaded:</span>
            <span class="s2">return</span>
        <span class="s1">self._exif._loaded = </span><span class="s2">False</span>
        <span class="s1">self.getexif()</span>

    <span class="s2">def </span><span class="s1">get_child_images(self):</span>
        <span class="s1">child_images = []</span>
        <span class="s1">exif = self.getexif()</span>
        <span class="s1">ifds = []</span>
        <span class="s2">if </span><span class="s1">ExifTags.Base.SubIFDs </span><span class="s2">in </span><span class="s1">exif:</span>
            <span class="s1">subifd_offsets = exif[ExifTags.Base.SubIFDs]</span>
            <span class="s2">if </span><span class="s1">subifd_offsets:</span>
                <span class="s2">if not </span><span class="s1">isinstance(subifd_offsets</span><span class="s2">, </span><span class="s1">tuple):</span>
                    <span class="s1">subifd_offsets = (subifd_offsets</span><span class="s2">,</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">subifd_offset </span><span class="s2">in </span><span class="s1">subifd_offsets:</span>
                    <span class="s1">ifds.append((exif._get_ifd_dict(subifd_offset)</span><span class="s2">, </span><span class="s1">subifd_offset))</span>
        <span class="s1">ifd1 = exif.get_ifd(ExifTags.IFD.IFD1)</span>
        <span class="s2">if </span><span class="s1">ifd1 </span><span class="s2">and </span><span class="s1">ifd1.get(</span><span class="s4">513</span><span class="s1">):</span>
            <span class="s1">ifds.append((ifd1</span><span class="s2">, </span><span class="s1">exif._info.next))</span>

        <span class="s1">offset = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">ifd</span><span class="s2">, </span><span class="s1">ifd_offset </span><span class="s2">in </span><span class="s1">ifds:</span>
            <span class="s1">current_offset = self.fp.tell()</span>
            <span class="s2">if </span><span class="s1">offset </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">offset = current_offset</span>

            <span class="s1">fp = self.fp</span>
            <span class="s1">thumbnail_offset = ifd.get(</span><span class="s4">513</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">thumbnail_offset </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">thumbnail_offset += self._exif_offset</span>
                <span class="s2">except </span><span class="s1">AttributeError:</span>
                    <span class="s2">pass</span>
                <span class="s1">self.fp.seek(thumbnail_offset)</span>
                <span class="s1">data = self.fp.read(ifd.get(</span><span class="s4">514</span><span class="s1">))</span>
                <span class="s1">fp = io.BytesIO(data)</span>

            <span class="s2">with </span><span class="s1">open(fp) </span><span class="s2">as </span><span class="s1">im:</span>
                <span class="s2">if </span><span class="s1">thumbnail_offset </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">im._frame_pos = [ifd_offset]</span>
                    <span class="s1">im._seek(</span><span class="s4">0</span><span class="s1">)</span>
                <span class="s1">im.load()</span>
                <span class="s1">child_images.append(im)</span>

        <span class="s2">if </span><span class="s1">offset </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.fp.seek(offset)</span>
        <span class="s2">return </span><span class="s1">child_images</span>

    <span class="s2">def </span><span class="s1">getim(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns a capsule that points to the internal image memory. 
 
        :returns: A capsule object. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>
        <span class="s2">return </span><span class="s1">self.im.ptr</span>

    <span class="s2">def </span><span class="s1">getpalette(self</span><span class="s2">, </span><span class="s1">rawmode=</span><span class="s3">&quot;RGB&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the image palette as a list. 
 
        :param rawmode: The mode in which to return the palette. ``None`` will 
           return the palette in its current mode. 
 
           .. versionadded:: 9.1.0 
 
        :returns: A list of color values [r, g, b, ...], or None if the 
           image has no palette. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">mode = self.im.getpalettemode()</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">return None  </span><span class="s0"># no palette</span>
        <span class="s2">if </span><span class="s1">rawmode </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rawmode = mode</span>
        <span class="s2">return </span><span class="s1">list(self.im.getpalette(mode</span><span class="s2">, </span><span class="s1">rawmode))</span>

    <span class="s2">def </span><span class="s1">apply_transparency(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        If a P mode image has a &quot;transparency&quot; key in the info dictionary, 
        remove the key and instead apply the transparency to the palette. 
        Otherwise, the image is unchanged. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.mode != </span><span class="s3">&quot;P&quot; </span><span class="s2">or </span><span class="s3">&quot;transparency&quot; </span><span class="s2">not in </span><span class="s1">self.info:</span>
            <span class="s2">return</span>

        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImagePalette</span>

        <span class="s1">palette = self.getpalette(</span><span class="s3">&quot;RGBA&quot;</span><span class="s1">)</span>
        <span class="s1">transparency = self.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">isinstance(transparency</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">alpha </span><span class="s2">in </span><span class="s1">enumerate(transparency):</span>
                <span class="s1">palette[i * </span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">3</span><span class="s1">] = alpha</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">palette[transparency * </span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">3</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s1">self.palette = ImagePalette.ImagePalette(</span><span class="s3">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s1">bytes(palette))</span>
        <span class="s1">self.palette.dirty = </span><span class="s4">1</span>

        <span class="s2">del </span><span class="s1">self.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">getpixel(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the pixel value at a given position. 
 
        :param xy: The coordinate, given as (x, y). See 
           :ref:`coordinate-system`. 
        :returns: The pixel value.  If the image is a multi-layer image, 
           this method returns a tuple. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>
        <span class="s2">if </span><span class="s1">self.pyaccess:</span>
            <span class="s2">return </span><span class="s1">self.pyaccess.getpixel(xy)</span>
        <span class="s2">return </span><span class="s1">self.im.getpixel(xy)</span>

    <span class="s2">def </span><span class="s1">getprojection(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get projection to x and y axes 
 
        :returns: Two sequences, indicating where there are non-zero 
            pixels along the X-axis and the Y-axis, respectively. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self.im.getprojection()</span>
        <span class="s2">return </span><span class="s1">list(x)</span><span class="s2">, </span><span class="s1">list(y)</span>

    <span class="s2">def </span><span class="s1">histogram(self</span><span class="s2">, </span><span class="s1">mask=</span><span class="s2">None, </span><span class="s1">extrema=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns a histogram for the image. The histogram is returned as a 
        list of pixel counts, one for each pixel value in the source 
        image. Counts are grouped into 256 bins for each band, even if 
        the image has more than 8 bits per band. If the image has more 
        than one band, the histograms for all bands are concatenated (for 
        example, the histogram for an &quot;RGB&quot; image contains 768 values). 
 
        A bilevel image (mode &quot;1&quot;) is treated as a greyscale (&quot;L&quot;) image 
        by this method. 
 
        If a mask is provided, the method returns a histogram for those 
        parts of the image where the mask image is non-zero. The mask 
        image must have the same size as the image, and be either a 
        bi-level image (mode &quot;1&quot;) or a greyscale image (&quot;L&quot;). 
 
        :param mask: An optional mask. 
        :param extrema: An optional tuple of manually-specified extrema. 
        :returns: A list containing pixel counts. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.load()</span>
        <span class="s2">if </span><span class="s1">mask:</span>
            <span class="s1">mask.load()</span>
            <span class="s2">return </span><span class="s1">self.im.histogram((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">mask.im)</span>
        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;F&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">extrema </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">extrema = self.getextrema()</span>
            <span class="s2">return </span><span class="s1">self.im.histogram(extrema)</span>
        <span class="s2">return </span><span class="s1">self.im.histogram()</span>

    <span class="s2">def </span><span class="s1">entropy(self</span><span class="s2">, </span><span class="s1">mask=</span><span class="s2">None, </span><span class="s1">extrema=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Calculates and returns the entropy for the image. 
 
        A bilevel image (mode &quot;1&quot;) is treated as a greyscale (&quot;L&quot;) 
        image by this method. 
 
        If a mask is provided, the method employs the histogram for 
        those parts of the image where the mask image is non-zero. 
        The mask image must have the same size as the image, and be 
        either a bi-level image (mode &quot;1&quot;) or a greyscale image (&quot;L&quot;). 
 
        :param mask: An optional mask. 
        :param extrema: An optional tuple of manually-specified extrema. 
        :returns: A float value representing the image entropy 
        &quot;&quot;&quot;</span>
        <span class="s1">self.load()</span>
        <span class="s2">if </span><span class="s1">mask:</span>
            <span class="s1">mask.load()</span>
            <span class="s2">return </span><span class="s1">self.im.entropy((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">mask.im)</span>
        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;F&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">extrema </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">extrema = self.getextrema()</span>
            <span class="s2">return </span><span class="s1">self.im.entropy(extrema)</span>
        <span class="s2">return </span><span class="s1">self.im.entropy()</span>

    <span class="s2">def </span><span class="s1">paste(self</span><span class="s2">, </span><span class="s1">im</span><span class="s2">, </span><span class="s1">box=</span><span class="s2">None, </span><span class="s1">mask=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Pastes another image into this image. The box argument is either 
        a 2-tuple giving the upper left corner, a 4-tuple defining the 
        left, upper, right, and lower pixel coordinate, or None (same as 
        (0, 0)). See :ref:`coordinate-system`. If a 4-tuple is given, the size 
        of the pasted image must match the size of the region. 
 
        If the modes don't match, the pasted image is converted to the mode of 
        this image (see the :py:meth:`~PIL.Image.Image.convert` method for 
        details). 
 
        Instead of an image, the source can be a integer or tuple 
        containing pixel values.  The method then fills the region 
        with the given color.  When creating RGB images, you can 
        also use color strings as supported by the ImageColor module. 
 
        If a mask is given, this method updates only the regions 
        indicated by the mask. You can use either &quot;1&quot;, &quot;L&quot;, &quot;LA&quot;, &quot;RGBA&quot; 
        or &quot;RGBa&quot; images (if present, the alpha band is used as mask). 
        Where the mask is 255, the given image is copied as is.  Where 
        the mask is 0, the current value is preserved.  Intermediate 
        values will mix the two images together, including their alpha 
        channels if they have them. 
 
        See :py:meth:`~PIL.Image.Image.alpha_composite` if you want to 
        combine images with respect to their alpha channels. 
 
        :param im: Source image or pixel value (integer or tuple). 
        :param box: An optional 4-tuple giving the region to paste into. 
           If a 2-tuple is used instead, it's treated as the upper left 
           corner.  If omitted or None, the source is pasted into the 
           upper left corner. 
 
           If an image is given as the second argument and there is no 
           third, the box defaults to (0, 0), and the second argument 
           is interpreted as a mask image. 
        :param mask: An optional mask image. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">isImageType(box) </span><span class="s2">and </span><span class="s1">mask </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># abbreviated paste(im, mask) syntax</span>
            <span class="s1">mask = box</span>
            <span class="s1">box = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">box </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">box = (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">len(box) == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s0"># upper left corner given; get size from image or mask</span>
            <span class="s2">if </span><span class="s1">isImageType(im):</span>
                <span class="s1">size = im.size</span>
            <span class="s2">elif </span><span class="s1">isImageType(mask):</span>
                <span class="s1">size = mask.size</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># FIXME: use self.size here?</span>
                <span class="s1">msg = </span><span class="s3">&quot;cannot determine region size; use 4-item box&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s1">box += (box[</span><span class="s4">0</span><span class="s1">] + size[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">box[</span><span class="s4">1</span><span class="s1">] + size[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s2">if </span><span class="s1">isinstance(im</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImageColor</span>

            <span class="s1">im = ImageColor.getcolor(im</span><span class="s2">, </span><span class="s1">self.mode)</span>

        <span class="s2">elif </span><span class="s1">isImageType(im):</span>
            <span class="s1">im.load()</span>
            <span class="s2">if </span><span class="s1">self.mode != im.mode:</span>
                <span class="s2">if </span><span class="s1">self.mode != </span><span class="s3">&quot;RGB&quot; </span><span class="s2">or </span><span class="s1">im.mode </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBa&quot;</span><span class="s1">):</span>
                    <span class="s0"># should use an adapter for this!</span>
                    <span class="s1">im = im.convert(self.mode)</span>
            <span class="s1">im = im.im</span>

        <span class="s1">self._ensure_mutable()</span>

        <span class="s2">if </span><span class="s1">mask:</span>
            <span class="s1">mask.load()</span>
            <span class="s1">self.im.paste(im</span><span class="s2">, </span><span class="s1">box</span><span class="s2">, </span><span class="s1">mask.im)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.im.paste(im</span><span class="s2">, </span><span class="s1">box)</span>

    <span class="s2">def </span><span class="s1">alpha_composite(self</span><span class="s2">, </span><span class="s1">im</span><span class="s2">, </span><span class="s1">dest=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">source=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)):</span>
        <span class="s5">&quot;&quot;&quot;'In-place' analog of Image.alpha_composite. Composites an image 
        onto this image. 
 
        :param im: image to composite over this one 
        :param dest: Optional 2 tuple (left, top) specifying the upper 
          left corner in this (destination) image. 
        :param source: Optional 2 (left, top) tuple for the upper left 
          corner in the overlay source image, or 4 tuple (left, top, right, 
          bottom) for the bounds of the source rectangle 
 
        Performance Note: Not currently implemented in-place in the core layer. 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">isinstance(source</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
            <span class="s1">msg = </span><span class="s3">&quot;Source must be a tuple&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s2">if not </span><span class="s1">isinstance(dest</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
            <span class="s1">msg = </span><span class="s3">&quot;Destination must be a tuple&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s2">if not </span><span class="s1">len(source) </span><span class="s2">in </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s3">&quot;Source must be a 2 or 4-tuple&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s2">if not </span><span class="s1">len(dest) == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;Destination must be a 2-tuple&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s2">if </span><span class="s1">min(source) &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;Source must be non-negative&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s2">if </span><span class="s1">len(source) == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">source = source + im.size</span>

        <span class="s0"># over image, crop if it's not the whole thing.</span>
        <span class="s2">if </span><span class="s1">source == (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + im.size:</span>
            <span class="s1">overlay = im</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">overlay = im.crop(source)</span>

        <span class="s0"># target for the paste</span>
        <span class="s1">box = dest + (dest[</span><span class="s4">0</span><span class="s1">] + overlay.width</span><span class="s2">, </span><span class="s1">dest[</span><span class="s4">1</span><span class="s1">] + overlay.height)</span>

        <span class="s0"># destination image. don't copy if we're using the whole image.</span>
        <span class="s2">if </span><span class="s1">box == (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + self.size:</span>
            <span class="s1">background = self</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">background = self.crop(box)</span>

        <span class="s1">result = alpha_composite(background</span><span class="s2">, </span><span class="s1">overlay)</span>
        <span class="s1">self.paste(result</span><span class="s2">, </span><span class="s1">box)</span>

    <span class="s2">def </span><span class="s1">point(self</span><span class="s2">, </span><span class="s1">lut</span><span class="s2">, </span><span class="s1">mode=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Maps this image through a lookup table or function. 
 
        :param lut: A lookup table, containing 256 (or 65536 if 
           self.mode==&quot;I&quot; and mode == &quot;L&quot;) values per band in the 
           image.  A function can be used instead, it should take a 
           single argument. The function is called once for each 
           possible pixel value, and the resulting table is applied to 
           all bands of the image. 
 
           It may also be an :py:class:`~PIL.Image.ImagePointHandler` 
           object:: 
 
               class Example(Image.ImagePointHandler): 
                 def point(self, data): 
                   # Return result 
        :param mode: Output mode (default is same as input).  In the 
           current version, this can only be used if the source image 
           has mode &quot;L&quot; or &quot;P&quot;, and the output has mode &quot;1&quot; or the 
           source image mode is &quot;I&quot; and the output mode is &quot;L&quot;. 
        :returns: An :py:class:`~PIL.Image.Image` object. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>

        <span class="s2">if </span><span class="s1">isinstance(lut</span><span class="s2">, </span><span class="s1">ImagePointHandler):</span>
            <span class="s2">return </span><span class="s1">lut.point(self)</span>

        <span class="s2">if </span><span class="s1">callable(lut):</span>
            <span class="s0"># if it isn't a list, it should be a function</span>
            <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;I;16&quot;</span><span class="s2">, </span><span class="s3">&quot;F&quot;</span><span class="s1">):</span>
                <span class="s0"># check if the function can be used with point_transform</span>
                <span class="s0"># UNDONE wiredfool -- I think this prevents us from ever doing</span>
                <span class="s0"># a gamma function point transform on &gt; 8bit images.</span>
                <span class="s1">scale</span><span class="s2">, </span><span class="s1">offset = _getscaleoffset(lut)</span>
                <span class="s2">return </span><span class="s1">self._new(self.im.point_transform(scale</span><span class="s2">, </span><span class="s1">offset))</span>
            <span class="s0"># for other modes, convert the function to a table</span>
            <span class="s1">lut = [lut(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">256</span><span class="s1">)] * self.im.bands</span>

        <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;F&quot;</span><span class="s1">:</span>
            <span class="s0"># FIXME: _imaging returns a confusing error message for this case</span>
            <span class="s1">msg = </span><span class="s3">&quot;point operation not supported for this mode&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s2">if </span><span class="s1">mode != </span><span class="s3">&quot;F&quot;</span><span class="s1">:</span>
            <span class="s1">lut = [round(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">lut]</span>
        <span class="s2">return </span><span class="s1">self._new(self.im.point(lut</span><span class="s2">, </span><span class="s1">mode))</span>

    <span class="s2">def </span><span class="s1">putalpha(self</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s5">&quot;&quot;&quot; 
        Adds or replaces the alpha layer in this image.  If the image 
        does not have an alpha layer, it's converted to &quot;LA&quot; or &quot;RGBA&quot;. 
        The new layer must be either &quot;L&quot; or &quot;1&quot;. 
 
        :param alpha: The new alpha layer.  This can either be an &quot;L&quot; or &quot;1&quot; 
           image having the same size as this image, or an integer or 
           other color value. 
        &quot;&quot;&quot;</span>

        <span class="s1">self._ensure_mutable()</span>

        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;PA&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">):</span>
            <span class="s0"># attempt to promote self to a matching alpha mode</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">mode = getmodebase(self.mode) + </span><span class="s3">&quot;A&quot;</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">self.im.setmode(mode)</span>
                <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">ValueError) </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s0"># do things the hard way</span>
                    <span class="s1">im = self.im.convert(mode)</span>
                    <span class="s2">if </span><span class="s1">im.mode </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;PA&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">):</span>
                        <span class="s2">raise </span><span class="s1">ValueError </span><span class="s2">from </span><span class="s1">e  </span><span class="s0"># sanity check</span>
                    <span class="s1">self.im = im</span>
                <span class="s1">self.pyaccess = </span><span class="s2">None</span>
                <span class="s1">self.mode = self.im.mode</span>
            <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">msg = </span><span class="s3">&quot;illegal image mode&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;PA&quot;</span><span class="s1">):</span>
            <span class="s1">band = </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">band = </span><span class="s4">3</span>

        <span class="s2">if </span><span class="s1">isImageType(alpha):</span>
            <span class="s0"># alpha layer</span>
            <span class="s2">if </span><span class="s1">alpha.mode </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s1">):</span>
                <span class="s1">msg = </span><span class="s3">&quot;illegal image mode&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s1">alpha.load()</span>
            <span class="s2">if </span><span class="s1">alpha.mode == </span><span class="s3">&quot;1&quot;</span><span class="s1">:</span>
                <span class="s1">alpha = alpha.convert(</span><span class="s3">&quot;L&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># constant alpha</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.im.fillband(band</span><span class="s2">, </span><span class="s1">alpha)</span>
            <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
                <span class="s0"># do things the hard way</span>
                <span class="s1">alpha = new(</span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s1">self.size</span><span class="s2">, </span><span class="s1">alpha)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return</span>

        <span class="s1">self.im.putband(alpha.im</span><span class="s2">, </span><span class="s1">band)</span>

    <span class="s2">def </span><span class="s1">putdata(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">offset=</span><span class="s4">0.0</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Copies pixel data from a flattened sequence object into the image. The 
        values should start at the upper left corner (0, 0), continue to the 
        end of the line, followed directly by the first value of the second 
        line, and so on. Data will be read until either the image or the 
        sequence ends. The scale and offset values are used to adjust the 
        sequence values: **pixel = value*scale + offset**. 
 
        :param data: A flattened sequence object. 
        :param scale: An optional scale value.  The default is 1.0. 
        :param offset: An optional offset value.  The default is 0.0. 
        &quot;&quot;&quot;</span>

        <span class="s1">self._ensure_mutable()</span>

        <span class="s1">self.im.putdata(data</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">offset)</span>

    <span class="s2">def </span><span class="s1">putpalette(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">rawmode=</span><span class="s3">&quot;RGB&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Attaches a palette to this image.  The image must be a &quot;P&quot;, &quot;PA&quot;, &quot;L&quot; 
        or &quot;LA&quot; image. 
 
        The palette sequence must contain at most 256 colors, made up of one 
        integer value for each channel in the raw mode. 
        For example, if the raw mode is &quot;RGB&quot;, then it can contain at most 768 
        values, made up of red, green and blue values for the corresponding pixel 
        index in the 256 colors. 
        If the raw mode is &quot;RGBA&quot;, then it can contain at most 1024 values, 
        containing red, green, blue and alpha values. 
 
        Alternatively, an 8-bit string may be used instead of an integer sequence. 
 
        :param data: A palette sequence (either a list or a string). 
        :param rawmode: The raw mode of the palette. Either &quot;RGB&quot;, &quot;RGBA&quot;, or a mode 
           that can be transformed to &quot;RGB&quot; or &quot;RGBA&quot; (e.g. &quot;R&quot;, &quot;BGR;15&quot;, &quot;RGBA;L&quot;). 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImagePalette</span>

        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;P&quot;</span><span class="s2">, </span><span class="s3">&quot;PA&quot;</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s3">&quot;illegal image mode&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">ImagePalette.ImagePalette):</span>
            <span class="s1">palette = ImagePalette.raw(data.rawmode</span><span class="s2">, </span><span class="s1">data.palette)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">bytes):</span>
                <span class="s1">data = bytes(data)</span>
            <span class="s1">palette = ImagePalette.raw(rawmode</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s1">self.mode = </span><span class="s3">&quot;PA&quot; </span><span class="s2">if </span><span class="s3">&quot;A&quot; </span><span class="s2">in </span><span class="s1">self.mode </span><span class="s2">else </span><span class="s3">&quot;P&quot;</span>
        <span class="s1">self.palette = palette</span>
        <span class="s1">self.palette.mode = </span><span class="s3">&quot;RGB&quot;</span>
        <span class="s1">self.load()  </span><span class="s0"># install new palette</span>

    <span class="s2">def </span><span class="s1">putpixel(self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s5">&quot;&quot;&quot; 
        Modifies the pixel at the given position. The color is given as 
        a single numerical value for single-band images, and a tuple for 
        multi-band images. In addition to this, RGB and RGBA tuples are 
        accepted for P and PA images. 
 
        Note that this method is relatively slow.  For more extensive changes, 
        use :py:meth:`~PIL.Image.Image.paste` or the :py:mod:`~PIL.ImageDraw` 
        module instead. 
 
        See: 
 
        * :py:meth:`~PIL.Image.Image.paste` 
        * :py:meth:`~PIL.Image.Image.putdata` 
        * :py:mod:`~PIL.ImageDraw` 
 
        :param xy: The pixel coordinate, given as (x, y). See 
           :ref:`coordinate-system`. 
        :param value: The pixel value. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.readonly:</span>
            <span class="s1">self._copy()</span>
        <span class="s1">self.load()</span>

        <span class="s2">if </span><span class="s1">self.pyaccess:</span>
            <span class="s2">return </span><span class="s1">self.pyaccess.putpixel(xy</span><span class="s2">, </span><span class="s1">value)</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;P&quot;</span><span class="s2">, </span><span class="s3">&quot;PA&quot;</span><span class="s1">)</span>
            <span class="s2">and </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple))</span>
            <span class="s2">and </span><span class="s1">len(value) </span><span class="s2">in </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">):</span>
            <span class="s0"># RGB or RGBA value for a P or PA image</span>
            <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;PA&quot;</span><span class="s1">:</span>
                <span class="s1">alpha = value[</span><span class="s4">3</span><span class="s1">] </span><span class="s2">if </span><span class="s1">len(value) == </span><span class="s4">4 </span><span class="s2">else </span><span class="s4">255</span>
                <span class="s1">value = value[:</span><span class="s4">3</span><span class="s1">]</span>
            <span class="s1">value = self.palette.getcolor(value</span><span class="s2">, </span><span class="s1">self)</span>
            <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;PA&quot;</span><span class="s1">:</span>
                <span class="s1">value = (value</span><span class="s2">, </span><span class="s1">alpha)</span>
        <span class="s2">return </span><span class="s1">self.im.putpixel(xy</span><span class="s2">, </span><span class="s1">value)</span>

    <span class="s2">def </span><span class="s1">remap_palette(self</span><span class="s2">, </span><span class="s1">dest_map</span><span class="s2">, </span><span class="s1">source_palette=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Rewrites the image to reorder the palette. 
 
        :param dest_map: A list of indexes into the original palette. 
           e.g. ``[1,0]`` would swap a two item palette, and ``list(range(256))`` 
           is the identity transform. 
        :param source_palette: Bytes or None. 
        :returns:  An :py:class:`~PIL.Image.Image` object. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImagePalette</span>

        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;P&quot;</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s3">&quot;illegal image mode&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">bands = </span><span class="s4">3</span>
        <span class="s1">palette_mode = </span><span class="s3">&quot;RGB&quot;</span>
        <span class="s2">if </span><span class="s1">source_palette </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;P&quot;</span><span class="s1">:</span>
                <span class="s1">self.load()</span>
                <span class="s1">palette_mode = self.im.getpalettemode()</span>
                <span class="s2">if </span><span class="s1">palette_mode == </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">:</span>
                    <span class="s1">bands = </span><span class="s4">4</span>
                <span class="s1">source_palette = self.im.getpalette(palette_mode</span><span class="s2">, </span><span class="s1">palette_mode)</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s0"># L-mode</span>
                <span class="s1">source_palette = bytearray(i // </span><span class="s4">3 </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">768</span><span class="s1">))</span>

        <span class="s1">palette_bytes = </span><span class="s6">b&quot;&quot;</span>
        <span class="s1">new_positions = [</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">256</span>

        <span class="s0"># pick only the used colors from the palette</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">oldPosition </span><span class="s2">in </span><span class="s1">enumerate(dest_map):</span>
            <span class="s1">palette_bytes += source_palette[</span>
                <span class="s1">oldPosition * bands : oldPosition * bands + bands</span>
            <span class="s1">]</span>
            <span class="s1">new_positions[oldPosition] = i</span>

        <span class="s0"># replace the palette color id of all pixel with the new id</span>

        <span class="s0"># Palette images are [0..255], mapped through a 1 or 3</span>
        <span class="s0"># byte/color map.  We need to remap the whole image</span>
        <span class="s0"># from palette 1 to palette 2. New_positions is</span>
        <span class="s0"># an array of indexes into palette 1.  Palette 2 is</span>
        <span class="s0"># palette 1 with any holes removed.</span>

        <span class="s0"># We're going to leverage the convert mechanism to use the</span>
        <span class="s0"># C code to remap the image from palette 1 to palette 2,</span>
        <span class="s0"># by forcing the source image into 'L' mode and adding a</span>
        <span class="s0"># mapping 'L' mode palette, then converting back to 'L'</span>
        <span class="s0"># sans palette thus converting the image bytes, then</span>
        <span class="s0"># assigning the optimized RGB palette.</span>

        <span class="s0"># perf reference, 9500x4000 gif, w/~135 colors</span>
        <span class="s0"># 14 sec prepatch, 1 sec postpatch with optimization forced.</span>

        <span class="s1">mapping_palette = bytearray(new_positions)</span>

        <span class="s1">m_im = self.copy()</span>
        <span class="s1">m_im.mode = </span><span class="s3">&quot;P&quot;</span>

        <span class="s1">m_im.palette = ImagePalette.ImagePalette(</span>
            <span class="s1">palette_mode</span><span class="s2">, </span><span class="s1">palette=mapping_palette * bands</span>
        <span class="s1">)</span>
        <span class="s0"># possibly set palette dirty, then</span>
        <span class="s0"># m_im.putpalette(mapping_palette, 'L')  # converts to 'P'</span>
        <span class="s0"># or just force it.</span>
        <span class="s0"># UNDONE -- this is part of the general issue with palettes</span>
        <span class="s1">m_im.im.putpalette(palette_mode + </span><span class="s3">&quot;;L&quot;</span><span class="s2">, </span><span class="s1">m_im.palette.tobytes())</span>

        <span class="s1">m_im = m_im.convert(</span><span class="s3">&quot;L&quot;</span><span class="s1">)</span>

        <span class="s1">m_im.putpalette(palette_bytes</span><span class="s2">, </span><span class="s1">palette_mode)</span>
        <span class="s1">m_im.palette = ImagePalette.ImagePalette(palette_mode</span><span class="s2">, </span><span class="s1">palette=palette_bytes)</span>

        <span class="s2">if </span><span class="s3">&quot;transparency&quot; </span><span class="s2">in </span><span class="s1">self.info:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">m_im.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">] = dest_map.index(self.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">])</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">if </span><span class="s3">&quot;transparency&quot; </span><span class="s2">in </span><span class="s1">m_im.info:</span>
                    <span class="s2">del </span><span class="s1">m_im.info[</span><span class="s3">&quot;transparency&quot;</span><span class="s1">]</span>

        <span class="s2">return </span><span class="s1">m_im</span>

    <span class="s2">def </span><span class="s1">_get_safe_box(self</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">resample</span><span class="s2">, </span><span class="s1">box):</span>
        <span class="s5">&quot;&quot;&quot;Expands the box so it includes adjacent pixels 
        that may be used by resampling with the given resampling filter. 
        &quot;&quot;&quot;</span>
        <span class="s1">filter_support = _filters_support[resample] - </span><span class="s4">0.5</span>
        <span class="s1">scale_x = (box[</span><span class="s4">2</span><span class="s1">] - box[</span><span class="s4">0</span><span class="s1">]) / size[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">scale_y = (box[</span><span class="s4">3</span><span class="s1">] - box[</span><span class="s4">1</span><span class="s1">]) / size[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">support_x = filter_support * scale_x</span>
        <span class="s1">support_y = filter_support * scale_y</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">max(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">int(box[</span><span class="s4">0</span><span class="s1">] - support_x))</span><span class="s2">,</span>
            <span class="s1">max(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">int(box[</span><span class="s4">1</span><span class="s1">] - support_y))</span><span class="s2">,</span>
            <span class="s1">min(self.size[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">math.ceil(box[</span><span class="s4">2</span><span class="s1">] + support_x))</span><span class="s2">,</span>
            <span class="s1">min(self.size[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">math.ceil(box[</span><span class="s4">3</span><span class="s1">] + support_y))</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">resize(self</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">resample=</span><span class="s2">None, </span><span class="s1">box=</span><span class="s2">None, </span><span class="s1">reducing_gap=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns a resized copy of this image. 
 
        :param size: The requested size in pixels, as a 2-tuple: 
           (width, height). 
        :param resample: An optional resampling filter.  This can be 
           one of :py:data:`Resampling.NEAREST`, :py:data:`Resampling.BOX`, 
           :py:data:`Resampling.BILINEAR`, :py:data:`Resampling.HAMMING`, 
           :py:data:`Resampling.BICUBIC` or :py:data:`Resampling.LANCZOS`. 
           If the image has mode &quot;1&quot; or &quot;P&quot;, it is always set to 
           :py:data:`Resampling.NEAREST`. If the image mode specifies a number 
           of bits, such as &quot;I;16&quot;, then the default filter is 
           :py:data:`Resampling.NEAREST`. Otherwise, the default filter is 
           :py:data:`Resampling.BICUBIC`. See: :ref:`concept-filters`. 
        :param box: An optional 4-tuple of floats providing 
           the source image region to be scaled. 
           The values must be within (0, 0, width, height) rectangle. 
           If omitted or None, the entire source is used. 
        :param reducing_gap: Apply optimization by resizing the image 
           in two steps. First, reducing the image by integer times 
           using :py:meth:`~PIL.Image.Image.reduce`. 
           Second, resizing using regular resampling. The last step 
           changes size no less than by ``reducing_gap`` times. 
           ``reducing_gap`` may be None (no first step is performed) 
           or should be greater than 1.0. The bigger ``reducing_gap``, 
           the closer the result to the fair resampling. 
           The smaller ``reducing_gap``, the faster resizing. 
           With ``reducing_gap`` greater or equal to 3.0, the result is 
           indistinguishable from fair resampling in most cases. 
           The default value is None (no optimization). 
        :returns: An :py:class:`~PIL.Image.Image` object. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">resample </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">type_special = </span><span class="s3">&quot;;&quot; </span><span class="s2">in </span><span class="s1">self.mode</span>
            <span class="s1">resample = Resampling.NEAREST </span><span class="s2">if </span><span class="s1">type_special </span><span class="s2">else </span><span class="s1">Resampling.BICUBIC</span>
        <span class="s2">elif </span><span class="s1">resample </span><span class="s2">not in </span><span class="s1">(</span>
            <span class="s1">Resampling.NEAREST</span><span class="s2">,</span>
            <span class="s1">Resampling.BILINEAR</span><span class="s2">,</span>
            <span class="s1">Resampling.BICUBIC</span><span class="s2">,</span>
            <span class="s1">Resampling.LANCZOS</span><span class="s2">,</span>
            <span class="s1">Resampling.BOX</span><span class="s2">,</span>
            <span class="s1">Resampling.HAMMING</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s1">msg = </span><span class="s3">f&quot;Unknown resampling filter (</span><span class="s2">{</span><span class="s1">resample</span><span class="s2">}</span><span class="s3">).&quot;</span>

            <span class="s1">filters = [</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">filter[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">} </span><span class="s3">(</span><span class="s2">{</span><span class="s1">filter[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">}</span><span class="s3">)&quot;</span>
                <span class="s2">for </span><span class="s1">filter </span><span class="s2">in </span><span class="s1">(</span>
                    <span class="s1">(Resampling.NEAREST</span><span class="s2">, </span><span class="s3">&quot;Image.Resampling.NEAREST&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">(Resampling.LANCZOS</span><span class="s2">, </span><span class="s3">&quot;Image.Resampling.LANCZOS&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">(Resampling.BILINEAR</span><span class="s2">, </span><span class="s3">&quot;Image.Resampling.BILINEAR&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">(Resampling.BICUBIC</span><span class="s2">, </span><span class="s3">&quot;Image.Resampling.BICUBIC&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">(Resampling.BOX</span><span class="s2">, </span><span class="s3">&quot;Image.Resampling.BOX&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">(Resampling.HAMMING</span><span class="s2">, </span><span class="s3">&quot;Image.Resampling.HAMMING&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">]</span>
            <span class="s1">msg += </span><span class="s3">&quot; Use &quot; </span><span class="s1">+ </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(filters[:-</span><span class="s4">1</span><span class="s1">]) + </span><span class="s3">&quot; or &quot; </span><span class="s1">+ filters[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s2">if </span><span class="s1">reducing_gap </span><span class="s2">is not None and </span><span class="s1">reducing_gap &lt; </span><span class="s4">1.0</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;reducing_gap must be 1.0 or greater&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">size = tuple(size)</span>

        <span class="s1">self.load()</span>
        <span class="s2">if </span><span class="s1">box </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">box = (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + self.size</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">box = tuple(box)</span>

        <span class="s2">if </span><span class="s1">self.size == size </span><span class="s2">and </span><span class="s1">box == (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + self.size:</span>
            <span class="s2">return </span><span class="s1">self.copy()</span>

        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;P&quot;</span><span class="s1">):</span>
            <span class="s1">resample = Resampling.NEAREST</span>

        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">] </span><span class="s2">and </span><span class="s1">resample != Resampling.NEAREST:</span>
            <span class="s1">im = self.convert({</span><span class="s3">&quot;LA&quot;</span><span class="s1">: </span><span class="s3">&quot;La&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">: </span><span class="s3">&quot;RGBa&quot;</span><span class="s1">}[self.mode])</span>
            <span class="s1">im = im.resize(size</span><span class="s2">, </span><span class="s1">resample</span><span class="s2">, </span><span class="s1">box)</span>
            <span class="s2">return </span><span class="s1">im.convert(self.mode)</span>

        <span class="s1">self.load()</span>

        <span class="s2">if </span><span class="s1">reducing_gap </span><span class="s2">is not None and </span><span class="s1">resample != Resampling.NEAREST:</span>
            <span class="s1">factor_x = int((box[</span><span class="s4">2</span><span class="s1">] - box[</span><span class="s4">0</span><span class="s1">]) / size[</span><span class="s4">0</span><span class="s1">] / reducing_gap) </span><span class="s2">or </span><span class="s4">1</span>
            <span class="s1">factor_y = int((box[</span><span class="s4">3</span><span class="s1">] - box[</span><span class="s4">1</span><span class="s1">]) / size[</span><span class="s4">1</span><span class="s1">] / reducing_gap) </span><span class="s2">or </span><span class="s4">1</span>
            <span class="s2">if </span><span class="s1">factor_x &gt; </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">factor_y &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">reduce_box = self._get_safe_box(size</span><span class="s2">, </span><span class="s1">resample</span><span class="s2">, </span><span class="s1">box)</span>
                <span class="s1">factor = (factor_x</span><span class="s2">, </span><span class="s1">factor_y)</span>
                <span class="s2">if </span><span class="s1">callable(self.reduce):</span>
                    <span class="s1">self = self.reduce(factor</span><span class="s2">, </span><span class="s1">box=reduce_box)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self = Image.reduce(self</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">box=reduce_box)</span>
                <span class="s1">box = (</span>
                    <span class="s1">(box[</span><span class="s4">0</span><span class="s1">] - reduce_box[</span><span class="s4">0</span><span class="s1">]) / factor_x</span><span class="s2">,</span>
                    <span class="s1">(box[</span><span class="s4">1</span><span class="s1">] - reduce_box[</span><span class="s4">1</span><span class="s1">]) / factor_y</span><span class="s2">,</span>
                    <span class="s1">(box[</span><span class="s4">2</span><span class="s1">] - reduce_box[</span><span class="s4">0</span><span class="s1">]) / factor_x</span><span class="s2">,</span>
                    <span class="s1">(box[</span><span class="s4">3</span><span class="s1">] - reduce_box[</span><span class="s4">1</span><span class="s1">]) / factor_y</span><span class="s2">,</span>
                <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self._new(self.im.resize(size</span><span class="s2">, </span><span class="s1">resample</span><span class="s2">, </span><span class="s1">box))</span>

    <span class="s2">def </span><span class="s1">reduce(self</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">box=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns a copy of the image reduced ``factor`` times. 
        If the size of the image is not dividable by ``factor``, 
        the resulting size will be rounded up. 
 
        :param factor: A greater than 0 integer or tuple of two integers 
           for width and height separately. 
        :param box: An optional 4-tuple of ints providing 
           the source image region to be reduced. 
           The values must be within ``(0, 0, width, height)`` rectangle. 
           If omitted or ``None``, the entire source is used. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(factor</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
            <span class="s1">factor = (factor</span><span class="s2">, </span><span class="s1">factor)</span>

        <span class="s2">if </span><span class="s1">box </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">box = (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + self.size</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">box = tuple(box)</span>

        <span class="s2">if </span><span class="s1">factor == (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) </span><span class="s2">and </span><span class="s1">box == (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + self.size:</span>
            <span class="s2">return </span><span class="s1">self.copy()</span>

        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">]:</span>
            <span class="s1">im = self.convert({</span><span class="s3">&quot;LA&quot;</span><span class="s1">: </span><span class="s3">&quot;La&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">: </span><span class="s3">&quot;RGBa&quot;</span><span class="s1">}[self.mode])</span>
            <span class="s1">im = im.reduce(factor</span><span class="s2">, </span><span class="s1">box)</span>
            <span class="s2">return </span><span class="s1">im.convert(self.mode)</span>

        <span class="s1">self.load()</span>

        <span class="s2">return </span><span class="s1">self._new(self.im.reduce(factor</span><span class="s2">, </span><span class="s1">box))</span>

    <span class="s2">def </span><span class="s1">rotate(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">angle</span><span class="s2">,</span>
        <span class="s1">resample=Resampling.NEAREST</span><span class="s2">,</span>
        <span class="s1">expand=</span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">center=</span><span class="s2">None,</span>
        <span class="s1">translate=</span><span class="s2">None,</span>
        <span class="s1">fillcolor=</span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns a rotated copy of this image.  This method returns a 
        copy of this image, rotated the given number of degrees counter 
        clockwise around its centre. 
 
        :param angle: In degrees counter clockwise. 
        :param resample: An optional resampling filter.  This can be 
           one of :py:data:`Resampling.NEAREST` (use nearest neighbour), 
           :py:data:`Resampling.BILINEAR` (linear interpolation in a 2x2 
           environment), or :py:data:`Resampling.BICUBIC` (cubic spline 
           interpolation in a 4x4 environment). If omitted, or if the image has 
           mode &quot;1&quot; or &quot;P&quot;, it is set to :py:data:`Resampling.NEAREST`. 
           See :ref:`concept-filters`. 
        :param expand: Optional expansion flag.  If true, expands the output 
           image to make it large enough to hold the entire rotated image. 
           If false or omitted, make the output image the same size as the 
           input image.  Note that the expand flag assumes rotation around 
           the center and no translation. 
        :param center: Optional center of rotation (a 2-tuple).  Origin is 
           the upper left corner.  Default is the center of the image. 
        :param translate: An optional post-rotate translation (a 2-tuple). 
        :param fillcolor: An optional color for area outside the rotated image. 
        :returns: An :py:class:`~PIL.Image.Image` object. 
        &quot;&quot;&quot;</span>

        <span class="s1">angle = angle % </span><span class="s4">360.0</span>

        <span class="s0"># Fast paths regardless of filter, as long as we're not</span>
        <span class="s0"># translating or changing the center.</span>
        <span class="s2">if not </span><span class="s1">(center </span><span class="s2">or </span><span class="s1">translate):</span>
            <span class="s2">if </span><span class="s1">angle == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.copy()</span>
            <span class="s2">if </span><span class="s1">angle == </span><span class="s4">180</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.transpose(Transpose.ROTATE_180)</span>
            <span class="s2">if </span><span class="s1">angle </span><span class="s2">in </span><span class="s1">(</span><span class="s4">90</span><span class="s2">, </span><span class="s4">270</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(expand </span><span class="s2">or </span><span class="s1">self.width == self.height):</span>
                <span class="s2">return </span><span class="s1">self.transpose(</span>
                    <span class="s1">Transpose.ROTATE_90 </span><span class="s2">if </span><span class="s1">angle == </span><span class="s4">90 </span><span class="s2">else </span><span class="s1">Transpose.ROTATE_270</span>
                <span class="s1">)</span>

        <span class="s0"># Calculate the affine matrix.  Note that this is the reverse</span>
        <span class="s0"># transformation (from destination image to source) because we</span>
        <span class="s0"># want to interpolate the (discrete) destination pixel from</span>
        <span class="s0"># the local area around the (floating) source pixel.</span>

        <span class="s0"># The matrix we actually want (note that it operates from the right):</span>
        <span class="s0"># (1, 0, tx)   (1, 0, cx)   ( cos a, sin a, 0)   (1, 0, -cx)</span>
        <span class="s0"># (0, 1, ty) * (0, 1, cy) * (-sin a, cos a, 0) * (0, 1, -cy)</span>
        <span class="s0"># (0, 0,  1)   (0, 0,  1)   (     0,     0, 1)   (0, 0,   1)</span>

        <span class="s0"># The reverse matrix is thus:</span>
        <span class="s0"># (1, 0, cx)   ( cos -a, sin -a, 0)   (1, 0, -cx)   (1, 0, -tx)</span>
        <span class="s0"># (0, 1, cy) * (-sin -a, cos -a, 0) * (0, 1, -cy) * (0, 1, -ty)</span>
        <span class="s0"># (0, 0,  1)   (      0,      0, 1)   (0, 0,   1)   (0, 0,   1)</span>

        <span class="s0"># In any case, the final translation may be updated at the end to</span>
        <span class="s0"># compensate for the expand flag.</span>

        <span class="s1">w</span><span class="s2">, </span><span class="s1">h = self.size</span>

        <span class="s2">if </span><span class="s1">translate </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">post_trans = (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">post_trans = translate</span>
        <span class="s2">if </span><span class="s1">center </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># FIXME These should be rounded to ints?</span>
            <span class="s1">rotn_center = (w / </span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">h / </span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rotn_center = center</span>

        <span class="s1">angle = -math.radians(angle)</span>
        <span class="s1">matrix = [</span>
            <span class="s1">round(math.cos(angle)</span><span class="s2">, </span><span class="s4">15</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">round(math.sin(angle)</span><span class="s2">, </span><span class="s4">15</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">0.0</span><span class="s2">,</span>
            <span class="s1">round(-math.sin(angle)</span><span class="s2">, </span><span class="s4">15</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">round(math.cos(angle)</span><span class="s2">, </span><span class="s4">15</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">0.0</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s2">def </span><span class="s1">transform(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">matrix):</span>
            <span class="s1">(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">f) = matrix</span>
            <span class="s2">return </span><span class="s1">a * x + b * y + c</span><span class="s2">, </span><span class="s1">d * x + e * y + f</span>

        <span class="s1">matrix[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">matrix[</span><span class="s4">5</span><span class="s1">] = transform(</span>
            <span class="s1">-rotn_center[</span><span class="s4">0</span><span class="s1">] - post_trans[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-rotn_center[</span><span class="s4">1</span><span class="s1">] - post_trans[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">matrix</span>
        <span class="s1">)</span>
        <span class="s1">matrix[</span><span class="s4">2</span><span class="s1">] += rotn_center[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">matrix[</span><span class="s4">5</span><span class="s1">] += rotn_center[</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">expand:</span>
            <span class="s0"># calculate output size</span>
            <span class="s1">xx = []</span>
            <span class="s1">yy = []</span>
            <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(w</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(w</span><span class="s2">, </span><span class="s1">h)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">h)):</span>
                <span class="s1">x</span><span class="s2">, </span><span class="s1">y = transform(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">matrix)</span>
                <span class="s1">xx.append(x)</span>
                <span class="s1">yy.append(y)</span>
            <span class="s1">nw = math.ceil(max(xx)) - math.floor(min(xx))</span>
            <span class="s1">nh = math.ceil(max(yy)) - math.floor(min(yy))</span>

            <span class="s0"># We multiply a translation matrix from the right.  Because of its</span>
            <span class="s0"># special form, this is the same as taking the image of the</span>
            <span class="s0"># translation vector as new translation vector.</span>
            <span class="s1">matrix[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">matrix[</span><span class="s4">5</span><span class="s1">] = transform(-(nw - w) / </span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">-(nh - h) / </span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">matrix)</span>
            <span class="s1">w</span><span class="s2">, </span><span class="s1">h = nw</span><span class="s2">, </span><span class="s1">nh</span>

        <span class="s2">return </span><span class="s1">self.transform(</span>
            <span class="s1">(w</span><span class="s2">, </span><span class="s1">h)</span><span class="s2">, </span><span class="s1">Transform.AFFINE</span><span class="s2">, </span><span class="s1">matrix</span><span class="s2">, </span><span class="s1">resample</span><span class="s2">, </span><span class="s1">fillcolor=fillcolor</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">save(self</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">format=</span><span class="s2">None, </span><span class="s1">**params):</span>
        <span class="s5">&quot;&quot;&quot; 
        Saves this image under the given filename.  If no format is 
        specified, the format to use is determined from the filename 
        extension, if possible. 
 
        Keyword options can be used to provide additional instructions 
        to the writer. If a writer doesn't recognise an option, it is 
        silently ignored. The available options are described in the 
        :doc:`image format documentation 
        &lt;../handbook/image-file-formats&gt;` for each writer. 
 
        You can use a file object instead of a filename. In this case, 
        you must always specify the format. The file object must 
        implement the ``seek``, ``tell``, and ``write`` 
        methods, and be opened in binary mode. 
 
        :param fp: A filename (string), pathlib.Path object or file object. 
        :param format: Optional format override.  If omitted, the 
           format to use is determined from the filename extension. 
           If a file object was used instead of a filename, this 
           parameter should always be used. 
        :param params: Extra parameters to the image writer. 
        :returns: None 
        :exception ValueError: If the output format could not be determined 
           from the file name.  Use the format option to solve this. 
        :exception OSError: If the file could not be written.  The file 
           may have been created, and may contain partial data. 
        &quot;&quot;&quot;</span>

        <span class="s1">filename = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">open_fp = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">isinstance(fp</span><span class="s2">, </span><span class="s1">Path):</span>
            <span class="s1">filename = str(fp)</span>
            <span class="s1">open_fp = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">is_path(fp):</span>
            <span class="s1">filename = fp</span>
            <span class="s1">open_fp = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">fp == sys.stdout:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">fp = sys.stdout.buffer</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s2">pass</span>
        <span class="s2">if not </span><span class="s1">filename </span><span class="s2">and </span><span class="s1">hasattr(fp</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">is_path(fp.name):</span>
            <span class="s0"># only set the name for metadata purposes</span>
            <span class="s1">filename = fp.name</span>

        <span class="s0"># may mutate self!</span>
        <span class="s1">self._ensure_mutable()</span>

        <span class="s1">save_all = params.pop(</span><span class="s3">&quot;save_all&quot;</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self.encoderinfo = params</span>
        <span class="s1">self.encoderconfig = ()</span>

        <span class="s1">preinit()</span>

        <span class="s1">ext = os.path.splitext(filename)[</span><span class="s4">1</span><span class="s1">].lower()</span>

        <span class="s2">if not </span><span class="s1">format:</span>
            <span class="s2">if </span><span class="s1">ext </span><span class="s2">not in </span><span class="s1">EXTENSION:</span>
                <span class="s1">init()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">format = EXTENSION[ext]</span>
            <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">msg = </span><span class="s3">f&quot;unknown file extension: </span><span class="s2">{</span><span class="s1">ext</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s2">if </span><span class="s1">format.upper() </span><span class="s2">not in </span><span class="s1">SAVE:</span>
            <span class="s1">init()</span>
        <span class="s2">if </span><span class="s1">save_all:</span>
            <span class="s1">save_handler = SAVE_ALL[format.upper()]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">save_handler = SAVE[format.upper()]</span>

        <span class="s1">created = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">open_fp:</span>
            <span class="s1">created = </span><span class="s2">not </span><span class="s1">os.path.exists(filename)</span>
            <span class="s2">if </span><span class="s1">params.get(</span><span class="s3">&quot;append&quot;</span><span class="s2">, False</span><span class="s1">):</span>
                <span class="s0"># Open also for reading (&quot;+&quot;), because TIFF save_all</span>
                <span class="s0"># writer needs to go back and edit the written data.</span>
                <span class="s1">fp = builtins.open(filename</span><span class="s2">, </span><span class="s3">&quot;r+b&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">fp = builtins.open(filename</span><span class="s2">, </span><span class="s3">&quot;w+b&quot;</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">save_handler(self</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">if </span><span class="s1">open_fp:</span>
                <span class="s1">fp.close()</span>
            <span class="s2">if </span><span class="s1">created:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">os.remove(filename)</span>
                <span class="s2">except </span><span class="s1">PermissionError:</span>
                    <span class="s2">pass</span>
            <span class="s2">raise</span>
        <span class="s2">if </span><span class="s1">open_fp:</span>
            <span class="s1">fp.close()</span>

    <span class="s2">def </span><span class="s1">seek(self</span><span class="s2">, </span><span class="s1">frame):</span>
        <span class="s5">&quot;&quot;&quot; 
        Seeks to the given frame in this sequence file. If you seek 
        beyond the end of the sequence, the method raises an 
        ``EOFError`` exception. When a sequence file is opened, the 
        library automatically seeks to frame 0. 
 
        See :py:meth:`~PIL.Image.Image.tell`. 
 
        If defined, :attr:`~PIL.Image.Image.n_frames` refers to the 
        number of available frames. 
 
        :param frame: Frame number, starting at 0. 
        :exception EOFError: If the call attempts to seek beyond the end 
            of the sequence. 
        &quot;&quot;&quot;</span>

        <span class="s0"># overridden by file handlers</span>
        <span class="s2">if </span><span class="s1">frame != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">EOFError</span>

    <span class="s2">def </span><span class="s1">show(self</span><span class="s2">, </span><span class="s1">title=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Displays this image. This method is mainly intended for debugging purposes. 
 
        This method calls :py:func:`PIL.ImageShow.show` internally. You can use 
        :py:func:`PIL.ImageShow.register` to override its default behaviour. 
 
        The image is first saved to a temporary file. By default, it will be in 
        PNG format. 
 
        On Unix, the image is then opened using the **display**, **eog** or 
        **xv** utility, depending on which one can be found. 
 
        On macOS, the image is opened with the native Preview application. 
 
        On Windows, the image is opened with the standard PNG display utility. 
 
        :param title: Optional title to use for the image window, where possible. 
        &quot;&quot;&quot;</span>

        <span class="s1">_show(self</span><span class="s2">, </span><span class="s1">title=title)</span>

    <span class="s2">def </span><span class="s1">split(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Split this image into individual bands. This method returns a 
        tuple of individual image bands from an image. For example, 
        splitting an &quot;RGB&quot; image creates three new images each 
        containing a copy of one of the original bands (red, green, 
        blue). 
 
        If you need only one band, :py:meth:`~PIL.Image.Image.getchannel` 
        method can be more convenient and faster. 
 
        :returns: A tuple containing bands. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>
        <span class="s2">if </span><span class="s1">self.im.bands == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">ims = [self.copy()]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ims = map(self._new</span><span class="s2">, </span><span class="s1">self.im.split())</span>
        <span class="s2">return </span><span class="s1">tuple(ims)</span>

    <span class="s2">def </span><span class="s1">getchannel(self</span><span class="s2">, </span><span class="s1">channel):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns an image containing a single channel of the source image. 
 
        :param channel: What channel to return. Could be index 
          (0 for &quot;R&quot; channel of &quot;RGB&quot;) or channel name 
          (&quot;A&quot; for alpha channel of &quot;RGBA&quot;). 
        :returns: An image in &quot;L&quot; mode. 
 
        .. versionadded:: 4.3.0 
        &quot;&quot;&quot;</span>
        <span class="s1">self.load()</span>

        <span class="s2">if </span><span class="s1">isinstance(channel</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">channel = self.getbands().index(channel)</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">msg = </span><span class="s3">f'The image has no channel &quot;</span><span class="s2">{</span><span class="s1">channel</span><span class="s2">}</span><span class="s3">&quot;'</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s2">return </span><span class="s1">self._new(self.im.getband(channel))</span>

    <span class="s2">def </span><span class="s1">tell(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the current frame number. See :py:meth:`~PIL.Image.Image.seek`. 
 
        If defined, :attr:`~PIL.Image.Image.n_frames` refers to the 
        number of available frames. 
 
        :returns: Frame number, starting with 0. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">def </span><span class="s1">thumbnail(self</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">resample=Resampling.BICUBIC</span><span class="s2">, </span><span class="s1">reducing_gap=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Make this image into a thumbnail.  This method modifies the 
        image to contain a thumbnail version of itself, no larger than 
        the given size.  This method calculates an appropriate thumbnail 
        size to preserve the aspect of the image, calls the 
        :py:meth:`~PIL.Image.Image.draft` method to configure the file reader 
        (where applicable), and finally resizes the image. 
 
        Note that this function modifies the :py:class:`~PIL.Image.Image` 
        object in place.  If you need to use the full resolution image as well, 
        apply this method to a :py:meth:`~PIL.Image.Image.copy` of the original 
        image. 
 
        :param size: The requested size in pixels, as a 2-tuple: 
           (width, height). 
        :param resample: Optional resampling filter.  This can be one 
           of :py:data:`Resampling.NEAREST`, :py:data:`Resampling.BOX`, 
           :py:data:`Resampling.BILINEAR`, :py:data:`Resampling.HAMMING`, 
           :py:data:`Resampling.BICUBIC` or :py:data:`Resampling.LANCZOS`. 
           If omitted, it defaults to :py:data:`Resampling.BICUBIC`. 
           (was :py:data:`Resampling.NEAREST` prior to version 2.5.0). 
           See: :ref:`concept-filters`. 
        :param reducing_gap: Apply optimization by resizing the image 
           in two steps. First, reducing the image by integer times 
           using :py:meth:`~PIL.Image.Image.reduce` or 
           :py:meth:`~PIL.Image.Image.draft` for JPEG images. 
           Second, resizing using regular resampling. The last step 
           changes size no less than by ``reducing_gap`` times. 
           ``reducing_gap`` may be None (no first step is performed) 
           or should be greater than 1.0. The bigger ``reducing_gap``, 
           the closer the result to the fair resampling. 
           The smaller ``reducing_gap``, the faster resizing. 
           With ``reducing_gap`` greater or equal to 3.0, the result is 
           indistinguishable from fair resampling in most cases. 
           The default value is 2.0 (very close to fair resampling 
           while still being faster in many cases). 
        :returns: None 
        &quot;&quot;&quot;</span>

        <span class="s1">provided_size = tuple(map(math.floor</span><span class="s2">, </span><span class="s1">size))</span>

        <span class="s2">def </span><span class="s1">preserve_aspect_ratio():</span>
            <span class="s2">def </span><span class="s1">round_aspect(number</span><span class="s2">, </span><span class="s1">key):</span>
                <span class="s2">return </span><span class="s1">max(min(math.floor(number)</span><span class="s2">, </span><span class="s1">math.ceil(number)</span><span class="s2">, </span><span class="s1">key=key)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = provided_size</span>
            <span class="s2">if </span><span class="s1">x &gt;= self.width </span><span class="s2">and </span><span class="s1">y &gt;= self.height:</span>
                <span class="s2">return</span>

            <span class="s1">aspect = self.width / self.height</span>
            <span class="s2">if </span><span class="s1">x / y &gt;= aspect:</span>
                <span class="s1">x = round_aspect(y * aspect</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">n: abs(aspect - n / y))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">y = round_aspect(</span>
                    <span class="s1">x / aspect</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">n: </span><span class="s4">0 </span><span class="s2">if </span><span class="s1">n == </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">abs(aspect - x / n)</span>
                <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span>

        <span class="s1">box = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">reducing_gap </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">size = preserve_aspect_ratio()</span>
            <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return</span>

            <span class="s1">res = self.draft(</span><span class="s2">None, </span><span class="s1">(size[</span><span class="s4">0</span><span class="s1">] * reducing_gap</span><span class="s2">, </span><span class="s1">size[</span><span class="s4">1</span><span class="s1">] * reducing_gap))</span>
            <span class="s2">if </span><span class="s1">res </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">box = res[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">box </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.load()</span>

            <span class="s0"># load() may have changed the size of the image</span>
            <span class="s1">size = preserve_aspect_ratio()</span>
            <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self.size != size:</span>
            <span class="s1">im = self.resize(size</span><span class="s2">, </span><span class="s1">resample</span><span class="s2">, </span><span class="s1">box=box</span><span class="s2">, </span><span class="s1">reducing_gap=reducing_gap)</span>

            <span class="s1">self.im = im.im</span>
            <span class="s1">self._size = size</span>
            <span class="s1">self.mode = self.im.mode</span>

        <span class="s1">self.readonly = </span><span class="s4">0</span>
        <span class="s1">self.pyaccess = </span><span class="s2">None</span>

    <span class="s0"># FIXME: the different transform methods need further explanation</span>
    <span class="s0"># instead of bloating the method docs, add a separate chapter.</span>
    <span class="s2">def </span><span class="s1">transform(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">size</span><span class="s2">,</span>
        <span class="s1">method</span><span class="s2">,</span>
        <span class="s1">data=</span><span class="s2">None,</span>
        <span class="s1">resample=Resampling.NEAREST</span><span class="s2">,</span>
        <span class="s1">fill=</span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">fillcolor=</span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Transforms this image.  This method creates a new image with the 
        given size, and the same mode as the original, and copies data 
        to the new image using the given transform. 
 
        :param size: The output size in pixels, as a 2-tuple: 
           (width, height). 
        :param method: The transformation method.  This is one of 
          :py:data:`Transform.EXTENT` (cut out a rectangular subregion), 
          :py:data:`Transform.AFFINE` (affine transform), 
          :py:data:`Transform.PERSPECTIVE` (perspective transform), 
          :py:data:`Transform.QUAD` (map a quadrilateral to a rectangle), or 
          :py:data:`Transform.MESH` (map a number of source quadrilaterals 
          in one operation). 
 
          It may also be an :py:class:`~PIL.Image.ImageTransformHandler` 
          object:: 
 
            class Example(Image.ImageTransformHandler): 
                def transform(self, size, data, resample, fill=1): 
                    # Return result 
 
          It may also be an object with a ``method.getdata`` method 
          that returns a tuple supplying new ``method`` and ``data`` values:: 
 
            class Example: 
                def getdata(self): 
                    method = Image.Transform.EXTENT 
                    data = (0, 0, 100, 100) 
                    return method, data 
        :param data: Extra data to the transformation method. 
        :param resample: Optional resampling filter.  It can be one of 
           :py:data:`Resampling.NEAREST` (use nearest neighbour), 
           :py:data:`Resampling.BILINEAR` (linear interpolation in a 2x2 
           environment), or :py:data:`Resampling.BICUBIC` (cubic spline 
           interpolation in a 4x4 environment). If omitted, or if the image 
           has mode &quot;1&quot; or &quot;P&quot;, it is set to :py:data:`Resampling.NEAREST`. 
           See: :ref:`concept-filters`. 
        :param fill: If ``method`` is an 
          :py:class:`~PIL.Image.ImageTransformHandler` object, this is one of 
          the arguments passed to it. Otherwise, it is unused. 
        :param fillcolor: Optional fill color for the area outside the 
           transform in the output image. 
        :returns: An :py:class:`~PIL.Image.Image` object. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">resample != Resampling.NEAREST:</span>
            <span class="s2">return </span><span class="s1">(</span>
                <span class="s1">self.convert({</span><span class="s3">&quot;LA&quot;</span><span class="s1">: </span><span class="s3">&quot;La&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">: </span><span class="s3">&quot;RGBa&quot;</span><span class="s1">}[self.mode])</span>
                <span class="s1">.transform(size</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">resample</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, </span><span class="s1">fillcolor)</span>
                <span class="s1">.convert(self.mode)</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(method</span><span class="s2">, </span><span class="s1">ImageTransformHandler):</span>
            <span class="s2">return </span><span class="s1">method.transform(size</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">resample=resample</span><span class="s2">, </span><span class="s1">fill=fill)</span>

        <span class="s2">if </span><span class="s1">hasattr(method</span><span class="s2">, </span><span class="s3">&quot;getdata&quot;</span><span class="s1">):</span>
            <span class="s0"># compatibility w. old-style transform objects</span>
            <span class="s1">method</span><span class="s2">, </span><span class="s1">data = method.getdata()</span>

        <span class="s2">if </span><span class="s1">data </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;missing method data&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">im = new(self.mode</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">fillcolor)</span>
        <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;P&quot; </span><span class="s2">and </span><span class="s1">self.palette:</span>
            <span class="s1">im.palette = self.palette.copy()</span>
        <span class="s1">im.info = self.info.copy()</span>
        <span class="s2">if </span><span class="s1">method == Transform.MESH:</span>
            <span class="s0"># list of quads</span>
            <span class="s2">for </span><span class="s1">box</span><span class="s2">, </span><span class="s1">quad </span><span class="s2">in </span><span class="s1">data:</span>
                <span class="s1">im.__transformer(</span>
                    <span class="s1">box</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">Transform.QUAD</span><span class="s2">, </span><span class="s1">quad</span><span class="s2">, </span><span class="s1">resample</span><span class="s2">, </span><span class="s1">fillcolor </span><span class="s2">is None</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">im.__transformer(</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + size</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">resample</span><span class="s2">, </span><span class="s1">fillcolor </span><span class="s2">is None</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">im</span>

    <span class="s2">def </span><span class="s1">__transformer(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">box</span><span class="s2">, </span><span class="s1">image</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">resample=Resampling.NEAREST</span><span class="s2">, </span><span class="s1">fill=</span><span class="s4">1</span>
    <span class="s1">):</span>
        <span class="s1">w = box[</span><span class="s4">2</span><span class="s1">] - box[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">h = box[</span><span class="s4">3</span><span class="s1">] - box[</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">method == Transform.AFFINE:</span>
            <span class="s1">data = data[:</span><span class="s4">6</span><span class="s1">]</span>

        <span class="s2">elif </span><span class="s1">method == Transform.EXTENT:</span>
            <span class="s0"># convert extent to an affine transform</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = data</span>
            <span class="s1">xs = (x1 - x0) / w</span>
            <span class="s1">ys = (y1 - y0) / h</span>
            <span class="s1">method = Transform.AFFINE</span>
            <span class="s1">data = (xs</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">y0)</span>

        <span class="s2">elif </span><span class="s1">method == Transform.PERSPECTIVE:</span>
            <span class="s1">data = data[:</span><span class="s4">8</span><span class="s1">]</span>

        <span class="s2">elif </span><span class="s1">method == Transform.QUAD:</span>
            <span class="s0"># quadrilateral warp.  data specifies the four corners</span>
            <span class="s0"># given as NW, SW, SE, and NE.</span>
            <span class="s1">nw = data[:</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">sw = data[</span><span class="s4">2</span><span class="s1">:</span><span class="s4">4</span><span class="s1">]</span>
            <span class="s1">se = data[</span><span class="s4">4</span><span class="s1">:</span><span class="s4">6</span><span class="s1">]</span>
            <span class="s1">ne = data[</span><span class="s4">6</span><span class="s1">:</span><span class="s4">8</span><span class="s1">]</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = nw</span>
            <span class="s1">As = </span><span class="s4">1.0 </span><span class="s1">/ w</span>
            <span class="s1">At = </span><span class="s4">1.0 </span><span class="s1">/ h</span>
            <span class="s1">data = (</span>
                <span class="s1">x0</span><span class="s2">,</span>
                <span class="s1">(ne[</span><span class="s4">0</span><span class="s1">] - x0) * As</span><span class="s2">,</span>
                <span class="s1">(sw[</span><span class="s4">0</span><span class="s1">] - x0) * At</span><span class="s2">,</span>
                <span class="s1">(se[</span><span class="s4">0</span><span class="s1">] - sw[</span><span class="s4">0</span><span class="s1">] - ne[</span><span class="s4">0</span><span class="s1">] + x0) * As * At</span><span class="s2">,</span>
                <span class="s1">y0</span><span class="s2">,</span>
                <span class="s1">(ne[</span><span class="s4">1</span><span class="s1">] - y0) * As</span><span class="s2">,</span>
                <span class="s1">(sw[</span><span class="s4">1</span><span class="s1">] - y0) * At</span><span class="s2">,</span>
                <span class="s1">(se[</span><span class="s4">1</span><span class="s1">] - sw[</span><span class="s4">1</span><span class="s1">] - ne[</span><span class="s4">1</span><span class="s1">] + y0) * As * At</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;unknown transformation method&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s2">if </span><span class="s1">resample </span><span class="s2">not in </span><span class="s1">(</span>
            <span class="s1">Resampling.NEAREST</span><span class="s2">,</span>
            <span class="s1">Resampling.BILINEAR</span><span class="s2">,</span>
            <span class="s1">Resampling.BICUBIC</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">resample </span><span class="s2">in </span><span class="s1">(Resampling.BOX</span><span class="s2">, </span><span class="s1">Resampling.HAMMING</span><span class="s2">, </span><span class="s1">Resampling.LANCZOS):</span>
                <span class="s1">msg = {</span>
                    <span class="s1">Resampling.BOX: </span><span class="s3">&quot;Image.Resampling.BOX&quot;</span><span class="s2">,</span>
                    <span class="s1">Resampling.HAMMING: </span><span class="s3">&quot;Image.Resampling.HAMMING&quot;</span><span class="s2">,</span>
                    <span class="s1">Resampling.LANCZOS: </span><span class="s3">&quot;Image.Resampling.LANCZOS&quot;</span><span class="s2">,</span>
                <span class="s1">}[resample] + </span><span class="s3">f&quot; (</span><span class="s2">{</span><span class="s1">resample</span><span class="s2">}</span><span class="s3">) cannot be used.&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s3">f&quot;Unknown resampling filter (</span><span class="s2">{</span><span class="s1">resample</span><span class="s2">}</span><span class="s3">).&quot;</span>

            <span class="s1">filters = [</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">filter[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">} </span><span class="s3">(</span><span class="s2">{</span><span class="s1">filter[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">}</span><span class="s3">)&quot;</span>
                <span class="s2">for </span><span class="s1">filter </span><span class="s2">in </span><span class="s1">(</span>
                    <span class="s1">(Resampling.NEAREST</span><span class="s2">, </span><span class="s3">&quot;Image.Resampling.NEAREST&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">(Resampling.BILINEAR</span><span class="s2">, </span><span class="s3">&quot;Image.Resampling.BILINEAR&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">(Resampling.BICUBIC</span><span class="s2">, </span><span class="s3">&quot;Image.Resampling.BICUBIC&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">]</span>
            <span class="s1">msg += </span><span class="s3">&quot; Use &quot; </span><span class="s1">+ </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(filters[:-</span><span class="s4">1</span><span class="s1">]) + </span><span class="s3">&quot; or &quot; </span><span class="s1">+ filters[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">image.load()</span>

        <span class="s1">self.load()</span>

        <span class="s2">if </span><span class="s1">image.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;P&quot;</span><span class="s1">):</span>
            <span class="s1">resample = Resampling.NEAREST</span>

        <span class="s1">self.im.transform2(box</span><span class="s2">, </span><span class="s1">image.im</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">resample</span><span class="s2">, </span><span class="s1">fill)</span>

    <span class="s2">def </span><span class="s1">transpose(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s5">&quot;&quot;&quot; 
        Transpose image (flip or rotate in 90 degree steps) 
 
        :param method: One of :py:data:`Transpose.FLIP_LEFT_RIGHT`, 
          :py:data:`Transpose.FLIP_TOP_BOTTOM`, :py:data:`Transpose.ROTATE_90`, 
          :py:data:`Transpose.ROTATE_180`, :py:data:`Transpose.ROTATE_270`, 
          :py:data:`Transpose.TRANSPOSE` or :py:data:`Transpose.TRANSVERSE`. 
        :returns: Returns a flipped or rotated copy of this image. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.load()</span>
        <span class="s2">return </span><span class="s1">self._new(self.im.transpose(method))</span>

    <span class="s2">def </span><span class="s1">effect_spread(self</span><span class="s2">, </span><span class="s1">distance):</span>
        <span class="s5">&quot;&quot;&quot; 
        Randomly spread pixels in an image. 
 
        :param distance: Distance to spread pixels. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.load()</span>
        <span class="s2">return </span><span class="s1">self._new(self.im.effect_spread(distance))</span>

    <span class="s2">def </span><span class="s1">toqimage(self):</span>
        <span class="s5">&quot;&quot;&quot;Returns a QImage copy of this image&quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImageQt</span>

        <span class="s2">if not </span><span class="s1">ImageQt.qt_is_installed:</span>
            <span class="s1">msg = </span><span class="s3">&quot;Qt bindings are not installed&quot;</span>
            <span class="s2">raise </span><span class="s1">ImportError(msg)</span>
        <span class="s2">return </span><span class="s1">ImageQt.toqimage(self)</span>

    <span class="s2">def </span><span class="s1">toqpixmap(self):</span>
        <span class="s5">&quot;&quot;&quot;Returns a QPixmap copy of this image&quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImageQt</span>

        <span class="s2">if not </span><span class="s1">ImageQt.qt_is_installed:</span>
            <span class="s1">msg = </span><span class="s3">&quot;Qt bindings are not installed&quot;</span>
            <span class="s2">raise </span><span class="s1">ImportError(msg)</span>
        <span class="s2">return </span><span class="s1">ImageQt.toqpixmap(self)</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Abstract handlers.</span>


<span class="s2">class </span><span class="s1">ImagePointHandler:</span>
    <span class="s5">&quot;&quot;&quot; 
    Used as a mixin by point transforms 
    (for use with :py:meth:`~PIL.Image.Image.point`) 
    &quot;&quot;&quot;</span>

    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">ImageTransformHandler:</span>
    <span class="s5">&quot;&quot;&quot; 
    Used as a mixin by geometry transforms 
    (for use with :py:meth:`~PIL.Image.Image.transform`) 
    &quot;&quot;&quot;</span>

    <span class="s2">pass</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Factories</span>

<span class="s0">#</span>
<span class="s0"># Debugging</span>


<span class="s2">def </span><span class="s1">_wedge():</span>
    <span class="s5">&quot;&quot;&quot;Create greyscale wedge (for debugging only)&quot;&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">Image()._new(core.wedge(</span><span class="s3">&quot;L&quot;</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">_check_size(size):</span>
    <span class="s5">&quot;&quot;&quot; 
    Common check to enforce type and sanity check on size tuples 
 
    :param size: Should be a 2 tuple of (width, height) 
    :returns: True, or raises a ValueError 
    &quot;&quot;&quot;</span>

    <span class="s2">if not </span><span class="s1">isinstance(size</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s1">msg = </span><span class="s3">&quot;Size must be a tuple&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
    <span class="s2">if </span><span class="s1">len(size) != </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s3">&quot;Size must be a tuple of length 2&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
    <span class="s2">if </span><span class="s1">size[</span><span class="s4">0</span><span class="s1">] &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">size[</span><span class="s4">1</span><span class="s1">] &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s3">&quot;Width and height must be &gt;= 0&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">new(mode</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">color=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Creates a new image with the given mode and size. 
 
    :param mode: The mode to use for the new image. See: 
       :ref:`concept-modes`. 
    :param size: A 2-tuple, containing (width, height) in pixels. 
    :param color: What color to use for the image.  Default is black. 
       If given, this should be a single integer or floating point value 
       for single-band modes, and a tuple for multi-band modes (one value 
       per band).  When creating RGB images, you can also use color 
       strings as supported by the ImageColor module.  If the color is 
       None, the image is not initialised. 
    :returns: An :py:class:`~PIL.Image.Image` object. 
    &quot;&quot;&quot;</span>

    <span class="s1">_check_size(size)</span>

    <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s0"># don't initialize</span>
        <span class="s2">return </span><span class="s1">Image()._new(core.new(mode</span><span class="s2">, </span><span class="s1">size))</span>

    <span class="s2">if </span><span class="s1">isinstance(color</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s0"># css3-style specifier</span>

        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImageColor</span>

        <span class="s1">color = ImageColor.getcolor(color</span><span class="s2">, </span><span class="s1">mode)</span>

    <span class="s1">im = Image()</span>
    <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;P&quot; </span><span class="s2">and </span><span class="s1">isinstance(color</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)) </span><span class="s2">and </span><span class="s1">len(color) </span><span class="s2">in </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]:</span>
        <span class="s0"># RGB or RGBA value for a P image</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImagePalette</span>

        <span class="s1">im.palette = ImagePalette.ImagePalette()</span>
        <span class="s1">color = im.palette.getcolor(color)</span>
    <span class="s2">return </span><span class="s1">im._new(core.fill(mode</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">color))</span>


<span class="s2">def </span><span class="s1">frombytes(mode</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">decoder_name=</span><span class="s3">&quot;raw&quot;</span><span class="s2">, </span><span class="s1">*args):</span>
    <span class="s5">&quot;&quot;&quot; 
    Creates a copy of an image memory from pixel data in a buffer. 
 
    In its simplest form, this function takes three arguments 
    (mode, size, and unpacked pixel data). 
 
    You can also use any pixel decoder supported by PIL. For more 
    information on available decoders, see the section 
    :ref:`Writing Your Own File Codec &lt;file-codecs&gt;`. 
 
    Note that this function decodes pixel data only, not entire images. 
    If you have an entire image in a string, wrap it in a 
    :py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load 
    it. 
 
    :param mode: The image mode. See: :ref:`concept-modes`. 
    :param size: The image size. 
    :param data: A byte buffer containing raw data for the given mode. 
    :param decoder_name: What decoder to use. 
    :param args: Additional parameters for the given decoder. 
    :returns: An :py:class:`~PIL.Image.Image` object. 
    &quot;&quot;&quot;</span>

    <span class="s1">_check_size(size)</span>

    <span class="s0"># may pass tuple instead of argument list</span>
    <span class="s2">if </span><span class="s1">len(args) == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">isinstance(args[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tuple):</span>
        <span class="s1">args = args[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">decoder_name == </span><span class="s3">&quot;raw&quot; </span><span class="s2">and </span><span class="s1">args == ():</span>
        <span class="s1">args = mode</span>

    <span class="s1">im = new(mode</span><span class="s2">, </span><span class="s1">size)</span>
    <span class="s1">im.frombytes(data</span><span class="s2">, </span><span class="s1">decoder_name</span><span class="s2">, </span><span class="s1">args)</span>
    <span class="s2">return </span><span class="s1">im</span>


<span class="s2">def </span><span class="s1">frombuffer(mode</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">decoder_name=</span><span class="s3">&quot;raw&quot;</span><span class="s2">, </span><span class="s1">*args):</span>
    <span class="s5">&quot;&quot;&quot; 
    Creates an image memory referencing pixel data in a byte buffer. 
 
    This function is similar to :py:func:`~PIL.Image.frombytes`, but uses data 
    in the byte buffer, where possible.  This means that changes to the 
    original buffer object are reflected in this image).  Not all modes can 
    share memory; supported modes include &quot;L&quot;, &quot;RGBX&quot;, &quot;RGBA&quot;, and &quot;CMYK&quot;. 
 
    Note that this function decodes pixel data only, not entire images. 
    If you have an entire image file in a string, wrap it in a 
    :py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load it. 
 
    In the current version, the default parameters used for the &quot;raw&quot; decoder 
    differs from that used for :py:func:`~PIL.Image.frombytes`.  This is a 
    bug, and will probably be fixed in a future release.  The current release 
    issues a warning if you do this; to disable the warning, you should provide 
    the full set of parameters.  See below for details. 
 
    :param mode: The image mode. See: :ref:`concept-modes`. 
    :param size: The image size. 
    :param data: A bytes or other buffer object containing raw 
        data for the given mode. 
    :param decoder_name: What decoder to use. 
    :param args: Additional parameters for the given decoder.  For the 
        default encoder (&quot;raw&quot;), it's recommended that you provide the 
        full set of parameters:: 
 
            frombuffer(mode, size, data, &quot;raw&quot;, mode, 0, 1) 
 
    :returns: An :py:class:`~PIL.Image.Image` object. 
 
    .. versionadded:: 1.1.4 
    &quot;&quot;&quot;</span>

    <span class="s1">_check_size(size)</span>

    <span class="s0"># may pass tuple instead of argument list</span>
    <span class="s2">if </span><span class="s1">len(args) == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">isinstance(args[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tuple):</span>
        <span class="s1">args = args[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">decoder_name == </span><span class="s3">&quot;raw&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">args == ():</span>
            <span class="s1">args = mode</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">args[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">_MAPMODES:</span>
            <span class="s1">im = new(mode</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">im = im._new(core.map_buffer(data</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">decoder_name</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">args))</span>
            <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;P&quot;</span><span class="s1">:</span>
                <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImagePalette</span>

                <span class="s1">im.palette = ImagePalette.ImagePalette(</span><span class="s3">&quot;RGB&quot;</span><span class="s2">, </span><span class="s1">im.im.getpalette(</span><span class="s3">&quot;RGB&quot;</span><span class="s1">))</span>
            <span class="s1">im.readonly = </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">im</span>

    <span class="s2">return </span><span class="s1">frombytes(mode</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">decoder_name</span><span class="s2">, </span><span class="s1">args)</span>


<span class="s2">def </span><span class="s1">fromarray(obj</span><span class="s2">, </span><span class="s1">mode=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Creates an image memory from an object exporting the array interface 
    (using the buffer protocol). 
 
    If ``obj`` is not contiguous, then the ``tobytes`` method is called 
    and :py:func:`~PIL.Image.frombuffer` is used. 
 
    If you have an image in NumPy:: 
 
      from PIL import Image 
      import numpy as np 
      im = Image.open(&quot;hopper.jpg&quot;) 
      a = np.asarray(im) 
 
    Then this can be used to convert it to a Pillow image:: 
 
      im = Image.fromarray(a) 
 
    :param obj: Object with array interface 
    :param mode: Optional mode to use when reading ``obj``. Will be determined from 
      type if ``None``. 
 
      This will not be used to convert the data after reading, but will be used to 
      change how the data is read:: 
 
        from PIL import Image 
        import numpy as np 
        a = np.full((1, 1), 300) 
        im = Image.fromarray(a, mode=&quot;L&quot;) 
        im.getpixel((0, 0))  # 44 
        im = Image.fromarray(a, mode=&quot;RGB&quot;) 
        im.getpixel((0, 0))  # (44, 1, 0) 
 
      See: :ref:`concept-modes` for general information about modes. 
    :returns: An image object. 
 
    .. versionadded:: 1.1.6 
    &quot;&quot;&quot;</span>
    <span class="s1">arr = obj.__array_interface__</span>
    <span class="s1">shape = arr[</span><span class="s3">&quot;shape&quot;</span><span class="s1">]</span>
    <span class="s1">ndim = len(shape)</span>
    <span class="s1">strides = arr.get(</span><span class="s3">&quot;strides&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">typekey = (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) + shape[</span><span class="s4">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">arr[</span><span class="s3">&quot;typestr&quot;</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">msg = </span><span class="s3">&quot;Cannot handle this data type&quot;</span>
            <span class="s2">raise </span><span class="s1">TypeError(msg) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">mode</span><span class="s2">, </span><span class="s1">rawmode = _fromarray_typemap[typekey]</span>
        <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">msg = </span><span class="s3">&quot;Cannot handle this data type: %s, %s&quot; </span><span class="s1">% typekey</span>
            <span class="s2">raise </span><span class="s1">TypeError(msg) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">rawmode = mode</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;P&quot;</span><span class="s2">, </span><span class="s3">&quot;F&quot;</span><span class="s1">]:</span>
        <span class="s1">ndmax = </span><span class="s4">2</span>
    <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">&quot;RGB&quot;</span><span class="s1">:</span>
        <span class="s1">ndmax = </span><span class="s4">3</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">ndmax = </span><span class="s4">4</span>
    <span class="s2">if </span><span class="s1">ndim &gt; ndmax:</span>
        <span class="s1">msg = </span><span class="s3">f&quot;Too many dimensions: </span><span class="s2">{</span><span class="s1">ndim</span><span class="s2">} </span><span class="s3">&gt; </span><span class="s2">{</span><span class="s1">ndmax</span><span class="s2">}</span><span class="s3">.&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s1">size = </span><span class="s4">1 </span><span class="s2">if </span><span class="s1">ndim == </span><span class="s4">1 </span><span class="s2">else </span><span class="s1">shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">strides </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s3">&quot;tobytes&quot;</span><span class="s1">):</span>
            <span class="s1">obj = obj.tobytes()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">obj = obj.tostring()</span>

    <span class="s2">return </span><span class="s1">frombuffer(mode</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s3">&quot;raw&quot;</span><span class="s2">, </span><span class="s1">rawmode</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">fromqimage(im):</span>
    <span class="s5">&quot;&quot;&quot;Creates an image instance from a QImage image&quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImageQt</span>

    <span class="s2">if not </span><span class="s1">ImageQt.qt_is_installed:</span>
        <span class="s1">msg = </span><span class="s3">&quot;Qt bindings are not installed&quot;</span>
        <span class="s2">raise </span><span class="s1">ImportError(msg)</span>
    <span class="s2">return </span><span class="s1">ImageQt.fromqimage(im)</span>


<span class="s2">def </span><span class="s1">fromqpixmap(im):</span>
    <span class="s5">&quot;&quot;&quot;Creates an image instance from a QPixmap image&quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImageQt</span>

    <span class="s2">if not </span><span class="s1">ImageQt.qt_is_installed:</span>
        <span class="s1">msg = </span><span class="s3">&quot;Qt bindings are not installed&quot;</span>
        <span class="s2">raise </span><span class="s1">ImportError(msg)</span>
    <span class="s2">return </span><span class="s1">ImageQt.fromqpixmap(im)</span>


<span class="s1">_fromarray_typemap = {</span>
    <span class="s0"># (shape, typestr) =&gt; mode, rawmode</span>
    <span class="s0"># first two members of shape are set to one</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;|b1&quot;</span><span class="s1">): (</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;1;8&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;|u1&quot;</span><span class="s1">): (</span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;|i1&quot;</span><span class="s1">): (</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;I;8&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;&lt;u2&quot;</span><span class="s1">): (</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;I;16&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;&gt;u2&quot;</span><span class="s1">): (</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;I;16B&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;&lt;i2&quot;</span><span class="s1">): (</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;I;16S&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;&gt;i2&quot;</span><span class="s1">): (</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;I;16BS&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;&lt;u4&quot;</span><span class="s1">): (</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;I;32&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;&gt;u4&quot;</span><span class="s1">): (</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;I;32B&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;&lt;i4&quot;</span><span class="s1">): (</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;I;32S&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;&gt;i4&quot;</span><span class="s1">): (</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;I;32BS&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;&lt;f4&quot;</span><span class="s1">): (</span><span class="s3">&quot;F&quot;</span><span class="s2">, </span><span class="s3">&quot;F;32F&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;&gt;f4&quot;</span><span class="s1">): (</span><span class="s3">&quot;F&quot;</span><span class="s2">, </span><span class="s3">&quot;F;32BF&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;&lt;f8&quot;</span><span class="s1">): (</span><span class="s3">&quot;F&quot;</span><span class="s2">, </span><span class="s3">&quot;F;64F&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;&gt;f8&quot;</span><span class="s1">): (</span><span class="s3">&quot;F&quot;</span><span class="s2">, </span><span class="s3">&quot;F;64BF&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;|u1&quot;</span><span class="s1">): (</span><span class="s3">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">&quot;LA&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;|u1&quot;</span><span class="s1">): (</span><span class="s3">&quot;RGB&quot;</span><span class="s2">, </span><span class="s3">&quot;RGB&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;|u1&quot;</span><span class="s1">): (</span><span class="s3">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s0"># shortcuts:</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_ENDIAN + </span><span class="s3">&quot;i4&quot;</span><span class="s1">): (</span><span class="s3">&quot;I&quot;</span><span class="s2">, </span><span class="s3">&quot;I&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_ENDIAN + </span><span class="s3">&quot;f4&quot;</span><span class="s1">): (</span><span class="s3">&quot;F&quot;</span><span class="s2">, </span><span class="s3">&quot;F&quot;</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">_decompression_bomb_check(size):</span>
    <span class="s2">if </span><span class="s1">MAX_IMAGE_PIXELS </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return</span>

    <span class="s1">pixels = size[</span><span class="s4">0</span><span class="s1">] * size[</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">pixels &gt; </span><span class="s4">2 </span><span class="s1">* MAX_IMAGE_PIXELS:</span>
        <span class="s1">msg = (</span>
            <span class="s3">f&quot;Image size (</span><span class="s2">{</span><span class="s1">pixels</span><span class="s2">} </span><span class="s3">pixels) exceeds limit of </span><span class="s2">{</span><span class="s4">2 </span><span class="s1">* MAX_IMAGE_PIXELS</span><span class="s2">} </span><span class="s3">&quot;</span>
            <span class="s3">&quot;pixels, could be decompression bomb DOS attack.&quot;</span>
        <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">DecompressionBombError(msg)</span>

    <span class="s2">if </span><span class="s1">pixels &gt; MAX_IMAGE_PIXELS:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">f&quot;Image size (</span><span class="s2">{</span><span class="s1">pixels</span><span class="s2">} </span><span class="s3">pixels) exceeds limit of </span><span class="s2">{</span><span class="s1">MAX_IMAGE_PIXELS</span><span class="s2">} </span><span class="s3">pixels, &quot;</span>
            <span class="s3">&quot;could be decompression bomb DOS attack.&quot;</span><span class="s2">,</span>
            <span class="s1">DecompressionBombWarning</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">open(fp</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;r&quot;</span><span class="s2">, </span><span class="s1">formats=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Opens and identifies the given image file. 
 
    This is a lazy operation; this function identifies the file, but 
    the file remains open and the actual image data is not read from 
    the file until you try to process the data (or call the 
    :py:meth:`~PIL.Image.Image.load` method).  See 
    :py:func:`~PIL.Image.new`. See :ref:`file-handling`. 
 
    :param fp: A filename (string), pathlib.Path object or a file object. 
       The file object must implement ``file.read``, 
       ``file.seek``, and ``file.tell`` methods, 
       and be opened in binary mode. 
    :param mode: The mode.  If given, this argument must be &quot;r&quot;. 
    :param formats: A list or tuple of formats to attempt to load the file in. 
       This can be used to restrict the set of formats checked. 
       Pass ``None`` to try all supported formats. You can print the set of 
       available formats by running ``python3 -m PIL`` or using 
       the :py:func:`PIL.features.pilinfo` function. 
    :returns: An :py:class:`~PIL.Image.Image` object. 
    :exception FileNotFoundError: If the file cannot be found. 
    :exception PIL.UnidentifiedImageError: If the image cannot be opened and 
       identified. 
    :exception ValueError: If the ``mode`` is not &quot;r&quot;, or if a ``StringIO`` 
       instance is used for ``fp``. 
    :exception TypeError: If ``formats`` is not ``None``, a list or a tuple. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">mode != </span><span class="s3">&quot;r&quot;</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s3">f&quot;bad mode </span><span class="s2">{</span><span class="s1">repr(mode)</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
    <span class="s2">elif </span><span class="s1">isinstance(fp</span><span class="s2">, </span><span class="s1">io.StringIO):</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;StringIO cannot be used to open an image. &quot;</span>
            <span class="s3">&quot;Binary data must be used instead.&quot;</span>
        <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s2">if </span><span class="s1">formats </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">formats = ID</span>
    <span class="s2">elif not </span><span class="s1">isinstance(formats</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s1">msg = </span><span class="s3">&quot;formats must be a list or tuple&quot;</span>
        <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s1">exclusive_fp = </span><span class="s2">False</span>
    <span class="s1">filename = </span><span class="s3">&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(fp</span><span class="s2">, </span><span class="s1">Path):</span>
        <span class="s1">filename = str(fp.resolve())</span>
    <span class="s2">elif </span><span class="s1">is_path(fp):</span>
        <span class="s1">filename = fp</span>

    <span class="s2">if </span><span class="s1">filename:</span>
        <span class="s1">fp = builtins.open(filename</span><span class="s2">, </span><span class="s3">&quot;rb&quot;</span><span class="s1">)</span>
        <span class="s1">exclusive_fp = </span><span class="s2">True</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">fp.seek(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">io.UnsupportedOperation):</span>
        <span class="s1">fp = io.BytesIO(fp.read())</span>
        <span class="s1">exclusive_fp = </span><span class="s2">True</span>

    <span class="s1">prefix = fp.read(</span><span class="s4">16</span><span class="s1">)</span>

    <span class="s1">preinit()</span>

    <span class="s1">accept_warnings = []</span>

    <span class="s2">def </span><span class="s1">_open_core(fp</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">formats):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">formats:</span>
            <span class="s1">i = i.upper()</span>
            <span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">OPEN:</span>
                <span class="s1">init()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">factory</span><span class="s2">, </span><span class="s1">accept = OPEN[i]</span>
                <span class="s1">result = </span><span class="s2">not </span><span class="s1">accept </span><span class="s2">or </span><span class="s1">accept(prefix)</span>
                <span class="s2">if </span><span class="s1">type(result) </span><span class="s2">in </span><span class="s1">[str</span><span class="s2">, </span><span class="s1">bytes]:</span>
                    <span class="s1">accept_warnings.append(result)</span>
                <span class="s2">elif </span><span class="s1">result:</span>
                    <span class="s1">fp.seek(</span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s1">im = factory(fp</span><span class="s2">, </span><span class="s1">filename)</span>
                    <span class="s1">_decompression_bomb_check(im.size)</span>
                    <span class="s2">return </span><span class="s1">im</span>
            <span class="s2">except </span><span class="s1">(SyntaxError</span><span class="s2">, </span><span class="s1">IndexError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">struct.error):</span>
                <span class="s0"># Leave disabled by default, spams the logs with image</span>
                <span class="s0"># opening failures that are entirely expected.</span>
                <span class="s0"># logger.debug(&quot;&quot;, exc_info=True)</span>
                <span class="s2">continue</span>
            <span class="s2">except </span><span class="s1">BaseException:</span>
                <span class="s2">if </span><span class="s1">exclusive_fp:</span>
                    <span class="s1">fp.close()</span>
                <span class="s2">raise</span>
        <span class="s2">return None</span>

    <span class="s1">im = _open_core(fp</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">formats)</span>

    <span class="s2">if </span><span class="s1">im </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">init():</span>
            <span class="s1">im = _open_core(fp</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">formats)</span>

    <span class="s2">if </span><span class="s1">im:</span>
        <span class="s1">im._exclusive_fp = exclusive_fp</span>
        <span class="s2">return </span><span class="s1">im</span>

    <span class="s2">if </span><span class="s1">exclusive_fp:</span>
        <span class="s1">fp.close()</span>
    <span class="s2">for </span><span class="s1">message </span><span class="s2">in </span><span class="s1">accept_warnings:</span>
        <span class="s1">warnings.warn(message)</span>
    <span class="s1">msg = </span><span class="s3">&quot;cannot identify image file %r&quot; </span><span class="s1">% (filename </span><span class="s2">if </span><span class="s1">filename </span><span class="s2">else </span><span class="s1">fp)</span>
    <span class="s2">raise </span><span class="s1">UnidentifiedImageError(msg)</span>


<span class="s0">#</span>
<span class="s0"># Image processing.</span>


<span class="s2">def </span><span class="s1">alpha_composite(im1</span><span class="s2">, </span><span class="s1">im2):</span>
    <span class="s5">&quot;&quot;&quot; 
    Alpha composite im2 over im1. 
 
    :param im1: The first image. Must have mode RGBA. 
    :param im2: The second image.  Must have mode RGBA, and the same size as 
       the first image. 
    :returns: An :py:class:`~PIL.Image.Image` object. 
    &quot;&quot;&quot;</span>

    <span class="s1">im1.load()</span>
    <span class="s1">im2.load()</span>
    <span class="s2">return </span><span class="s1">im1._new(core.alpha_composite(im1.im</span><span class="s2">, </span><span class="s1">im2.im))</span>


<span class="s2">def </span><span class="s1">blend(im1</span><span class="s2">, </span><span class="s1">im2</span><span class="s2">, </span><span class="s1">alpha):</span>
    <span class="s5">&quot;&quot;&quot; 
    Creates a new image by interpolating between two input images, using 
    a constant alpha:: 
 
        out = image1 * (1.0 - alpha) + image2 * alpha 
 
    :param im1: The first image. 
    :param im2: The second image.  Must have the same mode and size as 
       the first image. 
    :param alpha: The interpolation alpha factor.  If alpha is 0.0, a 
       copy of the first image is returned. If alpha is 1.0, a copy of 
       the second image is returned. There are no restrictions on the 
       alpha value. If necessary, the result is clipped to fit into 
       the allowed output range. 
    :returns: An :py:class:`~PIL.Image.Image` object. 
    &quot;&quot;&quot;</span>

    <span class="s1">im1.load()</span>
    <span class="s1">im2.load()</span>
    <span class="s2">return </span><span class="s1">im1._new(core.blend(im1.im</span><span class="s2">, </span><span class="s1">im2.im</span><span class="s2">, </span><span class="s1">alpha))</span>


<span class="s2">def </span><span class="s1">composite(image1</span><span class="s2">, </span><span class="s1">image2</span><span class="s2">, </span><span class="s1">mask):</span>
    <span class="s5">&quot;&quot;&quot; 
    Create composite image by blending images using a transparency mask. 
 
    :param image1: The first image. 
    :param image2: The second image.  Must have the same mode and 
       size as the first image. 
    :param mask: A mask image.  This image can have mode 
       &quot;1&quot;, &quot;L&quot;, or &quot;RGBA&quot;, and must have the same size as the 
       other two images. 
    &quot;&quot;&quot;</span>

    <span class="s1">image = image2.copy()</span>
    <span class="s1">image.paste(image1</span><span class="s2">, None, </span><span class="s1">mask)</span>
    <span class="s2">return </span><span class="s1">image</span>


<span class="s2">def </span><span class="s1">eval(image</span><span class="s2">, </span><span class="s1">*args):</span>
    <span class="s5">&quot;&quot;&quot; 
    Applies the function (which should take one argument) to each pixel 
    in the given image. If the image has more than one band, the same 
    function is applied to each band. Note that the function is 
    evaluated once for each possible pixel value, so you cannot use 
    random components or other generators. 
 
    :param image: The input image. 
    :param function: A function object, taking one integer argument. 
    :returns: An :py:class:`~PIL.Image.Image` object. 
    &quot;&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">image.point(args[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">merge(mode</span><span class="s2">, </span><span class="s1">bands):</span>
    <span class="s5">&quot;&quot;&quot; 
    Merge a set of single band images into a new multiband image. 
 
    :param mode: The mode to use for the output image. See: 
        :ref:`concept-modes`. 
    :param bands: A sequence containing one single-band image for 
        each band in the output image.  All bands must have the 
        same size. 
    :returns: An :py:class:`~PIL.Image.Image` object. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">getmodebands(mode) != len(bands) </span><span class="s2">or </span><span class="s3">&quot;*&quot; </span><span class="s2">in </span><span class="s1">mode:</span>
        <span class="s1">msg = </span><span class="s3">&quot;wrong number of bands&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
    <span class="s2">for </span><span class="s1">band </span><span class="s2">in </span><span class="s1">bands[</span><span class="s4">1</span><span class="s1">:]:</span>
        <span class="s2">if </span><span class="s1">band.mode != getmodetype(mode):</span>
            <span class="s1">msg = </span><span class="s3">&quot;mode mismatch&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s2">if </span><span class="s1">band.size != bands[</span><span class="s4">0</span><span class="s1">].size:</span>
            <span class="s1">msg = </span><span class="s3">&quot;size mismatch&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
    <span class="s2">for </span><span class="s1">band </span><span class="s2">in </span><span class="s1">bands:</span>
        <span class="s1">band.load()</span>
    <span class="s2">return </span><span class="s1">bands[</span><span class="s4">0</span><span class="s1">]._new(core.merge(mode</span><span class="s2">, </span><span class="s1">*[b.im </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">bands]))</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Plugin registry</span>


<span class="s2">def </span><span class="s1">register_open(id</span><span class="s2">, </span><span class="s1">factory</span><span class="s2">, </span><span class="s1">accept=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Register an image file plugin.  This function should not be used 
    in application code. 
 
    :param id: An image format identifier. 
    :param factory: An image file factory method. 
    :param accept: An optional function that can be used to quickly 
       reject images having another format. 
    &quot;&quot;&quot;</span>
    <span class="s1">id = id.upper()</span>
    <span class="s1">ID.append(id)</span>
    <span class="s1">OPEN[id] = factory</span><span class="s2">, </span><span class="s1">accept</span>


<span class="s2">def </span><span class="s1">register_mime(id</span><span class="s2">, </span><span class="s1">mimetype):</span>
    <span class="s5">&quot;&quot;&quot; 
    Registers an image MIME type.  This function should not be used 
    in application code. 
 
    :param id: An image format identifier. 
    :param mimetype: The image MIME type for this format. 
    &quot;&quot;&quot;</span>
    <span class="s1">MIME[id.upper()] = mimetype</span>


<span class="s2">def </span><span class="s1">register_save(id</span><span class="s2">, </span><span class="s1">driver):</span>
    <span class="s5">&quot;&quot;&quot; 
    Registers an image save function.  This function should not be 
    used in application code. 
 
    :param id: An image format identifier. 
    :param driver: A function to save images in this format. 
    &quot;&quot;&quot;</span>
    <span class="s1">SAVE[id.upper()] = driver</span>


<span class="s2">def </span><span class="s1">register_save_all(id</span><span class="s2">, </span><span class="s1">driver):</span>
    <span class="s5">&quot;&quot;&quot; 
    Registers an image function to save all the frames 
    of a multiframe format.  This function should not be 
    used in application code. 
 
    :param id: An image format identifier. 
    :param driver: A function to save images in this format. 
    &quot;&quot;&quot;</span>
    <span class="s1">SAVE_ALL[id.upper()] = driver</span>


<span class="s2">def </span><span class="s1">register_extension(id</span><span class="s2">, </span><span class="s1">extension):</span>
    <span class="s5">&quot;&quot;&quot; 
    Registers an image extension.  This function should not be 
    used in application code. 
 
    :param id: An image format identifier. 
    :param extension: An extension used for this format. 
    &quot;&quot;&quot;</span>
    <span class="s1">EXTENSION[extension.lower()] = id.upper()</span>


<span class="s2">def </span><span class="s1">register_extensions(id</span><span class="s2">, </span><span class="s1">extensions):</span>
    <span class="s5">&quot;&quot;&quot; 
    Registers image extensions.  This function should not be 
    used in application code. 
 
    :param id: An image format identifier. 
    :param extensions: A list of extensions used for this format. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">extension </span><span class="s2">in </span><span class="s1">extensions:</span>
        <span class="s1">register_extension(id</span><span class="s2">, </span><span class="s1">extension)</span>


<span class="s2">def </span><span class="s1">registered_extensions():</span>
    <span class="s5">&quot;&quot;&quot; 
    Returns a dictionary containing all file extensions belonging 
    to registered plugins 
    &quot;&quot;&quot;</span>
    <span class="s1">init()</span>
    <span class="s2">return </span><span class="s1">EXTENSION</span>


<span class="s2">def </span><span class="s1">register_decoder(name</span><span class="s2">, </span><span class="s1">decoder):</span>
    <span class="s5">&quot;&quot;&quot; 
    Registers an image decoder.  This function should not be 
    used in application code. 
 
    :param name: The name of the decoder 
    :param decoder: A callable(mode, args) that returns an 
                    ImageFile.PyDecoder object 
 
    .. versionadded:: 4.1.0 
    &quot;&quot;&quot;</span>
    <span class="s1">DECODERS[name] = decoder</span>


<span class="s2">def </span><span class="s1">register_encoder(name</span><span class="s2">, </span><span class="s1">encoder):</span>
    <span class="s5">&quot;&quot;&quot; 
    Registers an image encoder.  This function should not be 
    used in application code. 
 
    :param name: The name of the encoder 
    :param encoder: A callable(mode, args) that returns an 
                    ImageFile.PyEncoder object 
 
    .. versionadded:: 4.1.0 
    &quot;&quot;&quot;</span>
    <span class="s1">ENCODERS[name] = encoder</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Simple display support.</span>


<span class="s2">def </span><span class="s1">_show(image</span><span class="s2">, </span><span class="s1">**options):</span>
    <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ImageShow</span>

    <span class="s1">ImageShow.show(image</span><span class="s2">, </span><span class="s1">**options)</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Effects</span>


<span class="s2">def </span><span class="s1">effect_mandelbrot(size</span><span class="s2">, </span><span class="s1">extent</span><span class="s2">, </span><span class="s1">quality):</span>
    <span class="s5">&quot;&quot;&quot; 
    Generate a Mandelbrot set covering the given extent. 
 
    :param size: The requested size in pixels, as a 2-tuple: 
       (width, height). 
    :param extent: The extent to cover, as a 4-tuple: 
       (x0, y0, x1, y1). 
    :param quality: Quality. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Image()._new(core.effect_mandelbrot(size</span><span class="s2">, </span><span class="s1">extent</span><span class="s2">, </span><span class="s1">quality))</span>


<span class="s2">def </span><span class="s1">effect_noise(size</span><span class="s2">, </span><span class="s1">sigma):</span>
    <span class="s5">&quot;&quot;&quot; 
    Generate Gaussian noise centered around 128. 
 
    :param size: The requested size in pixels, as a 2-tuple: 
       (width, height). 
    :param sigma: Standard deviation of noise. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Image()._new(core.effect_noise(size</span><span class="s2">, </span><span class="s1">sigma))</span>


<span class="s2">def </span><span class="s1">linear_gradient(mode):</span>
    <span class="s5">&quot;&quot;&quot; 
    Generate 256x256 linear gradient from black to white, top to bottom. 
 
    :param mode: Input mode. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Image()._new(core.linear_gradient(mode))</span>


<span class="s2">def </span><span class="s1">radial_gradient(mode):</span>
    <span class="s5">&quot;&quot;&quot; 
    Generate 256x256 radial gradient from black to white, centre to edge. 
 
    :param mode: Input mode. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Image()._new(core.radial_gradient(mode))</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Resources</span>


<span class="s2">def </span><span class="s1">_apply_env_variables(env=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">env </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">env = os.environ</span>

    <span class="s2">for </span><span class="s1">var_name</span><span class="s2">, </span><span class="s1">setter </span><span class="s2">in </span><span class="s1">[</span>
        <span class="s1">(</span><span class="s3">&quot;PILLOW_ALIGNMENT&quot;</span><span class="s2">, </span><span class="s1">core.set_alignment)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;PILLOW_BLOCK_SIZE&quot;</span><span class="s2">, </span><span class="s1">core.set_block_size)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;PILLOW_BLOCKS_MAX&quot;</span><span class="s2">, </span><span class="s1">core.set_blocks_max)</span><span class="s2">,</span>
    <span class="s1">]:</span>
        <span class="s2">if </span><span class="s1">var_name </span><span class="s2">not in </span><span class="s1">env:</span>
            <span class="s2">continue</span>

        <span class="s1">var = env[var_name].lower()</span>

        <span class="s1">units = </span><span class="s4">1</span>
        <span class="s2">for </span><span class="s1">postfix</span><span class="s2">, </span><span class="s1">mul </span><span class="s2">in </span><span class="s1">[(</span><span class="s3">&quot;k&quot;</span><span class="s2">, </span><span class="s4">1024</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s4">1024 </span><span class="s1">* </span><span class="s4">1024</span><span class="s1">)]:</span>
            <span class="s2">if </span><span class="s1">var.endswith(postfix):</span>
                <span class="s1">units = mul</span>
                <span class="s1">var = var[: -len(postfix)]</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">var = int(var) * units</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s1">warnings.warn(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">var_name</span><span class="s2">} </span><span class="s3">is not int&quot;</span><span class="s1">)</span>
            <span class="s2">continue</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">setter(var)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">warnings.warn(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">var_name</span><span class="s2">}</span><span class="s3">: </span><span class="s2">{</span><span class="s1">e</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s1">_apply_env_variables()</span>
<span class="s1">atexit.register(core.clear_cache)</span>


<span class="s2">class </span><span class="s1">Exif(MutableMapping):</span>
    <span class="s1">endian = </span><span class="s2">None</span>
    <span class="s1">bigtiff = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._data = {}</span>
        <span class="s1">self._hidden_data = {}</span>
        <span class="s1">self._ifds = {}</span>
        <span class="s1">self._info = </span><span class="s2">None</span>
        <span class="s1">self._loaded_exif = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_fixup(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(value) == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">tuple):</span>
                <span class="s2">return </span><span class="s1">value[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">pass</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">_fixup_dict(self</span><span class="s2">, </span><span class="s1">src_dict):</span>
        <span class="s0"># Helper function</span>
        <span class="s0"># returns a dict with any single item tuples/lists as individual values</span>
        <span class="s2">return </span><span class="s1">{k: self._fixup(v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">src_dict.items()}</span>

    <span class="s2">def </span><span class="s1">_get_ifd_dict(self</span><span class="s2">, </span><span class="s1">offset):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s0"># an offset pointer to the location of the nested embedded IFD.</span>
            <span class="s0"># It should be a long, but may be corrupted.</span>
            <span class="s1">self.fp.seek(offset)</span>
        <span class="s2">except </span><span class="s1">(KeyError</span><span class="s2">, </span><span class="s1">TypeError):</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">TiffImagePlugin</span>

            <span class="s1">info = TiffImagePlugin.ImageFileDirectory_v2(self.head)</span>
            <span class="s1">info.load(self.fp)</span>
            <span class="s2">return </span><span class="s1">self._fixup_dict(info)</span>

    <span class="s2">def </span><span class="s1">_get_head(self):</span>
        <span class="s1">version = </span><span class="s6">b&quot;</span><span class="s2">\x2B</span><span class="s6">&quot; </span><span class="s2">if </span><span class="s1">self.bigtiff </span><span class="s2">else </span><span class="s6">b&quot;</span><span class="s2">\x2A</span><span class="s6">&quot;</span>
        <span class="s2">if </span><span class="s1">self.endian == </span><span class="s3">&quot;&lt;&quot;</span><span class="s1">:</span>
            <span class="s1">head = </span><span class="s6">b&quot;II&quot; </span><span class="s1">+ version + </span><span class="s6">b&quot;</span><span class="s2">\x00</span><span class="s6">&quot; </span><span class="s1">+ o32le(</span><span class="s4">8</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">head = </span><span class="s6">b&quot;MM</span><span class="s2">\x00</span><span class="s6">&quot; </span><span class="s1">+ version + o32be(</span><span class="s4">8</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.bigtiff:</span>
            <span class="s1">head += o32le(</span><span class="s4">8</span><span class="s1">) </span><span class="s2">if </span><span class="s1">self.endian == </span><span class="s3">&quot;&lt;&quot; </span><span class="s2">else </span><span class="s1">o32be(</span><span class="s4">8</span><span class="s1">)</span>
            <span class="s1">head += </span><span class="s6">b&quot;</span><span class="s2">\x00\x00\x00\x00</span><span class="s6">&quot;</span>
        <span class="s2">return </span><span class="s1">head</span>

    <span class="s2">def </span><span class="s1">load(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s0"># Extract EXIF information.  This is highly experimental,</span>
        <span class="s0"># and is likely to be replaced with something better in a future</span>
        <span class="s0"># version.</span>

        <span class="s0"># The EXIF record consists of a TIFF file embedded in a JPEG</span>
        <span class="s0"># application marker (!).</span>
        <span class="s2">if </span><span class="s1">data == self._loaded_exif:</span>
            <span class="s2">return</span>
        <span class="s1">self._loaded_exif = data</span>
        <span class="s1">self._data.clear()</span>
        <span class="s1">self._hidden_data.clear()</span>
        <span class="s1">self._ifds.clear()</span>
        <span class="s2">if </span><span class="s1">data </span><span class="s2">and </span><span class="s1">data.startswith(</span><span class="s6">b&quot;Exif</span><span class="s2">\x00\x00</span><span class="s6">&quot;</span><span class="s1">):</span>
            <span class="s1">data = data[</span><span class="s4">6</span><span class="s1">:]</span>
        <span class="s2">if not </span><span class="s1">data:</span>
            <span class="s1">self._info = </span><span class="s2">None</span>
            <span class="s2">return</span>

        <span class="s1">self.fp = io.BytesIO(data)</span>
        <span class="s1">self.head = self.fp.read(</span><span class="s4">8</span><span class="s1">)</span>
        <span class="s0"># process dictionary</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">TiffImagePlugin</span>

        <span class="s1">self._info = TiffImagePlugin.ImageFileDirectory_v2(self.head)</span>
        <span class="s1">self.endian = self._info._endian</span>
        <span class="s1">self.fp.seek(self._info.next)</span>
        <span class="s1">self._info.load(self.fp)</span>

    <span class="s2">def </span><span class="s1">load_from_fp(self</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">offset=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self._loaded_exif = </span><span class="s2">None</span>
        <span class="s1">self._data.clear()</span>
        <span class="s1">self._hidden_data.clear()</span>
        <span class="s1">self._ifds.clear()</span>

        <span class="s0"># process dictionary</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">TiffImagePlugin</span>

        <span class="s1">self.fp = fp</span>
        <span class="s2">if </span><span class="s1">offset </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.head = self._get_head()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.head = self.fp.read(</span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">self._info = TiffImagePlugin.ImageFileDirectory_v2(self.head)</span>
        <span class="s2">if </span><span class="s1">self.endian </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.endian = self._info._endian</span>
        <span class="s2">if </span><span class="s1">offset </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">offset = self._info.next</span>
        <span class="s1">self.fp.seek(offset)</span>
        <span class="s1">self._info.load(self.fp)</span>

    <span class="s2">def </span><span class="s1">_get_merged_dict(self):</span>
        <span class="s1">merged_dict = dict(self)</span>

        <span class="s0"># get EXIF extension</span>
        <span class="s2">if </span><span class="s1">ExifTags.IFD.Exif </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s1">ifd = self._get_ifd_dict(self[ExifTags.IFD.Exif])</span>
            <span class="s2">if </span><span class="s1">ifd:</span>
                <span class="s1">merged_dict.update(ifd)</span>

        <span class="s0"># GPS</span>
        <span class="s2">if </span><span class="s1">ExifTags.IFD.GPSInfo </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s1">merged_dict[ExifTags.IFD.GPSInfo] = self._get_ifd_dict(</span>
                <span class="s1">self[ExifTags.IFD.GPSInfo]</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">merged_dict</span>

    <span class="s2">def </span><span class="s1">tobytes(self</span><span class="s2">, </span><span class="s1">offset=</span><span class="s4">8</span><span class="s1">):</span>
        <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">TiffImagePlugin</span>

        <span class="s1">head = self._get_head()</span>
        <span class="s1">ifd = TiffImagePlugin.ImageFileDirectory_v2(ifh=head)</span>
        <span class="s2">for </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self.items():</span>
            <span class="s2">if </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">[</span>
                <span class="s1">ExifTags.IFD.Exif</span><span class="s2">,</span>
                <span class="s1">ExifTags.IFD.GPSInfo</span><span class="s2">,</span>
            <span class="s1">] </span><span class="s2">and not </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s1">value = self.get_ifd(tag)</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">tag == ExifTags.IFD.Exif</span>
                    <span class="s2">and </span><span class="s1">ExifTags.IFD.Interop </span><span class="s2">in </span><span class="s1">value</span>
                    <span class="s2">and not </span><span class="s1">isinstance(value[ExifTags.IFD.Interop]</span><span class="s2">, </span><span class="s1">dict)</span>
                <span class="s1">):</span>
                    <span class="s1">value = value.copy()</span>
                    <span class="s1">value[ExifTags.IFD.Interop] = self.get_ifd(ExifTags.IFD.Interop)</span>
            <span class="s1">ifd[tag] = value</span>
        <span class="s2">return </span><span class="s6">b&quot;Exif</span><span class="s2">\x00\x00</span><span class="s6">&quot; </span><span class="s1">+ head + ifd.tobytes(offset)</span>

    <span class="s2">def </span><span class="s1">get_ifd(self</span><span class="s2">, </span><span class="s1">tag):</span>
        <span class="s2">if </span><span class="s1">tag </span><span class="s2">not in </span><span class="s1">self._ifds:</span>
            <span class="s2">if </span><span class="s1">tag == ExifTags.IFD.IFD1:</span>
                <span class="s2">if </span><span class="s1">self._info </span><span class="s2">is not None and </span><span class="s1">self._info.next != </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">self._ifds[tag] = self._get_ifd_dict(self._info.next)</span>
            <span class="s2">elif </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">[ExifTags.IFD.Exif</span><span class="s2">, </span><span class="s1">ExifTags.IFD.GPSInfo]:</span>
                <span class="s1">offset = self._hidden_data.get(tag</span><span class="s2">, </span><span class="s1">self.get(tag))</span>
                <span class="s2">if </span><span class="s1">offset </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">self._ifds[tag] = self._get_ifd_dict(offset)</span>
            <span class="s2">elif </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">[ExifTags.IFD.Interop</span><span class="s2">, </span><span class="s1">ExifTags.IFD.Makernote]:</span>
                <span class="s2">if </span><span class="s1">ExifTags.IFD.Exif </span><span class="s2">not in </span><span class="s1">self._ifds:</span>
                    <span class="s1">self.get_ifd(ExifTags.IFD.Exif)</span>
                <span class="s1">tag_data = self._ifds[ExifTags.IFD.Exif][tag]</span>
                <span class="s2">if </span><span class="s1">tag == ExifTags.IFD.Makernote:</span>
                    <span class="s2">from </span><span class="s1">.TiffImagePlugin </span><span class="s2">import </span><span class="s1">ImageFileDirectory_v2</span>

                    <span class="s2">if </span><span class="s1">tag_data[:</span><span class="s4">8</span><span class="s1">] == </span><span class="s6">b&quot;FUJIFILM&quot;</span><span class="s1">:</span>
                        <span class="s1">ifd_offset = i32le(tag_data</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span>
                        <span class="s1">ifd_data = tag_data[ifd_offset:]</span>

                        <span class="s1">makernote = {}</span>
                        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">struct.unpack(</span><span class="s3">&quot;&lt;H&quot;</span><span class="s2">, </span><span class="s1">ifd_data[:</span><span class="s4">2</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">]):</span>
                            <span class="s1">ifd_tag</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">count</span><span class="s2">, </span><span class="s1">data = struct.unpack(</span>
                                <span class="s3">&quot;&lt;HHL4s&quot;</span><span class="s2">, </span><span class="s1">ifd_data[i * </span><span class="s4">12 </span><span class="s1">+ </span><span class="s4">2 </span><span class="s1">: (i + </span><span class="s4">1</span><span class="s1">) * </span><span class="s4">12 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">]</span>
                            <span class="s1">)</span>
                            <span class="s2">try</span><span class="s1">:</span>
                                <span class="s1">(</span>
                                    <span class="s1">unit_size</span><span class="s2">,</span>
                                    <span class="s1">handler</span><span class="s2">,</span>
                                <span class="s1">) = ImageFileDirectory_v2._load_dispatch[typ]</span>
                            <span class="s2">except </span><span class="s1">KeyError:</span>
                                <span class="s2">continue</span>
                            <span class="s1">size = count * unit_size</span>
                            <span class="s2">if </span><span class="s1">size &gt; </span><span class="s4">4</span><span class="s1">:</span>
                                <span class="s1">(offset</span><span class="s2">,</span><span class="s1">) = struct.unpack(</span><span class="s3">&quot;&lt;L&quot;</span><span class="s2">, </span><span class="s1">data)</span>
                                <span class="s1">data = ifd_data[offset - </span><span class="s4">12 </span><span class="s1">: offset + size - </span><span class="s4">12</span><span class="s1">]</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">data = data[:size]</span>

                            <span class="s2">if </span><span class="s1">len(data) != size:</span>
                                <span class="s1">warnings.warn(</span>
                                    <span class="s3">&quot;Possibly corrupt EXIF MakerNote data.  &quot;</span>
                                    <span class="s3">f&quot;Expecting to read </span><span class="s2">{</span><span class="s1">size</span><span class="s2">} </span><span class="s3">bytes but only got &quot;</span>
                                    <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">len(data)</span><span class="s2">}</span><span class="s3">. Skipping tag </span><span class="s2">{</span><span class="s1">ifd_tag</span><span class="s2">}</span><span class="s3">&quot;</span>
                                <span class="s1">)</span>
                                <span class="s2">continue</span>

                            <span class="s2">if not </span><span class="s1">data:</span>
                                <span class="s2">continue</span>

                            <span class="s1">makernote[ifd_tag] = handler(</span>
                                <span class="s1">ImageFileDirectory_v2()</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, False</span>
                            <span class="s1">)</span>
                        <span class="s1">self._ifds[tag] = dict(self._fixup_dict(makernote))</span>
                    <span class="s2">elif </span><span class="s1">self.get(</span><span class="s4">0x010F</span><span class="s1">) == </span><span class="s3">&quot;Nintendo&quot;</span><span class="s1">:</span>
                        <span class="s1">makernote = {}</span>
                        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">struct.unpack(</span><span class="s3">&quot;&gt;H&quot;</span><span class="s2">, </span><span class="s1">tag_data[:</span><span class="s4">2</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">]):</span>
                            <span class="s1">ifd_tag</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">count</span><span class="s2">, </span><span class="s1">data = struct.unpack(</span>
                                <span class="s3">&quot;&gt;HHL4s&quot;</span><span class="s2">, </span><span class="s1">tag_data[i * </span><span class="s4">12 </span><span class="s1">+ </span><span class="s4">2 </span><span class="s1">: (i + </span><span class="s4">1</span><span class="s1">) * </span><span class="s4">12 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">]</span>
                            <span class="s1">)</span>
                            <span class="s2">if </span><span class="s1">ifd_tag == </span><span class="s4">0x1101</span><span class="s1">:</span>
                                <span class="s0"># CameraInfo</span>
                                <span class="s1">(offset</span><span class="s2">,</span><span class="s1">) = struct.unpack(</span><span class="s3">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">data)</span>
                                <span class="s1">self.fp.seek(offset)</span>

                                <span class="s1">camerainfo = {</span><span class="s3">&quot;ModelID&quot;</span><span class="s1">: self.fp.read(</span><span class="s4">4</span><span class="s1">)}</span>

                                <span class="s1">self.fp.read(</span><span class="s4">4</span><span class="s1">)</span>
                                <span class="s0"># Seconds since 2000</span>
                                <span class="s1">camerainfo[</span><span class="s3">&quot;TimeStamp&quot;</span><span class="s1">] = i32le(self.fp.read(</span><span class="s4">12</span><span class="s1">))</span>

                                <span class="s1">self.fp.read(</span><span class="s4">4</span><span class="s1">)</span>
                                <span class="s1">camerainfo[</span><span class="s3">&quot;InternalSerialNumber&quot;</span><span class="s1">] = self.fp.read(</span><span class="s4">4</span><span class="s1">)</span>

                                <span class="s1">self.fp.read(</span><span class="s4">12</span><span class="s1">)</span>
                                <span class="s1">parallax = self.fp.read(</span><span class="s4">4</span><span class="s1">)</span>
                                <span class="s1">handler = ImageFileDirectory_v2._load_dispatch[</span>
                                    <span class="s1">TiffTags.FLOAT</span>
                                <span class="s1">][</span><span class="s4">1</span><span class="s1">]</span>
                                <span class="s1">camerainfo[</span><span class="s3">&quot;Parallax&quot;</span><span class="s1">] = handler(</span>
                                    <span class="s1">ImageFileDirectory_v2()</span><span class="s2">, </span><span class="s1">parallax</span><span class="s2">, False</span>
                                <span class="s1">)</span>

                                <span class="s1">self.fp.read(</span><span class="s4">4</span><span class="s1">)</span>
                                <span class="s1">camerainfo[</span><span class="s3">&quot;Category&quot;</span><span class="s1">] = self.fp.read(</span><span class="s4">2</span><span class="s1">)</span>

                                <span class="s1">makernote = {</span><span class="s4">0x1101</span><span class="s1">: dict(self._fixup_dict(camerainfo))}</span>
                        <span class="s1">self._ifds[tag] = makernote</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s0"># Interop</span>
                    <span class="s1">self._ifds[tag] = self._get_ifd_dict(tag_data)</span>
        <span class="s1">ifd = self._ifds.get(tag</span><span class="s2">, </span><span class="s1">{})</span>
        <span class="s2">if </span><span class="s1">tag == ExifTags.IFD.Exif </span><span class="s2">and </span><span class="s1">self._hidden_data:</span>
            <span class="s1">ifd = {</span>
                <span class="s1">k: v</span>
                <span class="s2">for </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">in </span><span class="s1">ifd.items()</span>
                <span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">(ExifTags.IFD.Interop</span><span class="s2">, </span><span class="s1">ExifTags.IFD.Makernote)</span>
            <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">ifd</span>

    <span class="s2">def </span><span class="s1">hide_offsets(self):</span>
        <span class="s2">for </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">(ExifTags.IFD.Exif</span><span class="s2">, </span><span class="s1">ExifTags.IFD.GPSInfo):</span>
            <span class="s2">if </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">self:</span>
                <span class="s1">self._hidden_data[tag] = self[tag]</span>
                <span class="s2">del </span><span class="s1">self[tag]</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">if </span><span class="s1">self._info </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s0"># Load all keys into self._data</span>
            <span class="s2">for </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">self._info.keys():</span>
                <span class="s1">self[tag]</span>

        <span class="s2">return </span><span class="s1">str(self._data)</span>

    <span class="s2">def </span><span class="s1">__len__(self):</span>
        <span class="s1">keys = set(self._data)</span>
        <span class="s2">if </span><span class="s1">self._info </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">keys.update(self._info)</span>
        <span class="s2">return </span><span class="s1">len(keys)</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">tag):</span>
        <span class="s2">if </span><span class="s1">self._info </span><span class="s2">is not None and </span><span class="s1">tag </span><span class="s2">not in </span><span class="s1">self._data </span><span class="s2">and </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">self._info:</span>
            <span class="s1">self._data[tag] = self._fixup(self._info[tag])</span>
            <span class="s2">del </span><span class="s1">self._info[tag]</span>
        <span class="s2">return </span><span class="s1">self._data[tag]</span>

    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">tag):</span>
        <span class="s2">return </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">self._data </span><span class="s2">or </span><span class="s1">(self._info </span><span class="s2">is not None and </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">self._info)</span>

    <span class="s2">def </span><span class="s1">__setitem__(self</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">self._info </span><span class="s2">is not None and </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">self._info:</span>
            <span class="s2">del </span><span class="s1">self._info[tag]</span>
        <span class="s1">self._data[tag] = value</span>

    <span class="s2">def </span><span class="s1">__delitem__(self</span><span class="s2">, </span><span class="s1">tag):</span>
        <span class="s2">if </span><span class="s1">self._info </span><span class="s2">is not None and </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">self._info:</span>
            <span class="s2">del </span><span class="s1">self._info[tag]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">del </span><span class="s1">self._data[tag]</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s1">keys = set(self._data)</span>
        <span class="s2">if </span><span class="s1">self._info </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">keys.update(self._info)</span>
        <span class="s2">return </span><span class="s1">iter(keys)</span>
</pre>
</body>
</html>