<html>
<head>
<title>shutil.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
shutil.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s0">#</span>
<span class="s0"># Copyright (C) 2012 The Python Software Foundation.</span>
<span class="s0"># See LICENSE.txt and CONTRIBUTORS.txt.</span>
<span class="s0">#</span>
<span class="s2">&quot;&quot;&quot;Utility functions for copying and archiving files and directory trees. 
 
XXX The functions here don't copy the resource fork or other metadata on Mac. 
 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">stat</span>
<span class="s3">from </span><span class="s1">os.path </span><span class="s3">import </span><span class="s1">abspath</span>
<span class="s3">import </span><span class="s1">fnmatch</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">collections.abc </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">tarfile</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">import </span><span class="s1">bz2</span>
    <span class="s1">_BZ2_SUPPORTED = </span><span class="s3">True</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s1">_BZ2_SUPPORTED = </span><span class="s3">False</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">pwd </span><span class="s3">import </span><span class="s1">getpwnam</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s1">getpwnam = </span><span class="s3">None</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">grp </span><span class="s3">import </span><span class="s1">getgrnam</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s1">getgrnam = </span><span class="s3">None</span>

<span class="s1">__all__ = [</span><span class="s4">&quot;copyfileobj&quot;</span><span class="s3">, </span><span class="s4">&quot;copyfile&quot;</span><span class="s3">, </span><span class="s4">&quot;copymode&quot;</span><span class="s3">, </span><span class="s4">&quot;copystat&quot;</span><span class="s3">, </span><span class="s4">&quot;copy&quot;</span><span class="s3">, </span><span class="s4">&quot;copy2&quot;</span><span class="s3">,</span>
           <span class="s4">&quot;copytree&quot;</span><span class="s3">, </span><span class="s4">&quot;move&quot;</span><span class="s3">, </span><span class="s4">&quot;rmtree&quot;</span><span class="s3">, </span><span class="s4">&quot;Error&quot;</span><span class="s3">, </span><span class="s4">&quot;SpecialFileError&quot;</span><span class="s3">,</span>
           <span class="s4">&quot;ExecError&quot;</span><span class="s3">, </span><span class="s4">&quot;make_archive&quot;</span><span class="s3">, </span><span class="s4">&quot;get_archive_formats&quot;</span><span class="s3">,</span>
           <span class="s4">&quot;register_archive_format&quot;</span><span class="s3">, </span><span class="s4">&quot;unregister_archive_format&quot;</span><span class="s3">,</span>
           <span class="s4">&quot;get_unpack_formats&quot;</span><span class="s3">, </span><span class="s4">&quot;register_unpack_format&quot;</span><span class="s3">,</span>
           <span class="s4">&quot;unregister_unpack_format&quot;</span><span class="s3">, </span><span class="s4">&quot;unpack_archive&quot;</span><span class="s3">, </span><span class="s4">&quot;ignore_patterns&quot;</span><span class="s1">]</span>

<span class="s3">class </span><span class="s1">Error(EnvironmentError):</span>
    <span class="s3">pass</span>

<span class="s3">class </span><span class="s1">SpecialFileError(EnvironmentError):</span>
    <span class="s2">&quot;&quot;&quot;Raised when trying to do a kind of operation (e.g. copying) which is 
    not supported on a special file (e.g. a named pipe)&quot;&quot;&quot;</span>

<span class="s3">class </span><span class="s1">ExecError(EnvironmentError):</span>
    <span class="s2">&quot;&quot;&quot;Raised when a command could not be executed&quot;&quot;&quot;</span>

<span class="s3">class </span><span class="s1">ReadError(EnvironmentError):</span>
    <span class="s2">&quot;&quot;&quot;Raised when an archive cannot be read&quot;&quot;&quot;</span>

<span class="s3">class </span><span class="s1">RegistryError(Exception):</span>
    <span class="s2">&quot;&quot;&quot;Raised when a registry operation with the archiving 
    and unpacking registries fails&quot;&quot;&quot;</span>


<span class="s3">try</span><span class="s1">:</span>
    <span class="s1">WindowsError</span>
<span class="s3">except </span><span class="s1">NameError:</span>
    <span class="s1">WindowsError = </span><span class="s3">None</span>

<span class="s3">def </span><span class="s1">copyfileobj(fsrc</span><span class="s3">, </span><span class="s1">fdst</span><span class="s3">, </span><span class="s1">length=</span><span class="s5">16</span><span class="s1">*</span><span class="s5">1024</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;copy data from file-like object fsrc to file-like object fdst&quot;&quot;&quot;</span>
    <span class="s3">while </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">buf = fsrc.read(length)</span>
        <span class="s3">if not </span><span class="s1">buf:</span>
            <span class="s3">break</span>
        <span class="s1">fdst.write(buf)</span>

<span class="s3">def </span><span class="s1">_samefile(src</span><span class="s3">, </span><span class="s1">dst):</span>
    <span class="s0"># Macintosh, Unix.</span>
    <span class="s3">if </span><span class="s1">hasattr(os.path</span><span class="s3">, </span><span class="s4">'samefile'</span><span class="s1">):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">os.path.samefile(src</span><span class="s3">, </span><span class="s1">dst)</span>
        <span class="s3">except </span><span class="s1">OSError:</span>
            <span class="s3">return False</span>

    <span class="s0"># All other platforms: check for same pathname.</span>
    <span class="s3">return </span><span class="s1">(os.path.normcase(os.path.abspath(src)) ==</span>
            <span class="s1">os.path.normcase(os.path.abspath(dst)))</span>

<span class="s3">def </span><span class="s1">copyfile(src</span><span class="s3">, </span><span class="s1">dst):</span>
    <span class="s2">&quot;&quot;&quot;Copy data from src to dst&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">_samefile(src</span><span class="s3">, </span><span class="s1">dst):</span>
        <span class="s3">raise </span><span class="s1">Error(</span><span class="s4">&quot;`%s` and `%s` are the same file&quot; </span><span class="s1">% (src</span><span class="s3">, </span><span class="s1">dst))</span>

    <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">[src</span><span class="s3">, </span><span class="s1">dst]:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">st = os.stat(fn)</span>
        <span class="s3">except </span><span class="s1">OSError:</span>
            <span class="s0"># File most likely does not exist</span>
            <span class="s3">pass</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># XXX What about other special files? (sockets, devices...)</span>
            <span class="s3">if </span><span class="s1">stat.S_ISFIFO(st.st_mode):</span>
                <span class="s3">raise </span><span class="s1">SpecialFileError(</span><span class="s4">&quot;`%s` is a named pipe&quot; </span><span class="s1">% fn)</span>

    <span class="s3">with </span><span class="s1">open(src</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">fsrc:</span>
        <span class="s3">with </span><span class="s1">open(dst</span><span class="s3">, </span><span class="s4">'wb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">fdst:</span>
            <span class="s1">copyfileobj(fsrc</span><span class="s3">, </span><span class="s1">fdst)</span>

<span class="s3">def </span><span class="s1">copymode(src</span><span class="s3">, </span><span class="s1">dst):</span>
    <span class="s2">&quot;&quot;&quot;Copy mode bits from src to dst&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">hasattr(os</span><span class="s3">, </span><span class="s4">'chmod'</span><span class="s1">):</span>
        <span class="s1">st = os.stat(src)</span>
        <span class="s1">mode = stat.S_IMODE(st.st_mode)</span>
        <span class="s1">os.chmod(dst</span><span class="s3">, </span><span class="s1">mode)</span>

<span class="s3">def </span><span class="s1">copystat(src</span><span class="s3">, </span><span class="s1">dst):</span>
    <span class="s2">&quot;&quot;&quot;Copy all stat info (mode bits, atime, mtime, flags) from src to dst&quot;&quot;&quot;</span>
    <span class="s1">st = os.stat(src)</span>
    <span class="s1">mode = stat.S_IMODE(st.st_mode)</span>
    <span class="s3">if </span><span class="s1">hasattr(os</span><span class="s3">, </span><span class="s4">'utime'</span><span class="s1">):</span>
        <span class="s1">os.utime(dst</span><span class="s3">, </span><span class="s1">(st.st_atime</span><span class="s3">, </span><span class="s1">st.st_mtime))</span>
    <span class="s3">if </span><span class="s1">hasattr(os</span><span class="s3">, </span><span class="s4">'chmod'</span><span class="s1">):</span>
        <span class="s1">os.chmod(dst</span><span class="s3">, </span><span class="s1">mode)</span>
    <span class="s3">if </span><span class="s1">hasattr(os</span><span class="s3">, </span><span class="s4">'chflags'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">hasattr(st</span><span class="s3">, </span><span class="s4">'st_flags'</span><span class="s1">):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">os.chflags(dst</span><span class="s3">, </span><span class="s1">st.st_flags)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">why:</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">hasattr(errno</span><span class="s3">, </span><span class="s4">'EOPNOTSUPP'</span><span class="s1">) </span><span class="s3">or</span>
                <span class="s1">why.errno != errno.EOPNOTSUPP):</span>
                <span class="s3">raise</span>

<span class="s3">def </span><span class="s1">copy(src</span><span class="s3">, </span><span class="s1">dst):</span>
    <span class="s2">&quot;&quot;&quot;Copy data and mode bits (&quot;cp src dst&quot;). 
 
    The destination may be a directory. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">os.path.isdir(dst):</span>
        <span class="s1">dst = os.path.join(dst</span><span class="s3">, </span><span class="s1">os.path.basename(src))</span>
    <span class="s1">copyfile(src</span><span class="s3">, </span><span class="s1">dst)</span>
    <span class="s1">copymode(src</span><span class="s3">, </span><span class="s1">dst)</span>

<span class="s3">def </span><span class="s1">copy2(src</span><span class="s3">, </span><span class="s1">dst):</span>
    <span class="s2">&quot;&quot;&quot;Copy data and all stat info (&quot;cp -p src dst&quot;). 
 
    The destination may be a directory. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">os.path.isdir(dst):</span>
        <span class="s1">dst = os.path.join(dst</span><span class="s3">, </span><span class="s1">os.path.basename(src))</span>
    <span class="s1">copyfile(src</span><span class="s3">, </span><span class="s1">dst)</span>
    <span class="s1">copystat(src</span><span class="s3">, </span><span class="s1">dst)</span>

<span class="s3">def </span><span class="s1">ignore_patterns(*patterns):</span>
    <span class="s2">&quot;&quot;&quot;Function that can be used as copytree() ignore parameter. 
 
    Patterns is a sequence of glob-style patterns 
    that are used to exclude files&quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">_ignore_patterns(path</span><span class="s3">, </span><span class="s1">names):</span>
        <span class="s1">ignored_names = []</span>
        <span class="s3">for </span><span class="s1">pattern </span><span class="s3">in </span><span class="s1">patterns:</span>
            <span class="s1">ignored_names.extend(fnmatch.filter(names</span><span class="s3">, </span><span class="s1">pattern))</span>
        <span class="s3">return </span><span class="s1">set(ignored_names)</span>
    <span class="s3">return </span><span class="s1">_ignore_patterns</span>

<span class="s3">def </span><span class="s1">copytree(src</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">, </span><span class="s1">symlinks=</span><span class="s3">False, </span><span class="s1">ignore=</span><span class="s3">None, </span><span class="s1">copy_function=copy2</span><span class="s3">,</span>
             <span class="s1">ignore_dangling_symlinks=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Recursively copy a directory tree. 
 
    The destination directory must not already exist. 
    If exception(s) occur, an Error is raised with a list of reasons. 
 
    If the optional symlinks flag is true, symbolic links in the 
    source tree result in symbolic links in the destination tree; if 
    it is false, the contents of the files pointed to by symbolic 
    links are copied. If the file pointed by the symlink doesn't 
    exist, an exception will be added in the list of errors raised in 
    an Error exception at the end of the copy process. 
 
    You can set the optional ignore_dangling_symlinks flag to true if you 
    want to silence this exception. Notice that this has no effect on 
    platforms that don't support os.symlink. 
 
    The optional ignore argument is a callable. If given, it 
    is called with the `src` parameter, which is the directory 
    being visited by copytree(), and `names` which is the list of 
    `src` contents, as returned by os.listdir(): 
 
        callable(src, names) -&gt; ignored_names 
 
    Since copytree() is called recursively, the callable will be 
    called once for each directory that is copied. It returns a 
    list of names relative to the `src` directory that should 
    not be copied. 
 
    The optional copy_function argument is a callable that will be used 
    to copy each file. It will be called with the source path and the 
    destination path as arguments. By default, copy2() is used, but any 
    function that supports the same signature (like copy()) can be used. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">names = os.listdir(src)</span>
    <span class="s3">if </span><span class="s1">ignore </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">ignored_names = ignore(src</span><span class="s3">, </span><span class="s1">names)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">ignored_names = set()</span>

    <span class="s1">os.makedirs(dst)</span>
    <span class="s1">errors = []</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">names:</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">ignored_names:</span>
            <span class="s3">continue</span>
        <span class="s1">srcname = os.path.join(src</span><span class="s3">, </span><span class="s1">name)</span>
        <span class="s1">dstname = os.path.join(dst</span><span class="s3">, </span><span class="s1">name)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">os.path.islink(srcname):</span>
                <span class="s1">linkto = os.readlink(srcname)</span>
                <span class="s3">if </span><span class="s1">symlinks:</span>
                    <span class="s1">os.symlink(linkto</span><span class="s3">, </span><span class="s1">dstname)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s0"># ignore dangling symlink if the flag is on</span>
                    <span class="s3">if not </span><span class="s1">os.path.exists(linkto) </span><span class="s3">and </span><span class="s1">ignore_dangling_symlinks:</span>
                        <span class="s3">continue</span>
                    <span class="s0"># otherwise let the copy occurs. copy2 will raise an error</span>
                    <span class="s1">copy_function(srcname</span><span class="s3">, </span><span class="s1">dstname)</span>
            <span class="s3">elif </span><span class="s1">os.path.isdir(srcname):</span>
                <span class="s1">copytree(srcname</span><span class="s3">, </span><span class="s1">dstname</span><span class="s3">, </span><span class="s1">symlinks</span><span class="s3">, </span><span class="s1">ignore</span><span class="s3">, </span><span class="s1">copy_function)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># Will raise a SpecialFileError for unsupported file types</span>
                <span class="s1">copy_function(srcname</span><span class="s3">, </span><span class="s1">dstname)</span>
        <span class="s0"># catch the Error from the recursive copytree so that we can</span>
        <span class="s0"># continue with other files</span>
        <span class="s3">except </span><span class="s1">Error </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s1">errors.extend(err.args[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s3">except </span><span class="s1">EnvironmentError </span><span class="s3">as </span><span class="s1">why:</span>
            <span class="s1">errors.append((srcname</span><span class="s3">, </span><span class="s1">dstname</span><span class="s3">, </span><span class="s1">str(why)))</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">copystat(src</span><span class="s3">, </span><span class="s1">dst)</span>
    <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">why:</span>
        <span class="s3">if </span><span class="s1">WindowsError </span><span class="s3">is not None and </span><span class="s1">isinstance(why</span><span class="s3">, </span><span class="s1">WindowsError):</span>
            <span class="s0"># Copying file access times may fail on Windows</span>
            <span class="s3">pass</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">errors.extend((src</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">, </span><span class="s1">str(why)))</span>
    <span class="s3">if </span><span class="s1">errors:</span>
        <span class="s3">raise </span><span class="s1">Error(errors)</span>

<span class="s3">def </span><span class="s1">rmtree(path</span><span class="s3">, </span><span class="s1">ignore_errors=</span><span class="s3">False, </span><span class="s1">onerror=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Recursively delete a directory tree. 
 
    If ignore_errors is set, errors are ignored; otherwise, if onerror 
    is set, it is called to handle the error with arguments (func, 
    path, exc_info) where func is os.listdir, os.remove, or os.rmdir; 
    path is the argument to that function that caused it to fail; and 
    exc_info is a tuple returned by sys.exc_info().  If ignore_errors 
    is false and onerror is None, an exception is raised. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">ignore_errors:</span>
        <span class="s3">def </span><span class="s1">onerror(*args):</span>
            <span class="s3">pass</span>
    <span class="s3">elif </span><span class="s1">onerror </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">def </span><span class="s1">onerror(*args):</span>
            <span class="s3">raise</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">os.path.islink(path):</span>
            <span class="s0"># symlinks to directories are forbidden, see bug #1669</span>
            <span class="s3">raise </span><span class="s1">OSError(</span><span class="s4">&quot;Cannot call rmtree on a symbolic link&quot;</span><span class="s1">)</span>
    <span class="s3">except </span><span class="s1">OSError:</span>
        <span class="s1">onerror(os.path.islink</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">sys.exc_info())</span>
        <span class="s0"># can't continue even if onerror hook returns</span>
        <span class="s3">return</span>
    <span class="s1">names = []</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">names = os.listdir(path)</span>
    <span class="s3">except </span><span class="s1">os.error:</span>
        <span class="s1">onerror(os.listdir</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">sys.exc_info())</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">names:</span>
        <span class="s1">fullname = os.path.join(path</span><span class="s3">, </span><span class="s1">name)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">mode = os.lstat(fullname).st_mode</span>
        <span class="s3">except </span><span class="s1">os.error:</span>
            <span class="s1">mode = </span><span class="s5">0</span>
        <span class="s3">if </span><span class="s1">stat.S_ISDIR(mode):</span>
            <span class="s1">rmtree(fullname</span><span class="s3">, </span><span class="s1">ignore_errors</span><span class="s3">, </span><span class="s1">onerror)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">os.remove(fullname)</span>
            <span class="s3">except </span><span class="s1">os.error:</span>
                <span class="s1">onerror(os.remove</span><span class="s3">, </span><span class="s1">fullname</span><span class="s3">, </span><span class="s1">sys.exc_info())</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">os.rmdir(path)</span>
    <span class="s3">except </span><span class="s1">os.error:</span>
        <span class="s1">onerror(os.rmdir</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">sys.exc_info())</span>


<span class="s3">def </span><span class="s1">_basename(path):</span>
    <span class="s0"># A basename() variant which first strips the trailing slash, if present.</span>
    <span class="s0"># Thus we always get the last component of the path, even for directories.</span>
    <span class="s3">return </span><span class="s1">os.path.basename(path.rstrip(os.path.sep))</span>

<span class="s3">def </span><span class="s1">move(src</span><span class="s3">, </span><span class="s1">dst):</span>
    <span class="s2">&quot;&quot;&quot;Recursively move a file or directory to another location. This is 
    similar to the Unix &quot;mv&quot; command. 
 
    If the destination is a directory or a symlink to a directory, the source 
    is moved inside the directory. The destination path must not already 
    exist. 
 
    If the destination already exists but is not a directory, it may be 
    overwritten depending on os.rename() semantics. 
 
    If the destination is on our current filesystem, then rename() is used. 
    Otherwise, src is copied to the destination and then removed. 
    A lot more could be done here...  A look at a mv.c shows a lot of 
    the issues this implementation glosses over. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">real_dst = dst</span>
    <span class="s3">if </span><span class="s1">os.path.isdir(dst):</span>
        <span class="s3">if </span><span class="s1">_samefile(src</span><span class="s3">, </span><span class="s1">dst):</span>
            <span class="s0"># We might be on a case insensitive filesystem,</span>
            <span class="s0"># perform the rename anyway.</span>
            <span class="s1">os.rename(src</span><span class="s3">, </span><span class="s1">dst)</span>
            <span class="s3">return</span>

        <span class="s1">real_dst = os.path.join(dst</span><span class="s3">, </span><span class="s1">_basename(src))</span>
        <span class="s3">if </span><span class="s1">os.path.exists(real_dst):</span>
            <span class="s3">raise </span><span class="s1">Error(</span><span class="s4">&quot;Destination path '%s' already exists&quot; </span><span class="s1">% real_dst)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">os.rename(src</span><span class="s3">, </span><span class="s1">real_dst)</span>
    <span class="s3">except </span><span class="s1">OSError:</span>
        <span class="s3">if </span><span class="s1">os.path.isdir(src):</span>
            <span class="s3">if </span><span class="s1">_destinsrc(src</span><span class="s3">, </span><span class="s1">dst):</span>
                <span class="s3">raise </span><span class="s1">Error(</span><span class="s4">&quot;Cannot move a directory '%s' into itself '%s'.&quot; </span><span class="s1">% (src</span><span class="s3">, </span><span class="s1">dst))</span>
            <span class="s1">copytree(src</span><span class="s3">, </span><span class="s1">real_dst</span><span class="s3">, </span><span class="s1">symlinks=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">rmtree(src)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">copy2(src</span><span class="s3">, </span><span class="s1">real_dst)</span>
            <span class="s1">os.unlink(src)</span>

<span class="s3">def </span><span class="s1">_destinsrc(src</span><span class="s3">, </span><span class="s1">dst):</span>
    <span class="s1">src = abspath(src)</span>
    <span class="s1">dst = abspath(dst)</span>
    <span class="s3">if not </span><span class="s1">src.endswith(os.path.sep):</span>
        <span class="s1">src += os.path.sep</span>
    <span class="s3">if not </span><span class="s1">dst.endswith(os.path.sep):</span>
        <span class="s1">dst += os.path.sep</span>
    <span class="s3">return </span><span class="s1">dst.startswith(src)</span>

<span class="s3">def </span><span class="s1">_get_gid(name):</span>
    <span class="s2">&quot;&quot;&quot;Returns a gid, given a group name.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">getgrnam </span><span class="s3">is None or </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">return None</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">result = getgrnam(name)</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s1">result = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">result </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">result[</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s3">return None</span>

<span class="s3">def </span><span class="s1">_get_uid(name):</span>
    <span class="s2">&quot;&quot;&quot;Returns an uid, given a user name.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">getpwnam </span><span class="s3">is None or </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">return None</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">result = getpwnam(name)</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s1">result = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">result </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">result[</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s3">return None</span>

<span class="s3">def </span><span class="s1">_make_tarball(base_name</span><span class="s3">, </span><span class="s1">base_dir</span><span class="s3">, </span><span class="s1">compress=</span><span class="s4">&quot;gzip&quot;</span><span class="s3">, </span><span class="s1">verbose=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dry_run=</span><span class="s5">0</span><span class="s3">,</span>
                  <span class="s1">owner=</span><span class="s3">None, </span><span class="s1">group=</span><span class="s3">None, </span><span class="s1">logger=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Create a (possibly compressed) tar file from all the files under 
    'base_dir'. 
 
    'compress' must be &quot;gzip&quot; (the default), &quot;bzip2&quot;, or None. 
 
    'owner' and 'group' can be used to define an owner and a group for the 
    archive that is being built. If not provided, the current owner and group 
    will be used. 
 
    The output tar file will be named 'base_name' +  &quot;.tar&quot;, possibly plus 
    the appropriate compression extension (&quot;.gz&quot;, or &quot;.bz2&quot;). 
 
    Returns the output filename. 
    &quot;&quot;&quot;</span>
    <span class="s1">tar_compression = {</span><span class="s4">'gzip'</span><span class="s1">: </span><span class="s4">'gz'</span><span class="s3">, None</span><span class="s1">: </span><span class="s4">''</span><span class="s1">}</span>
    <span class="s1">compress_ext = {</span><span class="s4">'gzip'</span><span class="s1">: </span><span class="s4">'.gz'</span><span class="s1">}</span>

    <span class="s3">if </span><span class="s1">_BZ2_SUPPORTED:</span>
        <span class="s1">tar_compression[</span><span class="s4">'bzip2'</span><span class="s1">] = </span><span class="s4">'bz2'</span>
        <span class="s1">compress_ext[</span><span class="s4">'bzip2'</span><span class="s1">] = </span><span class="s4">'.bz2'</span>

    <span class="s0"># flags for compression program, each element of list will be an argument</span>
    <span class="s3">if </span><span class="s1">compress </span><span class="s3">is not None and </span><span class="s1">compress </span><span class="s3">not in </span><span class="s1">compress_ext:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;bad value for 'compress', or compression format not &quot;</span>
                         <span class="s4">&quot;supported : {0}&quot;</span><span class="s1">.format(compress))</span>

    <span class="s1">archive_name = base_name + </span><span class="s4">'.tar' </span><span class="s1">+ compress_ext.get(compress</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
    <span class="s1">archive_dir = os.path.dirname(archive_name)</span>

    <span class="s3">if not </span><span class="s1">os.path.exists(archive_dir):</span>
        <span class="s3">if </span><span class="s1">logger </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;creating %s&quot;</span><span class="s3">, </span><span class="s1">archive_dir)</span>
        <span class="s3">if not </span><span class="s1">dry_run:</span>
            <span class="s1">os.makedirs(archive_dir)</span>

    <span class="s0"># creating the tarball</span>
    <span class="s3">if </span><span class="s1">logger </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">logger.info(</span><span class="s4">'Creating tar archive'</span><span class="s1">)</span>

    <span class="s1">uid = _get_uid(owner)</span>
    <span class="s1">gid = _get_gid(group)</span>

    <span class="s3">def </span><span class="s1">_set_uid_gid(tarinfo):</span>
        <span class="s3">if </span><span class="s1">gid </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">tarinfo.gid = gid</span>
            <span class="s1">tarinfo.gname = group</span>
        <span class="s3">if </span><span class="s1">uid </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">tarinfo.uid = uid</span>
            <span class="s1">tarinfo.uname = owner</span>
        <span class="s3">return </span><span class="s1">tarinfo</span>

    <span class="s3">if not </span><span class="s1">dry_run:</span>
        <span class="s1">tar = tarfile.open(archive_name</span><span class="s3">, </span><span class="s4">'w|%s' </span><span class="s1">% tar_compression[compress])</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">tar.add(base_dir</span><span class="s3">, </span><span class="s1">filter=_set_uid_gid)</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">tar.close()</span>

    <span class="s3">return </span><span class="s1">archive_name</span>

<span class="s3">def </span><span class="s1">_call_external_zip(base_dir</span><span class="s3">, </span><span class="s1">zip_filename</span><span class="s3">, </span><span class="s1">verbose=</span><span class="s3">False, </span><span class="s1">dry_run=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0"># XXX see if we want to keep an external call here</span>
    <span class="s3">if </span><span class="s1">verbose:</span>
        <span class="s1">zipoptions = </span><span class="s4">&quot;-r&quot;</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">zipoptions = </span><span class="s4">&quot;-rq&quot;</span>
    <span class="s3">from </span><span class="s1">distutils.errors </span><span class="s3">import </span><span class="s1">DistutilsExecError</span>
    <span class="s3">from </span><span class="s1">distutils.spawn </span><span class="s3">import </span><span class="s1">spawn</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">spawn([</span><span class="s4">&quot;zip&quot;</span><span class="s3">, </span><span class="s1">zipoptions</span><span class="s3">, </span><span class="s1">zip_filename</span><span class="s3">, </span><span class="s1">base_dir]</span><span class="s3">, </span><span class="s1">dry_run=dry_run)</span>
    <span class="s3">except </span><span class="s1">DistutilsExecError:</span>
        <span class="s0"># XXX really should distinguish between &quot;couldn't find</span>
        <span class="s0"># external 'zip' command&quot; and &quot;zip failed&quot;.</span>
        <span class="s3">raise </span><span class="s1">ExecError(</span><span class="s4">&quot;unable to create zip file '%s': &quot;</span>
            <span class="s4">&quot;could neither import the 'zipfile' module nor &quot;</span>
            <span class="s4">&quot;find a standalone zip utility&quot;</span><span class="s1">) % zip_filename</span>

<span class="s3">def </span><span class="s1">_make_zipfile(base_name</span><span class="s3">, </span><span class="s1">base_dir</span><span class="s3">, </span><span class="s1">verbose=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dry_run=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">logger=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Create a zip file from all the files under 'base_dir'. 
 
    The output zip file will be named 'base_name' + &quot;.zip&quot;.  Uses either the 
    &quot;zipfile&quot; Python module (if available) or the InfoZIP &quot;zip&quot; utility 
    (if installed and found on the default search path).  If neither tool is 
    available, raises ExecError.  Returns the name of the output zip 
    file. 
    &quot;&quot;&quot;</span>
    <span class="s1">zip_filename = base_name + </span><span class="s4">&quot;.zip&quot;</span>
    <span class="s1">archive_dir = os.path.dirname(base_name)</span>

    <span class="s3">if not </span><span class="s1">os.path.exists(archive_dir):</span>
        <span class="s3">if </span><span class="s1">logger </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;creating %s&quot;</span><span class="s3">, </span><span class="s1">archive_dir)</span>
        <span class="s3">if not </span><span class="s1">dry_run:</span>
            <span class="s1">os.makedirs(archive_dir)</span>

    <span class="s0"># If zipfile module is not available, try spawning an external 'zip'</span>
    <span class="s0"># command.</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">import </span><span class="s1">zipfile</span>
    <span class="s3">except </span><span class="s1">ImportError:</span>
        <span class="s1">zipfile = </span><span class="s3">None</span>

    <span class="s3">if </span><span class="s1">zipfile </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">_call_external_zip(base_dir</span><span class="s3">, </span><span class="s1">zip_filename</span><span class="s3">, </span><span class="s1">verbose</span><span class="s3">, </span><span class="s1">dry_run)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">logger </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;creating '%s' and adding '%s' to it&quot;</span><span class="s3">,</span>
                        <span class="s1">zip_filename</span><span class="s3">, </span><span class="s1">base_dir)</span>

        <span class="s3">if not </span><span class="s1">dry_run:</span>
            <span class="s1">zip = zipfile.ZipFile(zip_filename</span><span class="s3">, </span><span class="s4">&quot;w&quot;</span><span class="s3">,</span>
                                  <span class="s1">compression=zipfile.ZIP_DEFLATED)</span>

            <span class="s3">for </span><span class="s1">dirpath</span><span class="s3">, </span><span class="s1">dirnames</span><span class="s3">, </span><span class="s1">filenames </span><span class="s3">in </span><span class="s1">os.walk(base_dir):</span>
                <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">filenames:</span>
                    <span class="s1">path = os.path.normpath(os.path.join(dirpath</span><span class="s3">, </span><span class="s1">name))</span>
                    <span class="s3">if </span><span class="s1">os.path.isfile(path):</span>
                        <span class="s1">zip.write(path</span><span class="s3">, </span><span class="s1">path)</span>
                        <span class="s3">if </span><span class="s1">logger </span><span class="s3">is not None</span><span class="s1">:</span>
                            <span class="s1">logger.info(</span><span class="s4">&quot;adding '%s'&quot;</span><span class="s3">, </span><span class="s1">path)</span>
            <span class="s1">zip.close()</span>

    <span class="s3">return </span><span class="s1">zip_filename</span>

<span class="s1">_ARCHIVE_FORMATS = {</span>
    <span class="s4">'gztar'</span><span class="s1">: (_make_tarball</span><span class="s3">, </span><span class="s1">[(</span><span class="s4">'compress'</span><span class="s3">, </span><span class="s4">'gzip'</span><span class="s1">)]</span><span class="s3">, </span><span class="s4">&quot;gzip'ed tar-file&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s4">'bztar'</span><span class="s1">: (_make_tarball</span><span class="s3">, </span><span class="s1">[(</span><span class="s4">'compress'</span><span class="s3">, </span><span class="s4">'bzip2'</span><span class="s1">)]</span><span class="s3">, </span><span class="s4">&quot;bzip2'ed tar-file&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s4">'tar'</span><span class="s1">:   (_make_tarball</span><span class="s3">, </span><span class="s1">[(</span><span class="s4">'compress'</span><span class="s3">, None</span><span class="s1">)]</span><span class="s3">, </span><span class="s4">&quot;uncompressed tar file&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s4">'zip'</span><span class="s1">:   (_make_zipfile</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s4">&quot;ZIP file&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">}</span>

<span class="s3">if </span><span class="s1">_BZ2_SUPPORTED:</span>
    <span class="s1">_ARCHIVE_FORMATS[</span><span class="s4">'bztar'</span><span class="s1">] = (_make_tarball</span><span class="s3">, </span><span class="s1">[(</span><span class="s4">'compress'</span><span class="s3">, </span><span class="s4">'bzip2'</span><span class="s1">)]</span><span class="s3">,</span>
                                <span class="s4">&quot;bzip2'ed tar-file&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">get_archive_formats():</span>
    <span class="s2">&quot;&quot;&quot;Returns a list of supported formats for archiving and unarchiving. 
 
    Each element of the returned sequence is a tuple (name, description) 
    &quot;&quot;&quot;</span>
    <span class="s1">formats = [(name</span><span class="s3">, </span><span class="s1">registry[</span><span class="s5">2</span><span class="s1">]) </span><span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">registry </span><span class="s3">in</span>
               <span class="s1">_ARCHIVE_FORMATS.items()]</span>
    <span class="s1">formats.sort()</span>
    <span class="s3">return </span><span class="s1">formats</span>

<span class="s3">def </span><span class="s1">register_archive_format(name</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">extra_args=</span><span class="s3">None, </span><span class="s1">description=</span><span class="s4">''</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Registers an archive format. 
 
    name is the name of the format. function is the callable that will be 
    used to create archives. If provided, extra_args is a sequence of 
    (name, value) tuples that will be passed as arguments to the callable. 
    description can be provided to describe the format, and will be returned 
    by the get_archive_formats() function. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">extra_args </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">extra_args = []</span>
    <span class="s3">if not </span><span class="s1">isinstance(function</span><span class="s3">, </span><span class="s1">Callable):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'The %s object is not callable' </span><span class="s1">% function)</span>
    <span class="s3">if not </span><span class="s1">isinstance(extra_args</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list)):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'extra_args needs to be a sequence'</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">extra_args:</span>
        <span class="s3">if not </span><span class="s1">isinstance(element</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list)) </span><span class="s3">or </span><span class="s1">len(element) !=</span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'extra_args elements are : (arg_name, value)'</span><span class="s1">)</span>

    <span class="s1">_ARCHIVE_FORMATS[name] = (function</span><span class="s3">, </span><span class="s1">extra_args</span><span class="s3">, </span><span class="s1">description)</span>

<span class="s3">def </span><span class="s1">unregister_archive_format(name):</span>
    <span class="s3">del </span><span class="s1">_ARCHIVE_FORMATS[name]</span>

<span class="s3">def </span><span class="s1">make_archive(base_name</span><span class="s3">, </span><span class="s1">format</span><span class="s3">, </span><span class="s1">root_dir=</span><span class="s3">None, </span><span class="s1">base_dir=</span><span class="s3">None, </span><span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
                 <span class="s1">dry_run=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">owner=</span><span class="s3">None, </span><span class="s1">group=</span><span class="s3">None, </span><span class="s1">logger=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Create an archive file (eg. zip or tar). 
 
    'base_name' is the name of the file to create, minus any format-specific 
    extension; 'format' is the archive format: one of &quot;zip&quot;, &quot;tar&quot;, &quot;bztar&quot; 
    or &quot;gztar&quot;. 
 
    'root_dir' is a directory that will be the root directory of the 
    archive; ie. we typically chdir into 'root_dir' before creating the 
    archive.  'base_dir' is the directory where we start archiving from; 
    ie. 'base_dir' will be the common prefix of all files and 
    directories in the archive.  'root_dir' and 'base_dir' both default 
    to the current directory.  Returns the name of the archive file. 
 
    'owner' and 'group' are used when creating a tar archive. By default, 
    uses the current owner and group. 
    &quot;&quot;&quot;</span>
    <span class="s1">save_cwd = os.getcwd()</span>
    <span class="s3">if </span><span class="s1">root_dir </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">logger </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">logger.debug(</span><span class="s4">&quot;changing into '%s'&quot;</span><span class="s3">, </span><span class="s1">root_dir)</span>
        <span class="s1">base_name = os.path.abspath(base_name)</span>
        <span class="s3">if not </span><span class="s1">dry_run:</span>
            <span class="s1">os.chdir(root_dir)</span>

    <span class="s3">if </span><span class="s1">base_dir </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">base_dir = os.curdir</span>

    <span class="s1">kwargs = {</span><span class="s4">'dry_run'</span><span class="s1">: dry_run</span><span class="s3">, </span><span class="s4">'logger'</span><span class="s1">: logger}</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">format_info = _ARCHIVE_FORMATS[format]</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;unknown archive format '%s'&quot; </span><span class="s1">% format)</span>

    <span class="s1">func = format_info[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">for </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">format_info[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s1">kwargs[arg] = val</span>

    <span class="s3">if </span><span class="s1">format != </span><span class="s4">'zip'</span><span class="s1">:</span>
        <span class="s1">kwargs[</span><span class="s4">'owner'</span><span class="s1">] = owner</span>
        <span class="s1">kwargs[</span><span class="s4">'group'</span><span class="s1">] = group</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">filename = func(base_name</span><span class="s3">, </span><span class="s1">base_dir</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s3">finally</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">root_dir </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">logger </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">logger.debug(</span><span class="s4">&quot;changing back to '%s'&quot;</span><span class="s3">, </span><span class="s1">save_cwd)</span>
            <span class="s1">os.chdir(save_cwd)</span>

    <span class="s3">return </span><span class="s1">filename</span>


<span class="s3">def </span><span class="s1">get_unpack_formats():</span>
    <span class="s2">&quot;&quot;&quot;Returns a list of supported formats for unpacking. 
 
    Each element of the returned sequence is a tuple 
    (name, extensions, description) 
    &quot;&quot;&quot;</span>
    <span class="s1">formats = [(name</span><span class="s3">, </span><span class="s1">info[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">info[</span><span class="s5">3</span><span class="s1">]) </span><span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">info </span><span class="s3">in</span>
               <span class="s1">_UNPACK_FORMATS.items()]</span>
    <span class="s1">formats.sort()</span>
    <span class="s3">return </span><span class="s1">formats</span>

<span class="s3">def </span><span class="s1">_check_unpack_options(extensions</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">extra_args):</span>
    <span class="s2">&quot;&quot;&quot;Checks what gets registered as an unpacker.&quot;&quot;&quot;</span>
    <span class="s0"># first make sure no other unpacker is registered for this extension</span>
    <span class="s1">existing_extensions = {}</span>
    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">info </span><span class="s3">in </span><span class="s1">_UNPACK_FORMATS.items():</span>
        <span class="s3">for </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">info[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">existing_extensions[ext] = name</span>

    <span class="s3">for </span><span class="s1">extension </span><span class="s3">in </span><span class="s1">extensions:</span>
        <span class="s3">if </span><span class="s1">extension </span><span class="s3">in </span><span class="s1">existing_extensions:</span>
            <span class="s1">msg = </span><span class="s4">'%s is already registered for &quot;%s&quot;'</span>
            <span class="s3">raise </span><span class="s1">RegistryError(msg % (extension</span><span class="s3">,</span>
                                       <span class="s1">existing_extensions[extension]))</span>

    <span class="s3">if not </span><span class="s1">isinstance(function</span><span class="s3">, </span><span class="s1">Callable):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'The registered function must be a callable'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">register_unpack_format(name</span><span class="s3">, </span><span class="s1">extensions</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">extra_args=</span><span class="s3">None,</span>
                           <span class="s1">description=</span><span class="s4">''</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Registers an unpack format. 
 
    `name` is the name of the format. `extensions` is a list of extensions 
    corresponding to the format. 
 
    `function` is the callable that will be 
    used to unpack archives. The callable will receive archives to unpack. 
    If it's unable to handle an archive, it needs to raise a ReadError 
    exception. 
 
    If provided, `extra_args` is a sequence of 
    (name, value) tuples that will be passed as arguments to the callable. 
    description can be provided to describe the format, and will be returned 
    by the get_unpack_formats() function. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">extra_args </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">extra_args = []</span>
    <span class="s1">_check_unpack_options(extensions</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">extra_args)</span>
    <span class="s1">_UNPACK_FORMATS[name] = extensions</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">extra_args</span><span class="s3">, </span><span class="s1">description</span>

<span class="s3">def </span><span class="s1">unregister_unpack_format(name):</span>
    <span class="s2">&quot;&quot;&quot;Removes the pack format from the registry.&quot;&quot;&quot;</span>
    <span class="s3">del </span><span class="s1">_UNPACK_FORMATS[name]</span>

<span class="s3">def </span><span class="s1">_ensure_directory(path):</span>
    <span class="s2">&quot;&quot;&quot;Ensure that the parent directory of `path` exists&quot;&quot;&quot;</span>
    <span class="s1">dirname = os.path.dirname(path)</span>
    <span class="s3">if not </span><span class="s1">os.path.isdir(dirname):</span>
        <span class="s1">os.makedirs(dirname)</span>

<span class="s3">def </span><span class="s1">_unpack_zipfile(filename</span><span class="s3">, </span><span class="s1">extract_dir):</span>
    <span class="s2">&quot;&quot;&quot;Unpack zip `filename` to `extract_dir` 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">import </span><span class="s1">zipfile</span>
    <span class="s3">except </span><span class="s1">ImportError:</span>
        <span class="s3">raise </span><span class="s1">ReadError(</span><span class="s4">'zlib not supported, cannot unpack this archive.'</span><span class="s1">)</span>

    <span class="s3">if not </span><span class="s1">zipfile.is_zipfile(filename):</span>
        <span class="s3">raise </span><span class="s1">ReadError(</span><span class="s4">&quot;%s is not a zip file&quot; </span><span class="s1">% filename)</span>

    <span class="s1">zip = zipfile.ZipFile(filename)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">info </span><span class="s3">in </span><span class="s1">zip.infolist():</span>
            <span class="s1">name = info.filename</span>

            <span class="s0"># don't extract absolute paths or ones with .. in them</span>
            <span class="s3">if </span><span class="s1">name.startswith(</span><span class="s4">'/'</span><span class="s1">) </span><span class="s3">or </span><span class="s4">'..' </span><span class="s3">in </span><span class="s1">name:</span>
                <span class="s3">continue</span>

            <span class="s1">target = os.path.join(extract_dir</span><span class="s3">, </span><span class="s1">*name.split(</span><span class="s4">'/'</span><span class="s1">))</span>
            <span class="s3">if not </span><span class="s1">target:</span>
                <span class="s3">continue</span>

            <span class="s1">_ensure_directory(target)</span>
            <span class="s3">if not </span><span class="s1">name.endswith(</span><span class="s4">'/'</span><span class="s1">):</span>
                <span class="s0"># file</span>
                <span class="s1">data = zip.read(info.filename)</span>
                <span class="s1">f = open(target</span><span class="s3">, </span><span class="s4">'wb'</span><span class="s1">)</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">f.write(data)</span>
                <span class="s3">finally</span><span class="s1">:</span>
                    <span class="s1">f.close()</span>
                    <span class="s3">del </span><span class="s1">data</span>
    <span class="s3">finally</span><span class="s1">:</span>
        <span class="s1">zip.close()</span>

<span class="s3">def </span><span class="s1">_unpack_tarfile(filename</span><span class="s3">, </span><span class="s1">extract_dir):</span>
    <span class="s2">&quot;&quot;&quot;Unpack tar/tar.gz/tar.bz2 `filename` to `extract_dir` 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">tarobj = tarfile.open(filename)</span>
    <span class="s3">except </span><span class="s1">tarfile.TarError:</span>
        <span class="s3">raise </span><span class="s1">ReadError(</span>
            <span class="s4">&quot;%s is not a compressed or uncompressed tar file&quot; </span><span class="s1">% filename)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">tarobj.extractall(extract_dir)</span>
    <span class="s3">finally</span><span class="s1">:</span>
        <span class="s1">tarobj.close()</span>

<span class="s1">_UNPACK_FORMATS = {</span>
    <span class="s4">'gztar'</span><span class="s1">: ([</span><span class="s4">'.tar.gz'</span><span class="s3">, </span><span class="s4">'.tgz'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">_unpack_tarfile</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s4">&quot;gzip'ed tar-file&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s4">'tar'</span><span class="s1">:   ([</span><span class="s4">'.tar'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">_unpack_tarfile</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s4">&quot;uncompressed tar file&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s4">'zip'</span><span class="s1">:   ([</span><span class="s4">'.zip'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">_unpack_zipfile</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s4">&quot;ZIP file&quot;</span><span class="s1">)</span>
    <span class="s1">}</span>

<span class="s3">if </span><span class="s1">_BZ2_SUPPORTED:</span>
    <span class="s1">_UNPACK_FORMATS[</span><span class="s4">'bztar'</span><span class="s1">] = ([</span><span class="s4">'.bz2'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">_unpack_tarfile</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">,</span>
                                <span class="s4">&quot;bzip2'ed tar-file&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_find_unpack_format(filename):</span>
    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">info </span><span class="s3">in </span><span class="s1">_UNPACK_FORMATS.items():</span>
        <span class="s3">for </span><span class="s1">extension </span><span class="s3">in </span><span class="s1">info[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">filename.endswith(extension):</span>
                <span class="s3">return </span><span class="s1">name</span>
    <span class="s3">return None</span>

<span class="s3">def </span><span class="s1">unpack_archive(filename</span><span class="s3">, </span><span class="s1">extract_dir=</span><span class="s3">None, </span><span class="s1">format=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Unpack an archive. 
 
    `filename` is the name of the archive. 
 
    `extract_dir` is the name of the target directory, where the archive 
    is unpacked. If not provided, the current working directory is used. 
 
    `format` is the archive format: one of &quot;zip&quot;, &quot;tar&quot;, or &quot;gztar&quot;. Or any 
    other registered format. If not provided, unpack_archive will use the 
    filename extension and see if an unpacker was registered for that 
    extension. 
 
    In case none is found, a ValueError is raised. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">extract_dir </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">extract_dir = os.getcwd()</span>

    <span class="s3">if </span><span class="s1">format </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">format_info = _UNPACK_FORMATS[format]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unknown unpack format '{0}'&quot;</span><span class="s1">.format(format))</span>

        <span class="s1">func = format_info[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">func(filename</span><span class="s3">, </span><span class="s1">extract_dir</span><span class="s3">, </span><span class="s1">**dict(format_info[</span><span class="s5">2</span><span class="s1">]))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># we need to look at the registered unpackers supported extensions</span>
        <span class="s1">format = _find_unpack_format(filename)</span>
        <span class="s3">if </span><span class="s1">format </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ReadError(</span><span class="s4">&quot;Unknown archive format '{0}'&quot;</span><span class="s1">.format(filename))</span>

        <span class="s1">func = _UNPACK_FORMATS[format][</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">kwargs = dict(_UNPACK_FORMATS[format][</span><span class="s5">2</span><span class="s1">])</span>
        <span class="s1">func(filename</span><span class="s3">, </span><span class="s1">extract_dir</span><span class="s3">, </span><span class="s1">**kwargs)</span>
</pre>
</body>
</html>