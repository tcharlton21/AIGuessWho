<html>
<head>
<title>_parser.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_parser.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">string</span>
<span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">MappingProxyType</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">Dict</span><span class="s0">,</span>
    <span class="s1">FrozenSet</span><span class="s0">,</span>
    <span class="s1">Iterable</span><span class="s0">,</span>
    <span class="s1">Optional</span><span class="s0">,</span>
    <span class="s1">TextIO</span><span class="s0">,</span>
    <span class="s1">Tuple</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pip._vendor.tomli._re </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">RE_BIN</span><span class="s0">,</span>
    <span class="s1">RE_DATETIME</span><span class="s0">,</span>
    <span class="s1">RE_HEX</span><span class="s0">,</span>
    <span class="s1">RE_LOCALTIME</span><span class="s0">,</span>
    <span class="s1">RE_NUMBER</span><span class="s0">,</span>
    <span class="s1">RE_OCT</span><span class="s0">,</span>
    <span class="s1">match_to_datetime</span><span class="s0">,</span>
    <span class="s1">match_to_localtime</span><span class="s0">,</span>
    <span class="s1">match_to_number</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">re </span><span class="s0">import </span><span class="s1">Pattern</span>


<span class="s1">ASCII_CTRL = frozenset(chr(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">32</span><span class="s1">)) | frozenset(chr(</span><span class="s2">127</span><span class="s1">))</span>

<span class="s3"># Neither of these sets include quotation mark or backslash. They are</span>
<span class="s3"># currently handled as separate cases in the parser functions.</span>
<span class="s1">ILLEGAL_BASIC_STR_CHARS = ASCII_CTRL - frozenset(</span><span class="s4">&quot;</span><span class="s0">\t</span><span class="s4">&quot;</span><span class="s1">)</span>
<span class="s1">ILLEGAL_MULTILINE_BASIC_STR_CHARS = ASCII_CTRL - frozenset(</span><span class="s4">&quot;</span><span class="s0">\t\n\r</span><span class="s4">&quot;</span><span class="s1">)</span>

<span class="s1">ILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS</span>
<span class="s1">ILLEGAL_MULTILINE_LITERAL_STR_CHARS = ASCII_CTRL - frozenset(</span><span class="s4">&quot;</span><span class="s0">\t\n</span><span class="s4">&quot;</span><span class="s1">)</span>

<span class="s1">ILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS</span>

<span class="s1">TOML_WS = frozenset(</span><span class="s4">&quot; </span><span class="s0">\t</span><span class="s4">&quot;</span><span class="s1">)</span>
<span class="s1">TOML_WS_AND_NEWLINE = TOML_WS | frozenset(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
<span class="s1">BARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + </span><span class="s4">&quot;-_&quot;</span><span class="s1">)</span>
<span class="s1">KEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(</span><span class="s4">&quot;</span><span class="s0">\&quot;</span><span class="s4">'&quot;</span><span class="s1">)</span>

<span class="s1">BASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(</span>
    <span class="s1">{</span>
        <span class="s4">&quot;</span><span class="s0">\\</span><span class="s4">b&quot;</span><span class="s1">: </span><span class="s4">&quot;</span><span class="s0">\u0008</span><span class="s4">&quot;</span><span class="s0">,  </span><span class="s3"># backspace</span>
        <span class="s4">&quot;</span><span class="s0">\\</span><span class="s4">t&quot;</span><span class="s1">: </span><span class="s4">&quot;</span><span class="s0">\u0009</span><span class="s4">&quot;</span><span class="s0">,  </span><span class="s3"># tab</span>
        <span class="s4">&quot;</span><span class="s0">\\</span><span class="s4">n&quot;</span><span class="s1">: </span><span class="s4">&quot;</span><span class="s0">\u000A</span><span class="s4">&quot;</span><span class="s0">,  </span><span class="s3"># linefeed</span>
        <span class="s4">&quot;</span><span class="s0">\\</span><span class="s4">f&quot;</span><span class="s1">: </span><span class="s4">&quot;</span><span class="s0">\u000C</span><span class="s4">&quot;</span><span class="s0">,  </span><span class="s3"># form feed</span>
        <span class="s4">&quot;</span><span class="s0">\\</span><span class="s4">r&quot;</span><span class="s1">: </span><span class="s4">&quot;</span><span class="s0">\u000D</span><span class="s4">&quot;</span><span class="s0">,  </span><span class="s3"># carriage return</span>
        <span class="s4">'</span><span class="s0">\\</span><span class="s4">&quot;'</span><span class="s1">: </span><span class="s4">&quot;</span><span class="s0">\u0022</span><span class="s4">&quot;</span><span class="s0">,  </span><span class="s3"># quote</span>
        <span class="s4">&quot;</span><span class="s0">\\\\</span><span class="s4">&quot;</span><span class="s1">: </span><span class="s4">&quot;</span><span class="s0">\u005C</span><span class="s4">&quot;</span><span class="s0">,  </span><span class="s3"># backslash</span>
    <span class="s1">}</span>
<span class="s1">)</span>

<span class="s3"># Type annotations</span>
<span class="s1">ParseFloat = Callable[[str]</span><span class="s0">, </span><span class="s1">Any]</span>
<span class="s1">Key = Tuple[str</span><span class="s0">, </span><span class="s1">...]</span>
<span class="s1">Pos = int</span>


<span class="s0">class </span><span class="s1">TOMLDecodeError(ValueError):</span>
    <span class="s5">&quot;&quot;&quot;An error raised if a document is not valid TOML.&quot;&quot;&quot;</span>


<span class="s0">def </span><span class="s1">load(fp: TextIO</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">parse_float: ParseFloat = float) -&gt; Dict[str</span><span class="s0">, </span><span class="s1">Any]:</span>
    <span class="s5">&quot;&quot;&quot;Parse TOML from a file object.&quot;&quot;&quot;</span>
    <span class="s1">s = fp.read()</span>
    <span class="s0">return </span><span class="s1">loads(s</span><span class="s0">, </span><span class="s1">parse_float=parse_float)</span>


<span class="s0">def </span><span class="s1">loads(s: str</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">parse_float: ParseFloat = float) -&gt; Dict[str</span><span class="s0">, </span><span class="s1">Any]:  </span><span class="s3"># noqa: C901</span>
    <span class="s5">&quot;&quot;&quot;Parse TOML from a string.&quot;&quot;&quot;</span>

    <span class="s3"># The spec allows converting &quot;\r\n&quot; to &quot;\n&quot;, even in string</span>
    <span class="s3"># literals. Let's do so to simplify parsing.</span>
    <span class="s1">src = s.replace(</span><span class="s4">&quot;</span><span class="s0">\r\n</span><span class="s4">&quot;</span><span class="s0">, </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">pos = </span><span class="s2">0</span>
    <span class="s1">state = State()</span>

    <span class="s3"># Parse one statement at a time</span>
    <span class="s3"># (typically means one line in TOML source)</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s3"># 1. Skip line leading whitespace</span>
        <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>

        <span class="s3"># 2. Parse rules. Expect one of the following:</span>
        <span class="s3">#    - end of file</span>
        <span class="s3">#    - end of line</span>
        <span class="s3">#    - comment</span>
        <span class="s3">#    - key/value pair</span>
        <span class="s3">#    - append dict to list (and move to its namespace)</span>
        <span class="s3">#    - create dict (and move to its namespace)</span>
        <span class="s3"># Skip trailing whitespace when applicable.</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">char = src[pos]</span>
        <span class="s0">except </span><span class="s1">IndexError:</span>
            <span class="s0">break</span>
        <span class="s0">if </span><span class="s1">char == </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">:</span>
            <span class="s1">pos += </span><span class="s2">1</span>
            <span class="s0">continue</span>
        <span class="s0">if </span><span class="s1">char </span><span class="s0">in </span><span class="s1">KEY_INITIAL_CHARS:</span>
            <span class="s1">pos = key_value_rule(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">parse_float)</span>
            <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>
        <span class="s0">elif </span><span class="s1">char == </span><span class="s4">&quot;[&quot;</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">second_char: Optional[str] = src[pos + </span><span class="s2">1</span><span class="s1">]</span>
            <span class="s0">except </span><span class="s1">IndexError:</span>
                <span class="s1">second_char = </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">second_char == </span><span class="s4">&quot;[&quot;</span><span class="s1">:</span>
                <span class="s1">pos = create_list_rule(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">pos = create_dict_rule(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state)</span>
            <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>
        <span class="s0">elif </span><span class="s1">char != </span><span class="s4">&quot;#&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Invalid statement&quot;</span><span class="s1">)</span>

        <span class="s3"># 3. Skip comment</span>
        <span class="s1">pos = skip_comment(src</span><span class="s0">, </span><span class="s1">pos)</span>

        <span class="s3"># 4. Expect end of line or end of file</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">char = src[pos]</span>
        <span class="s0">except </span><span class="s1">IndexError:</span>
            <span class="s0">break</span>
        <span class="s0">if </span><span class="s1">char != </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">suffixed_err(</span>
                <span class="s1">src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Expected newline or end of document after a statement&quot;</span>
            <span class="s1">)</span>
        <span class="s1">pos += </span><span class="s2">1</span>

    <span class="s0">return </span><span class="s1">state.out.dict</span>


<span class="s0">class </span><span class="s1">State:</span>
    <span class="s0">def </span><span class="s1">__init__(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3"># Mutable, read-only</span>
        <span class="s1">self.out = NestedDict()</span>
        <span class="s1">self.flags = Flags()</span>

        <span class="s3"># Immutable, read and write</span>
        <span class="s1">self.header_namespace: Key = ()</span>


<span class="s0">class </span><span class="s1">Flags:</span>
    <span class="s5">&quot;&quot;&quot;Flags that map to parsed keys/namespaces.&quot;&quot;&quot;</span>

    <span class="s3"># Marks an immutable namespace (inline array or inline table).</span>
    <span class="s1">FROZEN = </span><span class="s2">0</span>
    <span class="s3"># Marks a nest that has been explicitly created and can no longer</span>
    <span class="s3"># be opened using the &quot;[table]&quot; syntax.</span>
    <span class="s1">EXPLICIT_NEST = </span><span class="s2">1</span>

    <span class="s0">def </span><span class="s1">__init__(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._flags: Dict[str</span><span class="s0">, </span><span class="s1">dict] = {}</span>

    <span class="s0">def </span><span class="s1">unset_all(self</span><span class="s0">, </span><span class="s1">key: Key) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">cont = self._flags</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">key[:-</span><span class="s2">1</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">cont:</span>
                <span class="s0">return</span>
            <span class="s1">cont = cont[k][</span><span class="s4">&quot;nested&quot;</span><span class="s1">]</span>
        <span class="s1">cont.pop(key[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">set_for_relative_key(self</span><span class="s0">, </span><span class="s1">head_key: Key</span><span class="s0">, </span><span class="s1">rel_key: Key</span><span class="s0">, </span><span class="s1">flag: int) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">cont = self._flags</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">head_key:</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">cont:</span>
                <span class="s1">cont[k] = {</span><span class="s4">&quot;flags&quot;</span><span class="s1">: set()</span><span class="s0">, </span><span class="s4">&quot;recursive_flags&quot;</span><span class="s1">: set()</span><span class="s0">, </span><span class="s4">&quot;nested&quot;</span><span class="s1">: {}}</span>
            <span class="s1">cont = cont[k][</span><span class="s4">&quot;nested&quot;</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">rel_key:</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">cont:</span>
                <span class="s1">cont[k][</span><span class="s4">&quot;flags&quot;</span><span class="s1">].add(flag)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">cont[k] = {</span><span class="s4">&quot;flags&quot;</span><span class="s1">: {flag}</span><span class="s0">, </span><span class="s4">&quot;recursive_flags&quot;</span><span class="s1">: set()</span><span class="s0">, </span><span class="s4">&quot;nested&quot;</span><span class="s1">: {}}</span>
            <span class="s1">cont = cont[k][</span><span class="s4">&quot;nested&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">set(self</span><span class="s0">, </span><span class="s1">key: Key</span><span class="s0">, </span><span class="s1">flag: int</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">recursive: bool) -&gt; </span><span class="s0">None</span><span class="s1">:  </span><span class="s3"># noqa: A003</span>
        <span class="s1">cont = self._flags</span>
        <span class="s1">key_parent</span><span class="s0">, </span><span class="s1">key_stem = key[:-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">key[-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">key_parent:</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">cont:</span>
                <span class="s1">cont[k] = {</span><span class="s4">&quot;flags&quot;</span><span class="s1">: set()</span><span class="s0">, </span><span class="s4">&quot;recursive_flags&quot;</span><span class="s1">: set()</span><span class="s0">, </span><span class="s4">&quot;nested&quot;</span><span class="s1">: {}}</span>
            <span class="s1">cont = cont[k][</span><span class="s4">&quot;nested&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">key_stem </span><span class="s0">not in </span><span class="s1">cont:</span>
            <span class="s1">cont[key_stem] = {</span><span class="s4">&quot;flags&quot;</span><span class="s1">: set()</span><span class="s0">, </span><span class="s4">&quot;recursive_flags&quot;</span><span class="s1">: set()</span><span class="s0">, </span><span class="s4">&quot;nested&quot;</span><span class="s1">: {}}</span>
        <span class="s1">cont[key_stem][</span><span class="s4">&quot;recursive_flags&quot; </span><span class="s0">if </span><span class="s1">recursive </span><span class="s0">else </span><span class="s4">&quot;flags&quot;</span><span class="s1">].add(flag)</span>

    <span class="s0">def </span><span class="s1">is_(self</span><span class="s0">, </span><span class="s1">key: Key</span><span class="s0">, </span><span class="s1">flag: int) -&gt; bool:</span>
        <span class="s0">if not </span><span class="s1">key:</span>
            <span class="s0">return False  </span><span class="s3"># document root has no flags</span>
        <span class="s1">cont = self._flags</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">key[:-</span><span class="s2">1</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">cont:</span>
                <span class="s0">return False</span>
            <span class="s1">inner_cont = cont[k]</span>
            <span class="s0">if </span><span class="s1">flag </span><span class="s0">in </span><span class="s1">inner_cont[</span><span class="s4">&quot;recursive_flags&quot;</span><span class="s1">]:</span>
                <span class="s0">return True</span>
            <span class="s1">cont = inner_cont[</span><span class="s4">&quot;nested&quot;</span><span class="s1">]</span>
        <span class="s1">key_stem = key[-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">key_stem </span><span class="s0">in </span><span class="s1">cont:</span>
            <span class="s1">cont = cont[key_stem]</span>
            <span class="s0">return </span><span class="s1">flag </span><span class="s0">in </span><span class="s1">cont[</span><span class="s4">&quot;flags&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s1">flag </span><span class="s0">in </span><span class="s1">cont[</span><span class="s4">&quot;recursive_flags&quot;</span><span class="s1">]</span>
        <span class="s0">return False</span>


<span class="s0">class </span><span class="s1">NestedDict:</span>
    <span class="s0">def </span><span class="s1">__init__(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3"># The parsed content of the TOML document</span>
        <span class="s1">self.dict: Dict[str</span><span class="s0">, </span><span class="s1">Any] = {}</span>

    <span class="s0">def </span><span class="s1">get_or_create_nest(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">key: Key</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">access_lists: bool = </span><span class="s0">True,</span>
    <span class="s1">) -&gt; dict:</span>
        <span class="s1">cont: Any = self.dict</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">key:</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">cont:</span>
                <span class="s1">cont[k] = {}</span>
            <span class="s1">cont = cont[k]</span>
            <span class="s0">if </span><span class="s1">access_lists </span><span class="s0">and </span><span class="s1">isinstance(cont</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s1">cont = cont[-</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s0">if not </span><span class="s1">isinstance(cont</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s4">&quot;There is no nest behind this key&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">cont</span>

    <span class="s0">def </span><span class="s1">append_nest_to_list(self</span><span class="s0">, </span><span class="s1">key: Key) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">cont = self.get_or_create_nest(key[:-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">last_key = key[-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">last_key </span><span class="s0">in </span><span class="s1">cont:</span>
            <span class="s1">list_ = cont[last_key]</span>
            <span class="s0">if not </span><span class="s1">isinstance(list_</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s4">&quot;An object other than list found behind this key&quot;</span><span class="s1">)</span>
            <span class="s1">list_.append({})</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">cont[last_key] = [{}]</span>


<span class="s0">def </span><span class="s1">skip_chars(src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">chars: Iterable[str]) -&gt; Pos:</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">while </span><span class="s1">src[pos] </span><span class="s0">in </span><span class="s1">chars:</span>
            <span class="s1">pos += </span><span class="s2">1</span>
    <span class="s0">except </span><span class="s1">IndexError:</span>
        <span class="s0">pass</span>
    <span class="s0">return </span><span class="s1">pos</span>


<span class="s0">def </span><span class="s1">skip_until(</span>
    <span class="s1">src: str</span><span class="s0">,</span>
    <span class="s1">pos: Pos</span><span class="s0">,</span>
    <span class="s1">expect: str</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">error_on: FrozenSet[str]</span><span class="s0">,</span>
    <span class="s1">error_on_eof: bool</span><span class="s0">,</span>
<span class="s1">) -&gt; Pos:</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">new_pos = src.index(expect</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s0">except </span><span class="s1">ValueError:</span>
        <span class="s1">new_pos = len(src)</span>
        <span class="s0">if </span><span class="s1">error_on_eof:</span>
            <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">new_pos</span><span class="s0">, </span><span class="s4">f'Expected &quot;</span><span class="s0">{</span><span class="s1">expect</span><span class="s0">!r}</span><span class="s4">&quot;'</span><span class="s1">)</span>

    <span class="s1">bad_chars = error_on.intersection(src[pos:new_pos])</span>
    <span class="s0">if </span><span class="s1">bad_chars:</span>
        <span class="s1">bad_char = next(iter(bad_chars))</span>
        <span class="s1">bad_pos = src.index(bad_char</span><span class="s0">, </span><span class="s1">pos)</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">bad_pos</span><span class="s0">, </span><span class="s4">f'Found invalid character &quot;</span><span class="s0">{</span><span class="s1">bad_char</span><span class="s0">!r}</span><span class="s4">&quot;'</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">new_pos</span>


<span class="s0">def </span><span class="s1">skip_comment(src: str</span><span class="s0">, </span><span class="s1">pos: Pos) -&gt; Pos:</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">char: Optional[str] = src[pos]</span>
    <span class="s0">except </span><span class="s1">IndexError:</span>
        <span class="s1">char = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">char == </span><span class="s4">&quot;#&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">skip_until(</span>
            <span class="s1">src</span><span class="s0">, </span><span class="s1">pos + </span><span class="s2">1</span><span class="s0">, </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s0">, </span><span class="s1">error_on=ILLEGAL_COMMENT_CHARS</span><span class="s0">, </span><span class="s1">error_on_eof=</span><span class="s0">False</span>
        <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">pos</span>


<span class="s0">def </span><span class="s1">skip_comments_and_array_ws(src: str</span><span class="s0">, </span><span class="s1">pos: Pos) -&gt; Pos:</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s1">pos_before_skip = pos</span>
        <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS_AND_NEWLINE)</span>
        <span class="s1">pos = skip_comment(src</span><span class="s0">, </span><span class="s1">pos)</span>
        <span class="s0">if </span><span class="s1">pos == pos_before_skip:</span>
            <span class="s0">return </span><span class="s1">pos</span>


<span class="s0">def </span><span class="s1">create_dict_rule(src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">state: State) -&gt; Pos:</span>
    <span class="s1">pos += </span><span class="s2">1  </span><span class="s3"># Skip &quot;[&quot;</span>
    <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>
    <span class="s1">pos</span><span class="s0">, </span><span class="s1">key = parse_key(src</span><span class="s0">, </span><span class="s1">pos)</span>

    <span class="s0">if </span><span class="s1">state.flags.is_(key</span><span class="s0">, </span><span class="s1">Flags.EXPLICIT_NEST) </span><span class="s0">or </span><span class="s1">state.flags.is_(key</span><span class="s0">, </span><span class="s1">Flags.FROZEN):</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">f&quot;Can not declare </span><span class="s0">{</span><span class="s1">key</span><span class="s0">} </span><span class="s4">twice&quot;</span><span class="s1">)</span>
    <span class="s1">state.flags.set(key</span><span class="s0">, </span><span class="s1">Flags.EXPLICIT_NEST</span><span class="s0">, </span><span class="s1">recursive=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">state.out.get_or_create_nest(key)</span>
    <span class="s0">except </span><span class="s1">KeyError:</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Can not overwrite a value&quot;</span><span class="s1">)</span>
    <span class="s1">state.header_namespace = key</span>

    <span class="s0">if </span><span class="s1">src[pos : pos + </span><span class="s2">1</span><span class="s1">] != </span><span class="s4">&quot;]&quot;</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">'Expected &quot;]&quot; at the end of a table declaration'</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">pos + </span><span class="s2">1</span>


<span class="s0">def </span><span class="s1">create_list_rule(src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">state: State) -&gt; Pos:</span>
    <span class="s1">pos += </span><span class="s2">2  </span><span class="s3"># Skip &quot;[[&quot;</span>
    <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>
    <span class="s1">pos</span><span class="s0">, </span><span class="s1">key = parse_key(src</span><span class="s0">, </span><span class="s1">pos)</span>

    <span class="s0">if </span><span class="s1">state.flags.is_(key</span><span class="s0">, </span><span class="s1">Flags.FROZEN):</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">f&quot;Can not mutate immutable namespace </span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s3"># Free the namespace now that it points to another empty list item...</span>
    <span class="s1">state.flags.unset_all(key)</span>
    <span class="s3"># ...but this key precisely is still prohibited from table declaration</span>
    <span class="s1">state.flags.set(key</span><span class="s0">, </span><span class="s1">Flags.EXPLICIT_NEST</span><span class="s0">, </span><span class="s1">recursive=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">state.out.append_nest_to_list(key)</span>
    <span class="s0">except </span><span class="s1">KeyError:</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Can not overwrite a value&quot;</span><span class="s1">)</span>
    <span class="s1">state.header_namespace = key</span>

    <span class="s1">end_marker = src[pos : pos + </span><span class="s2">2</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">end_marker != </span><span class="s4">&quot;]]&quot;</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(</span>
            <span class="s1">src</span><span class="s0">,</span>
            <span class="s1">pos</span><span class="s0">,</span>
            <span class="s4">f'Found &quot;</span><span class="s0">{</span><span class="s1">end_marker</span><span class="s0">!r}</span><span class="s4">&quot; at the end of an array declaration.'</span>
            <span class="s4">' Expected &quot;]]&quot;'</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">pos + </span><span class="s2">2</span>


<span class="s0">def </span><span class="s1">key_value_rule(src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">state: State</span><span class="s0">, </span><span class="s1">parse_float: ParseFloat) -&gt; Pos:</span>
    <span class="s1">pos</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value = parse_key_value_pair(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">parse_float)</span>
    <span class="s1">key_parent</span><span class="s0">, </span><span class="s1">key_stem = key[:-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">key[-</span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">abs_key_parent = state.header_namespace + key_parent</span>

    <span class="s0">if </span><span class="s1">state.flags.is_(abs_key_parent</span><span class="s0">, </span><span class="s1">Flags.FROZEN):</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(</span>
            <span class="s1">src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">f&quot;Can not mutate immutable namespace </span><span class="s0">{</span><span class="s1">abs_key_parent</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">)</span>
    <span class="s3"># Containers in the relative path can't be opened with the table syntax after this</span>
    <span class="s1">state.flags.set_for_relative_key(state.header_namespace</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">Flags.EXPLICIT_NEST)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">nest = state.out.get_or_create_nest(abs_key_parent)</span>
    <span class="s0">except </span><span class="s1">KeyError:</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Can not overwrite a value&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">key_stem </span><span class="s0">in </span><span class="s1">nest:</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Can not overwrite a value&quot;</span><span class="s1">)</span>
    <span class="s3"># Mark inline table and array namespaces recursively immutable</span>
    <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">, </span><span class="s1">list)):</span>
        <span class="s1">abs_key = state.header_namespace + key</span>
        <span class="s1">state.flags.set(abs_key</span><span class="s0">, </span><span class="s1">Flags.FROZEN</span><span class="s0">, </span><span class="s1">recursive=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">nest[key_stem] = value</span>
    <span class="s0">return </span><span class="s1">pos</span>


<span class="s0">def </span><span class="s1">parse_key_value_pair(</span>
    <span class="s1">src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">parse_float: ParseFloat</span>
<span class="s1">) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">Key</span><span class="s0">, </span><span class="s1">Any]:</span>
    <span class="s1">pos</span><span class="s0">, </span><span class="s1">key = parse_key(src</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">char: Optional[str] = src[pos]</span>
    <span class="s0">except </span><span class="s1">IndexError:</span>
        <span class="s1">char = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">char != </span><span class="s4">&quot;=&quot;</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">'Expected &quot;=&quot; after a key in a key/value pair'</span><span class="s1">)</span>
    <span class="s1">pos += </span><span class="s2">1</span>
    <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>
    <span class="s1">pos</span><span class="s0">, </span><span class="s1">value = parse_value(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">parse_float)</span>
    <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value</span>


<span class="s0">def </span><span class="s1">parse_key(src: str</span><span class="s0">, </span><span class="s1">pos: Pos) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">Key]:</span>
    <span class="s1">pos</span><span class="s0">, </span><span class="s1">key_part = parse_key_part(src</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s1">key = [key_part]</span>
    <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">char: Optional[str] = src[pos]</span>
        <span class="s0">except </span><span class="s1">IndexError:</span>
            <span class="s1">char = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">char != </span><span class="s4">&quot;.&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">tuple(key)</span>
        <span class="s1">pos += </span><span class="s2">1</span>
        <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>
        <span class="s1">pos</span><span class="s0">, </span><span class="s1">key_part = parse_key_part(src</span><span class="s0">, </span><span class="s1">pos)</span>
        <span class="s1">key.append(key_part)</span>
        <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>


<span class="s0">def </span><span class="s1">parse_key_part(src: str</span><span class="s0">, </span><span class="s1">pos: Pos) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">str]:</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">char: Optional[str] = src[pos]</span>
    <span class="s0">except </span><span class="s1">IndexError:</span>
        <span class="s1">char = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">char </span><span class="s0">in </span><span class="s1">BARE_KEY_CHARS:</span>
        <span class="s1">start_pos = pos</span>
        <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">BARE_KEY_CHARS)</span>
        <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">src[start_pos:pos]</span>
    <span class="s0">if </span><span class="s1">char == </span><span class="s4">&quot;'&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">parse_literal_str(src</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s0">if </span><span class="s1">char == </span><span class="s4">'&quot;'</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">parse_one_line_basic_str(src</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Invalid initial character for a key part&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">parse_one_line_basic_str(src: str</span><span class="s0">, </span><span class="s1">pos: Pos) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">str]:</span>
    <span class="s1">pos += </span><span class="s2">1</span>
    <span class="s0">return </span><span class="s1">parse_basic_str(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">multiline=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">parse_array(src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">parse_float: ParseFloat) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">list]:</span>
    <span class="s1">pos += </span><span class="s2">1</span>
    <span class="s1">array: list = []</span>

    <span class="s1">pos = skip_comments_and_array_ws(src</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s0">if </span><span class="s1">src[pos : pos + </span><span class="s2">1</span><span class="s1">] == </span><span class="s4">&quot;]&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">pos + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">array</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s1">pos</span><span class="s0">, </span><span class="s1">val = parse_value(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">parse_float)</span>
        <span class="s1">array.append(val)</span>
        <span class="s1">pos = skip_comments_and_array_ws(src</span><span class="s0">, </span><span class="s1">pos)</span>

        <span class="s1">c = src[pos : pos + </span><span class="s2">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">c == </span><span class="s4">&quot;]&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">pos + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">array</span>
        <span class="s0">if </span><span class="s1">c != </span><span class="s4">&quot;,&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Unclosed array&quot;</span><span class="s1">)</span>
        <span class="s1">pos += </span><span class="s2">1</span>

        <span class="s1">pos = skip_comments_and_array_ws(src</span><span class="s0">, </span><span class="s1">pos)</span>
        <span class="s0">if </span><span class="s1">src[pos : pos + </span><span class="s2">1</span><span class="s1">] == </span><span class="s4">&quot;]&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">pos + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">array</span>


<span class="s0">def </span><span class="s1">parse_inline_table(src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">parse_float: ParseFloat) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">dict]:</span>
    <span class="s1">pos += </span><span class="s2">1</span>
    <span class="s1">nested_dict = NestedDict()</span>
    <span class="s1">flags = Flags()</span>

    <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>
    <span class="s0">if </span><span class="s1">src[pos : pos + </span><span class="s2">1</span><span class="s1">] == </span><span class="s4">&quot;}&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">pos + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">nested_dict.dict</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s1">pos</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value = parse_key_value_pair(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">parse_float)</span>
        <span class="s1">key_parent</span><span class="s0">, </span><span class="s1">key_stem = key[:-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">key[-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">flags.is_(key</span><span class="s0">, </span><span class="s1">Flags.FROZEN):</span>
            <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">f&quot;Can not mutate immutable namespace </span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">nest = nested_dict.get_or_create_nest(key_parent</span><span class="s0">, </span><span class="s1">access_lists=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Can not overwrite a value&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">key_stem </span><span class="s0">in </span><span class="s1">nest:</span>
            <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">f'Duplicate inline table key &quot;</span><span class="s0">{</span><span class="s1">key_stem</span><span class="s0">}</span><span class="s4">&quot;'</span><span class="s1">)</span>
        <span class="s1">nest[key_stem] = value</span>
        <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>
        <span class="s1">c = src[pos : pos + </span><span class="s2">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">c == </span><span class="s4">&quot;}&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">pos + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">nested_dict.dict</span>
        <span class="s0">if </span><span class="s1">c != </span><span class="s4">&quot;,&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Unclosed inline table&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">, </span><span class="s1">list)):</span>
            <span class="s1">flags.set(key</span><span class="s0">, </span><span class="s1">Flags.FROZEN</span><span class="s0">, </span><span class="s1">recursive=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">pos += </span><span class="s2">1</span>
        <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>


<span class="s0">def </span><span class="s1">parse_basic_str_escape(</span>
    <span class="s1">src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">multiline: bool = </span><span class="s0">False</span>
<span class="s1">) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">str]:</span>
    <span class="s1">escape_id = src[pos : pos + </span><span class="s2">2</span><span class="s1">]</span>
    <span class="s1">pos += </span><span class="s2">2</span>
    <span class="s0">if </span><span class="s1">multiline </span><span class="s0">and </span><span class="s1">escape_id </span><span class="s0">in </span><span class="s1">{</span><span class="s4">&quot;</span><span class="s0">\\ </span><span class="s4">&quot;</span><span class="s0">, </span><span class="s4">&quot;</span><span class="s0">\\\t</span><span class="s4">&quot;</span><span class="s0">, </span><span class="s4">&quot;</span><span class="s0">\\\n</span><span class="s4">&quot;</span><span class="s1">}:</span>
        <span class="s3"># Skip whitespace until next non-whitespace character or end of</span>
        <span class="s3"># the doc. Error if non-whitespace is found before newline.</span>
        <span class="s0">if </span><span class="s1">escape_id != </span><span class="s4">&quot;</span><span class="s0">\\\n</span><span class="s4">&quot;</span><span class="s1">:</span>
            <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS)</span>
            <span class="s1">char = src[pos : pos + </span><span class="s2">1</span><span class="s1">]</span>
            <span class="s0">if not </span><span class="s1">char:</span>
                <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;&quot;</span>
            <span class="s0">if </span><span class="s1">char != </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">'Unescaped &quot;</span><span class="s0">\\</span><span class="s4">&quot; in a string'</span><span class="s1">)</span>
            <span class="s1">pos += </span><span class="s2">1</span>
        <span class="s1">pos = skip_chars(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">TOML_WS_AND_NEWLINE)</span>
        <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">escape_id == </span><span class="s4">&quot;</span><span class="s0">\\</span><span class="s4">u&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">parse_hex_char(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">escape_id == </span><span class="s4">&quot;</span><span class="s0">\\</span><span class="s4">U&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">parse_hex_char(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s2">8</span><span class="s1">)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">BASIC_STR_ESCAPE_REPLACEMENTS[escape_id]</span>
    <span class="s0">except </span><span class="s1">KeyError:</span>
        <span class="s0">if </span><span class="s1">len(escape_id) != </span><span class="s2">2</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Unterminated string&quot;</span><span class="s1">)</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">'Unescaped &quot;</span><span class="s0">\\</span><span class="s4">&quot; in a string'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">parse_basic_str_escape_multiline(src: str</span><span class="s0">, </span><span class="s1">pos: Pos) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">str]:</span>
    <span class="s0">return </span><span class="s1">parse_basic_str_escape(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">multiline=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">parse_hex_char(src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">hex_len: int) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">str]:</span>
    <span class="s1">hex_str = src[pos : pos + hex_len]</span>
    <span class="s0">if </span><span class="s1">len(hex_str) != hex_len </span><span class="s0">or </span><span class="s1">any(c </span><span class="s0">not in </span><span class="s1">string.hexdigits </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">hex_str):</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Invalid hex value&quot;</span><span class="s1">)</span>
    <span class="s1">pos += hex_len</span>
    <span class="s1">hex_int = int(hex_str</span><span class="s0">, </span><span class="s2">16</span><span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">is_unicode_scalar_value(hex_int):</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Escaped character is not a Unicode scalar value&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">chr(hex_int)</span>


<span class="s0">def </span><span class="s1">parse_literal_str(src: str</span><span class="s0">, </span><span class="s1">pos: Pos) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">str]:</span>
    <span class="s1">pos += </span><span class="s2">1  </span><span class="s3"># Skip starting apostrophe</span>
    <span class="s1">start_pos = pos</span>
    <span class="s1">pos = skip_until(</span>
        <span class="s1">src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;'&quot;</span><span class="s0">, </span><span class="s1">error_on=ILLEGAL_LITERAL_STR_CHARS</span><span class="s0">, </span><span class="s1">error_on_eof=</span><span class="s0">True</span>
    <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">pos + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">src[start_pos:pos]  </span><span class="s3"># Skip ending apostrophe</span>


<span class="s0">def </span><span class="s1">parse_multiline_str(src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">literal: bool) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">str]:</span>
    <span class="s1">pos += </span><span class="s2">3</span>
    <span class="s0">if </span><span class="s1">src[pos : pos + </span><span class="s2">1</span><span class="s1">] == </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">:</span>
        <span class="s1">pos += </span><span class="s2">1</span>

    <span class="s0">if </span><span class="s1">literal:</span>
        <span class="s1">delim = </span><span class="s4">&quot;'&quot;</span>
        <span class="s1">end_pos = skip_until(</span>
            <span class="s1">src</span><span class="s0">,</span>
            <span class="s1">pos</span><span class="s0">,</span>
            <span class="s4">&quot;'''&quot;</span><span class="s0">,</span>
            <span class="s1">error_on=ILLEGAL_MULTILINE_LITERAL_STR_CHARS</span><span class="s0">,</span>
            <span class="s1">error_on_eof=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">result = src[pos:end_pos]</span>
        <span class="s1">pos = end_pos + </span><span class="s2">3</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">delim = </span><span class="s4">'&quot;'</span>
        <span class="s1">pos</span><span class="s0">, </span><span class="s1">result = parse_basic_str(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">multiline=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s3"># Add at maximum two extra apostrophes/quotes if the end sequence</span>
    <span class="s3"># is 4 or 5 chars long instead of just 3.</span>
    <span class="s0">if </span><span class="s1">src[pos : pos + </span><span class="s2">1</span><span class="s1">] != delim:</span>
        <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">result</span>
    <span class="s1">pos += </span><span class="s2">1</span>
    <span class="s0">if </span><span class="s1">src[pos : pos + </span><span class="s2">1</span><span class="s1">] != delim:</span>
        <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">result + delim</span>
    <span class="s1">pos += </span><span class="s2">1</span>
    <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">result + (delim * </span><span class="s2">2</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">parse_basic_str(src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">multiline: bool) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">str]:</span>
    <span class="s0">if </span><span class="s1">multiline:</span>
        <span class="s1">error_on = ILLEGAL_MULTILINE_BASIC_STR_CHARS</span>
        <span class="s1">parse_escapes = parse_basic_str_escape_multiline</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">error_on = ILLEGAL_BASIC_STR_CHARS</span>
        <span class="s1">parse_escapes = parse_basic_str_escape</span>
    <span class="s1">result = </span><span class="s4">&quot;&quot;</span>
    <span class="s1">start_pos = pos</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">char = src[pos]</span>
        <span class="s0">except </span><span class="s1">IndexError:</span>
            <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Unterminated string&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">char == </span><span class="s4">'&quot;'</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">multiline:</span>
                <span class="s0">return </span><span class="s1">pos + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">result + src[start_pos:pos]</span>
            <span class="s0">if </span><span class="s1">src[pos + </span><span class="s2">1 </span><span class="s1">: pos + </span><span class="s2">3</span><span class="s1">] == </span><span class="s4">'&quot;&quot;'</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">pos + </span><span class="s2">3</span><span class="s0">, </span><span class="s1">result + src[start_pos:pos]</span>
            <span class="s1">pos += </span><span class="s2">1</span>
            <span class="s0">continue</span>
        <span class="s0">if </span><span class="s1">char == </span><span class="s4">&quot;</span><span class="s0">\\</span><span class="s4">&quot;</span><span class="s1">:</span>
            <span class="s1">result += src[start_pos:pos]</span>
            <span class="s1">pos</span><span class="s0">, </span><span class="s1">parsed_escape = parse_escapes(src</span><span class="s0">, </span><span class="s1">pos)</span>
            <span class="s1">result += parsed_escape</span>
            <span class="s1">start_pos = pos</span>
            <span class="s0">continue</span>
        <span class="s0">if </span><span class="s1">char </span><span class="s0">in </span><span class="s1">error_on:</span>
            <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">f'Illegal character &quot;</span><span class="s0">{</span><span class="s1">char</span><span class="s0">!r}</span><span class="s4">&quot;'</span><span class="s1">)</span>
        <span class="s1">pos += </span><span class="s2">1</span>


<span class="s0">def </span><span class="s1">parse_regex(src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">regex: </span><span class="s4">&quot;Pattern&quot;</span><span class="s1">) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">str]:</span>
    <span class="s1">match = regex.match(src</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s0">if not </span><span class="s1">match:</span>
        <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Unexpected sequence&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">match.end()</span><span class="s0">, </span><span class="s1">match.group()</span>


<span class="s0">def </span><span class="s1">parse_value(  </span><span class="s3"># noqa: C901</span>
    <span class="s1">src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">parse_float: ParseFloat</span>
<span class="s1">) -&gt; Tuple[Pos</span><span class="s0">, </span><span class="s1">Any]:</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">char: Optional[str] = src[pos]</span>
    <span class="s0">except </span><span class="s1">IndexError:</span>
        <span class="s1">char = </span><span class="s0">None</span>

    <span class="s3"># Basic strings</span>
    <span class="s0">if </span><span class="s1">char == </span><span class="s4">'&quot;'</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">src[pos + </span><span class="s2">1 </span><span class="s1">: pos + </span><span class="s2">3</span><span class="s1">] == </span><span class="s4">'&quot;&quot;'</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">parse_multiline_str(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">literal=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">parse_one_line_basic_str(src</span><span class="s0">, </span><span class="s1">pos)</span>

    <span class="s3"># Literal strings</span>
    <span class="s0">if </span><span class="s1">char == </span><span class="s4">&quot;'&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">src[pos + </span><span class="s2">1 </span><span class="s1">: pos + </span><span class="s2">3</span><span class="s1">] == </span><span class="s4">&quot;''&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">parse_multiline_str(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">literal=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">parse_literal_str(src</span><span class="s0">, </span><span class="s1">pos)</span>

    <span class="s3"># Booleans</span>
    <span class="s0">if </span><span class="s1">char == </span><span class="s4">&quot;t&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">src[pos + </span><span class="s2">1 </span><span class="s1">: pos + </span><span class="s2">4</span><span class="s1">] == </span><span class="s4">&quot;rue&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">pos + </span><span class="s2">4</span><span class="s0">, True</span>
    <span class="s0">if </span><span class="s1">char == </span><span class="s4">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">src[pos + </span><span class="s2">1 </span><span class="s1">: pos + </span><span class="s2">5</span><span class="s1">] == </span><span class="s4">&quot;alse&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">pos + </span><span class="s2">5</span><span class="s0">, False</span>

    <span class="s3"># Dates and times</span>
    <span class="s1">datetime_match = RE_DATETIME.match(src</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s0">if </span><span class="s1">datetime_match:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">datetime_obj = match_to_datetime(datetime_match)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Invalid date or datetime&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">datetime_match.end()</span><span class="s0">, </span><span class="s1">datetime_obj</span>
    <span class="s1">localtime_match = RE_LOCALTIME.match(src</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s0">if </span><span class="s1">localtime_match:</span>
        <span class="s0">return </span><span class="s1">localtime_match.end()</span><span class="s0">, </span><span class="s1">match_to_localtime(localtime_match)</span>

    <span class="s3"># Non-decimal integers</span>
    <span class="s0">if </span><span class="s1">char == </span><span class="s4">&quot;0&quot;</span><span class="s1">:</span>
        <span class="s1">second_char = src[pos + </span><span class="s2">1 </span><span class="s1">: pos + </span><span class="s2">2</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">second_char == </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>
            <span class="s1">pos</span><span class="s0">, </span><span class="s1">hex_str = parse_regex(src</span><span class="s0">, </span><span class="s1">pos + </span><span class="s2">2</span><span class="s0">, </span><span class="s1">RE_HEX)</span>
            <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">int(hex_str</span><span class="s0">, </span><span class="s2">16</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">second_char == </span><span class="s4">&quot;o&quot;</span><span class="s1">:</span>
            <span class="s1">pos</span><span class="s0">, </span><span class="s1">oct_str = parse_regex(src</span><span class="s0">, </span><span class="s1">pos + </span><span class="s2">2</span><span class="s0">, </span><span class="s1">RE_OCT)</span>
            <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">int(oct_str</span><span class="s0">, </span><span class="s2">8</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">second_char == </span><span class="s4">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s1">pos</span><span class="s0">, </span><span class="s1">bin_str = parse_regex(src</span><span class="s0">, </span><span class="s1">pos + </span><span class="s2">2</span><span class="s0">, </span><span class="s1">RE_BIN)</span>
            <span class="s0">return </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">int(bin_str</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

    <span class="s3"># Decimal integers and &quot;normal&quot; floats.</span>
    <span class="s3"># The regex will greedily match any type starting with a decimal</span>
    <span class="s3"># char, so needs to be located after handling of non-decimal ints,</span>
    <span class="s3"># and dates and times.</span>
    <span class="s1">number_match = RE_NUMBER.match(src</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s0">if </span><span class="s1">number_match:</span>
        <span class="s0">return </span><span class="s1">number_match.end()</span><span class="s0">, </span><span class="s1">match_to_number(number_match</span><span class="s0">, </span><span class="s1">parse_float)</span>

    <span class="s3"># Arrays</span>
    <span class="s0">if </span><span class="s1">char == </span><span class="s4">&quot;[&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">parse_array(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">parse_float)</span>

    <span class="s3"># Inline tables</span>
    <span class="s0">if </span><span class="s1">char == </span><span class="s4">&quot;{&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">parse_inline_table(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">parse_float)</span>

    <span class="s3"># Special floats</span>
    <span class="s1">first_three = src[pos : pos + </span><span class="s2">3</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">first_three </span><span class="s0">in </span><span class="s1">{</span><span class="s4">&quot;inf&quot;</span><span class="s0">, </span><span class="s4">&quot;nan&quot;</span><span class="s1">}:</span>
        <span class="s0">return </span><span class="s1">pos + </span><span class="s2">3</span><span class="s0">, </span><span class="s1">parse_float(first_three)</span>
    <span class="s1">first_four = src[pos : pos + </span><span class="s2">4</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">first_four </span><span class="s0">in </span><span class="s1">{</span><span class="s4">&quot;-inf&quot;</span><span class="s0">, </span><span class="s4">&quot;+inf&quot;</span><span class="s0">, </span><span class="s4">&quot;-nan&quot;</span><span class="s0">, </span><span class="s4">&quot;+nan&quot;</span><span class="s1">}:</span>
        <span class="s0">return </span><span class="s1">pos + </span><span class="s2">4</span><span class="s0">, </span><span class="s1">parse_float(first_four)</span>

    <span class="s0">raise </span><span class="s1">suffixed_err(src</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s4">&quot;Invalid value&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">suffixed_err(src: str</span><span class="s0">, </span><span class="s1">pos: Pos</span><span class="s0">, </span><span class="s1">msg: str) -&gt; TOMLDecodeError:</span>
    <span class="s5">&quot;&quot;&quot;Return a `TOMLDecodeError` where error message is suffixed with 
    coordinates in source.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">coord_repr(src: str</span><span class="s0">, </span><span class="s1">pos: Pos) -&gt; str:</span>
        <span class="s0">if </span><span class="s1">pos &gt;= len(src):</span>
            <span class="s0">return </span><span class="s4">&quot;end of document&quot;</span>
        <span class="s1">line = src.count(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">pos) + </span><span class="s2">1</span>
        <span class="s0">if </span><span class="s1">line == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s1">column = pos + </span><span class="s2">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">column = pos - src.rindex(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">pos)</span>
        <span class="s0">return </span><span class="s4">f&quot;line </span><span class="s0">{</span><span class="s1">line</span><span class="s0">}</span><span class="s4">, column </span><span class="s0">{</span><span class="s1">column</span><span class="s0">}</span><span class="s4">&quot;</span>

    <span class="s0">return </span><span class="s1">TOMLDecodeError(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">msg</span><span class="s0">} </span><span class="s4">(at </span><span class="s0">{</span><span class="s1">coord_repr(src</span><span class="s0">, </span><span class="s1">pos)</span><span class="s0">}</span><span class="s4">)&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">is_unicode_scalar_value(codepoint: int) -&gt; bool:</span>
    <span class="s0">return </span><span class="s1">(</span><span class="s2">0 </span><span class="s1">&lt;= codepoint &lt;= </span><span class="s2">55295</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(</span><span class="s2">57344 </span><span class="s1">&lt;= codepoint &lt;= </span><span class="s2">1114111</span><span class="s1">)</span>
</pre>
</body>
</html>