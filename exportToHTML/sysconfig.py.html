<html>
<head>
<title>sysconfig.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sysconfig.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s0">#</span>
<span class="s0"># Copyright (C) 2012 The Python Software Foundation.</span>
<span class="s0"># See LICENSE.txt and CONTRIBUTORS.txt.</span>
<span class="s0">#</span>
<span class="s2">&quot;&quot;&quot;Access to Python's configuration information.&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">codecs</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">from </span><span class="s1">os.path </span><span class="s3">import </span><span class="s1">pardir</span><span class="s3">, </span><span class="s1">realpath</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">import </span><span class="s1">configparser</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">import </span><span class="s1">ConfigParser </span><span class="s3">as </span><span class="s1">configparser</span>


<span class="s1">__all__ = [</span>
    <span class="s4">'get_config_h_filename'</span><span class="s3">,</span>
    <span class="s4">'get_config_var'</span><span class="s3">,</span>
    <span class="s4">'get_config_vars'</span><span class="s3">,</span>
    <span class="s4">'get_makefile_filename'</span><span class="s3">,</span>
    <span class="s4">'get_path'</span><span class="s3">,</span>
    <span class="s4">'get_path_names'</span><span class="s3">,</span>
    <span class="s4">'get_paths'</span><span class="s3">,</span>
    <span class="s4">'get_platform'</span><span class="s3">,</span>
    <span class="s4">'get_python_version'</span><span class="s3">,</span>
    <span class="s4">'get_scheme_names'</span><span class="s3">,</span>
    <span class="s4">'parse_config_h'</span><span class="s3">,</span>
<span class="s1">]</span>


<span class="s3">def </span><span class="s1">_safe_realpath(path):</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">realpath(path)</span>
    <span class="s3">except </span><span class="s1">OSError:</span>
        <span class="s3">return </span><span class="s1">path</span>


<span class="s3">if </span><span class="s1">sys.executable:</span>
    <span class="s1">_PROJECT_BASE = os.path.dirname(_safe_realpath(sys.executable))</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s0"># sys.executable can be empty if argv[0] has been changed and Python is</span>
    <span class="s0"># unable to retrieve the real program name</span>
    <span class="s1">_PROJECT_BASE = _safe_realpath(os.getcwd())</span>

<span class="s3">if </span><span class="s1">os.name == </span><span class="s4">&quot;nt&quot; </span><span class="s3">and </span><span class="s4">&quot;pcbuild&quot; </span><span class="s3">in </span><span class="s1">_PROJECT_BASE[-</span><span class="s5">8</span><span class="s1">:].lower():</span>
    <span class="s1">_PROJECT_BASE = _safe_realpath(os.path.join(_PROJECT_BASE</span><span class="s3">, </span><span class="s1">pardir))</span>
<span class="s0"># PC/VS7.1</span>
<span class="s3">if </span><span class="s1">os.name == </span><span class="s4">&quot;nt&quot; </span><span class="s3">and </span><span class="s4">&quot;</span><span class="s3">\\</span><span class="s4">pc</span><span class="s3">\\</span><span class="s4">v&quot; </span><span class="s3">in </span><span class="s1">_PROJECT_BASE[-</span><span class="s5">10</span><span class="s1">:].lower():</span>
    <span class="s1">_PROJECT_BASE = _safe_realpath(os.path.join(_PROJECT_BASE</span><span class="s3">, </span><span class="s1">pardir</span><span class="s3">, </span><span class="s1">pardir))</span>
<span class="s0"># PC/AMD64</span>
<span class="s3">if </span><span class="s1">os.name == </span><span class="s4">&quot;nt&quot; </span><span class="s3">and </span><span class="s4">&quot;</span><span class="s3">\\</span><span class="s4">pcbuild</span><span class="s3">\\</span><span class="s4">amd64&quot; </span><span class="s3">in </span><span class="s1">_PROJECT_BASE[-</span><span class="s5">14</span><span class="s1">:].lower():</span>
    <span class="s1">_PROJECT_BASE = _safe_realpath(os.path.join(_PROJECT_BASE</span><span class="s3">, </span><span class="s1">pardir</span><span class="s3">, </span><span class="s1">pardir))</span>


<span class="s3">def </span><span class="s1">is_python_build():</span>
    <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;Setup.dist&quot;</span><span class="s3">, </span><span class="s4">&quot;Setup.local&quot;</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">os.path.isfile(os.path.join(_PROJECT_BASE</span><span class="s3">, </span><span class="s4">&quot;Modules&quot;</span><span class="s3">, </span><span class="s1">fn)):</span>
            <span class="s3">return True</span>
    <span class="s3">return False</span>

<span class="s1">_PYTHON_BUILD = is_python_build()</span>

<span class="s1">_cfg_read = </span><span class="s3">False</span>

<span class="s3">def </span><span class="s1">_ensure_cfg_read():</span>
    <span class="s3">global </span><span class="s1">_cfg_read</span>
    <span class="s3">if not </span><span class="s1">_cfg_read:</span>
        <span class="s3">from </span><span class="s1">..resources </span><span class="s3">import </span><span class="s1">finder</span>
        <span class="s1">backport_package = __name__.rsplit(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">_finder = finder(backport_package)</span>
        <span class="s1">_cfgfile = _finder.find(</span><span class="s4">'sysconfig.cfg'</span><span class="s1">)</span>
        <span class="s3">assert </span><span class="s1">_cfgfile</span><span class="s3">, </span><span class="s4">'sysconfig.cfg exists'</span>
        <span class="s3">with </span><span class="s1">_cfgfile.as_stream() </span><span class="s3">as </span><span class="s1">s:</span>
            <span class="s1">_SCHEMES.readfp(s)</span>
        <span class="s3">if </span><span class="s1">_PYTHON_BUILD:</span>
            <span class="s3">for </span><span class="s1">scheme </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'posix_prefix'</span><span class="s3">, </span><span class="s4">'posix_home'</span><span class="s1">):</span>
                <span class="s1">_SCHEMES.set(scheme</span><span class="s3">, </span><span class="s4">'include'</span><span class="s3">, </span><span class="s4">'{srcdir}/Include'</span><span class="s1">)</span>
                <span class="s1">_SCHEMES.set(scheme</span><span class="s3">, </span><span class="s4">'platinclude'</span><span class="s3">, </span><span class="s4">'{projectbase}/.'</span><span class="s1">)</span>

        <span class="s1">_cfg_read = </span><span class="s3">True</span>


<span class="s1">_SCHEMES = configparser.RawConfigParser()</span>
<span class="s1">_VAR_REPL = re.compile(</span><span class="s4">r'\{([^{]*?)\}'</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_expand_globals(config):</span>
    <span class="s1">_ensure_cfg_read()</span>
    <span class="s3">if </span><span class="s1">config.has_section(</span><span class="s4">'globals'</span><span class="s1">):</span>
        <span class="s1">globals = config.items(</span><span class="s4">'globals'</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">globals = tuple()</span>

    <span class="s1">sections = config.sections()</span>
    <span class="s3">for </span><span class="s1">section </span><span class="s3">in </span><span class="s1">sections:</span>
        <span class="s3">if </span><span class="s1">section == </span><span class="s4">'globals'</span><span class="s1">:</span>
            <span class="s3">continue</span>
        <span class="s3">for </span><span class="s1">option</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">globals:</span>
            <span class="s3">if </span><span class="s1">config.has_option(section</span><span class="s3">, </span><span class="s1">option):</span>
                <span class="s3">continue</span>
            <span class="s1">config.set(section</span><span class="s3">, </span><span class="s1">option</span><span class="s3">, </span><span class="s1">value)</span>
    <span class="s1">config.remove_section(</span><span class="s4">'globals'</span><span class="s1">)</span>

    <span class="s0"># now expanding local variables defined in the cfg file</span>
    <span class="s0">#</span>
    <span class="s3">for </span><span class="s1">section </span><span class="s3">in </span><span class="s1">config.sections():</span>
        <span class="s1">variables = dict(config.items(section))</span>

        <span class="s3">def </span><span class="s1">_replacer(matchobj):</span>
            <span class="s1">name = matchobj.group(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">variables:</span>
                <span class="s3">return </span><span class="s1">variables[name]</span>
            <span class="s3">return </span><span class="s1">matchobj.group(</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s3">for </span><span class="s1">option</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">config.items(section):</span>
            <span class="s1">config.set(section</span><span class="s3">, </span><span class="s1">option</span><span class="s3">, </span><span class="s1">_VAR_REPL.sub(_replacer</span><span class="s3">, </span><span class="s1">value))</span>

<span class="s0">#_expand_globals(_SCHEMES)</span>

<span class="s1">_PY_VERSION = </span><span class="s4">'%s.%s.%s' </span><span class="s1">% sys.version_info[:</span><span class="s5">3</span><span class="s1">]</span>
<span class="s1">_PY_VERSION_SHORT = </span><span class="s4">'%s.%s' </span><span class="s1">% sys.version_info[:</span><span class="s5">2</span><span class="s1">]</span>
<span class="s1">_PY_VERSION_SHORT_NO_DOT = </span><span class="s4">'%s%s' </span><span class="s1">% sys.version_info[:</span><span class="s5">2</span><span class="s1">]</span>
<span class="s1">_PREFIX = os.path.normpath(sys.prefix)</span>
<span class="s1">_EXEC_PREFIX = os.path.normpath(sys.exec_prefix)</span>
<span class="s1">_CONFIG_VARS = </span><span class="s3">None</span>
<span class="s1">_USER_BASE = </span><span class="s3">None</span>


<span class="s3">def </span><span class="s1">_subst_vars(path</span><span class="s3">, </span><span class="s1">local_vars):</span>
    <span class="s2">&quot;&quot;&quot;In the string `path`, replace tokens like {some.thing} with the 
    corresponding value from the map `local_vars`. 
 
    If there is no corresponding value, leave the token unchanged. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">_replacer(matchobj):</span>
        <span class="s1">name = matchobj.group(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">local_vars:</span>
            <span class="s3">return </span><span class="s1">local_vars[name]</span>
        <span class="s3">elif </span><span class="s1">name </span><span class="s3">in </span><span class="s1">os.environ:</span>
            <span class="s3">return </span><span class="s1">os.environ[name]</span>
        <span class="s3">return </span><span class="s1">matchobj.group(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_VAR_REPL.sub(_replacer</span><span class="s3">, </span><span class="s1">path)</span>


<span class="s3">def </span><span class="s1">_extend_dict(target_dict</span><span class="s3">, </span><span class="s1">other_dict):</span>
    <span class="s1">target_keys = target_dict.keys()</span>
    <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">other_dict.items():</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">target_keys:</span>
            <span class="s3">continue</span>
        <span class="s1">target_dict[key] = value</span>


<span class="s3">def </span><span class="s1">_expand_vars(scheme</span><span class="s3">, </span><span class="s1">vars):</span>
    <span class="s1">res = {}</span>
    <span class="s3">if </span><span class="s1">vars </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">vars = {}</span>
    <span class="s1">_extend_dict(vars</span><span class="s3">, </span><span class="s1">get_config_vars())</span>

    <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">_SCHEMES.items(scheme):</span>
        <span class="s3">if </span><span class="s1">os.name </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'posix'</span><span class="s3">, </span><span class="s4">'nt'</span><span class="s1">):</span>
            <span class="s1">value = os.path.expanduser(value)</span>
        <span class="s1">res[key] = os.path.normpath(_subst_vars(value</span><span class="s3">, </span><span class="s1">vars))</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">format_value(value</span><span class="s3">, </span><span class="s1">vars):</span>
    <span class="s3">def </span><span class="s1">_replacer(matchobj):</span>
        <span class="s1">name = matchobj.group(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">vars:</span>
            <span class="s3">return </span><span class="s1">vars[name]</span>
        <span class="s3">return </span><span class="s1">matchobj.group(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_VAR_REPL.sub(_replacer</span><span class="s3">, </span><span class="s1">value)</span>


<span class="s3">def </span><span class="s1">_get_default_scheme():</span>
    <span class="s3">if </span><span class="s1">os.name == </span><span class="s4">'posix'</span><span class="s1">:</span>
        <span class="s0"># the default scheme for posix is posix_prefix</span>
        <span class="s3">return </span><span class="s4">'posix_prefix'</span>
    <span class="s3">return </span><span class="s1">os.name</span>


<span class="s3">def </span><span class="s1">_getuserbase():</span>
    <span class="s1">env_base = os.environ.get(</span><span class="s4">&quot;PYTHONUSERBASE&quot;</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">joinuser(*args):</span>
        <span class="s3">return </span><span class="s1">os.path.expanduser(os.path.join(*args))</span>

    <span class="s0"># what about 'os2emx', 'riscos' ?</span>
    <span class="s3">if </span><span class="s1">os.name == </span><span class="s4">&quot;nt&quot;</span><span class="s1">:</span>
        <span class="s1">base = os.environ.get(</span><span class="s4">&quot;APPDATA&quot;</span><span class="s1">) </span><span class="s3">or </span><span class="s4">&quot;~&quot;</span>
        <span class="s3">if </span><span class="s1">env_base:</span>
            <span class="s3">return </span><span class="s1">env_base</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">joinuser(base</span><span class="s3">, </span><span class="s4">&quot;Python&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">sys.platform == </span><span class="s4">&quot;darwin&quot;</span><span class="s1">:</span>
        <span class="s1">framework = get_config_var(</span><span class="s4">&quot;PYTHONFRAMEWORK&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">framework:</span>
            <span class="s3">if </span><span class="s1">env_base:</span>
                <span class="s3">return </span><span class="s1">env_base</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">joinuser(</span><span class="s4">&quot;~&quot;</span><span class="s3">, </span><span class="s4">&quot;Library&quot;</span><span class="s3">, </span><span class="s1">framework</span><span class="s3">, </span><span class="s4">&quot;%d.%d&quot; </span><span class="s1">%</span>
                                <span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">])</span>

    <span class="s3">if </span><span class="s1">env_base:</span>
        <span class="s3">return </span><span class="s1">env_base</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">joinuser(</span><span class="s4">&quot;~&quot;</span><span class="s3">, </span><span class="s4">&quot;.local&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_parse_makefile(filename</span><span class="s3">, </span><span class="s1">vars=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Parse a Makefile-style file. 
 
    A dictionary containing name/value pairs is returned.  If an 
    optional dictionary is passed in as the second argument, it is 
    used instead of a new dictionary. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Regexes needed for parsing Makefile (and similar syntaxes,</span>
    <span class="s0"># like old-style Setup files).</span>
    <span class="s1">_variable_rx = re.compile(</span><span class="s4">r&quot;([a-zA-Z][a-zA-Z0-9_]+)\s*=\s*(.*)&quot;</span><span class="s1">)</span>
    <span class="s1">_findvar1_rx = re.compile(</span><span class="s4">r&quot;\$\(([A-Za-z][A-Za-z0-9_]*)\)&quot;</span><span class="s1">)</span>
    <span class="s1">_findvar2_rx = re.compile(</span><span class="s4">r&quot;\${([A-Za-z][A-Za-z0-9_]*)}&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">vars </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">vars = {}</span>
    <span class="s1">done = {}</span>
    <span class="s1">notdone = {}</span>

    <span class="s3">with </span><span class="s1">codecs.open(filename</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s4">'utf-8'</span><span class="s3">, </span><span class="s1">errors=</span><span class="s4">&quot;surrogateescape&quot;</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s1">lines = f.readlines()</span>

    <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">lines:</span>
        <span class="s3">if </span><span class="s1">line.startswith(</span><span class="s4">'#'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">line.strip() == </span><span class="s4">''</span><span class="s1">:</span>
            <span class="s3">continue</span>
        <span class="s1">m = _variable_rx.match(line)</span>
        <span class="s3">if </span><span class="s1">m:</span>
            <span class="s1">n</span><span class="s3">, </span><span class="s1">v = m.group(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">v = v.strip()</span>
            <span class="s0"># `$$' is a literal `$' in make</span>
            <span class="s1">tmpv = v.replace(</span><span class="s4">'$$'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>

            <span class="s3">if </span><span class="s4">&quot;$&quot; </span><span class="s3">in </span><span class="s1">tmpv:</span>
                <span class="s1">notdone[n] = v</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">v = int(v)</span>
                <span class="s3">except </span><span class="s1">ValueError:</span>
                    <span class="s0"># insert literal `$'</span>
                    <span class="s1">done[n] = v.replace(</span><span class="s4">'$$'</span><span class="s3">, </span><span class="s4">'$'</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">done[n] = v</span>

    <span class="s0"># do variable interpolation here</span>
    <span class="s1">variables = list(notdone.keys())</span>

    <span class="s0"># Variables with a 'PY_' prefix in the makefile. These need to</span>
    <span class="s0"># be made available without that prefix through sysconfig.</span>
    <span class="s0"># Special care is needed to ensure that variable expansion works, even</span>
    <span class="s0"># if the expansion uses the name without a prefix.</span>
    <span class="s1">renamed_variables = (</span><span class="s4">'CFLAGS'</span><span class="s3">, </span><span class="s4">'LDFLAGS'</span><span class="s3">, </span><span class="s4">'CPPFLAGS'</span><span class="s1">)</span>

    <span class="s3">while </span><span class="s1">len(variables) &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">tuple(variables):</span>
            <span class="s1">value = notdone[name]</span>
            <span class="s1">m = _findvar1_rx.search(value) </span><span class="s3">or </span><span class="s1">_findvar2_rx.search(value)</span>
            <span class="s3">if </span><span class="s1">m </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">n = m.group(</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">found = </span><span class="s3">True</span>
                <span class="s3">if </span><span class="s1">n </span><span class="s3">in </span><span class="s1">done:</span>
                    <span class="s1">item = str(done[n])</span>
                <span class="s3">elif </span><span class="s1">n </span><span class="s3">in </span><span class="s1">notdone:</span>
                    <span class="s0"># get it on a subsequent round</span>
                    <span class="s1">found = </span><span class="s3">False</span>
                <span class="s3">elif </span><span class="s1">n </span><span class="s3">in </span><span class="s1">os.environ:</span>
                    <span class="s0"># do it like make: fall back to environment</span>
                    <span class="s1">item = os.environ[n]</span>

                <span class="s3">elif </span><span class="s1">n </span><span class="s3">in </span><span class="s1">renamed_variables:</span>
                    <span class="s3">if </span><span class="s1">(name.startswith(</span><span class="s4">'PY_'</span><span class="s1">) </span><span class="s3">and</span>
                        <span class="s1">name[</span><span class="s5">3</span><span class="s1">:] </span><span class="s3">in </span><span class="s1">renamed_variables):</span>
                        <span class="s1">item = </span><span class="s4">&quot;&quot;</span>

                    <span class="s3">elif </span><span class="s4">'PY_' </span><span class="s1">+ n </span><span class="s3">in </span><span class="s1">notdone:</span>
                        <span class="s1">found = </span><span class="s3">False</span>

                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">item = str(done[</span><span class="s4">'PY_' </span><span class="s1">+ n])</span>

                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">done[n] = item = </span><span class="s4">&quot;&quot;</span>

                <span class="s3">if </span><span class="s1">found:</span>
                    <span class="s1">after = value[m.end():]</span>
                    <span class="s1">value = value[:m.start()] + item + after</span>
                    <span class="s3">if </span><span class="s4">&quot;$&quot; </span><span class="s3">in </span><span class="s1">after:</span>
                        <span class="s1">notdone[name] = value</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">try</span><span class="s1">:</span>
                            <span class="s1">value = int(value)</span>
                        <span class="s3">except </span><span class="s1">ValueError:</span>
                            <span class="s1">done[name] = value.strip()</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s1">done[name] = value</span>
                        <span class="s1">variables.remove(name)</span>

                        <span class="s3">if </span><span class="s1">(name.startswith(</span><span class="s4">'PY_'</span><span class="s1">) </span><span class="s3">and</span>
                            <span class="s1">name[</span><span class="s5">3</span><span class="s1">:] </span><span class="s3">in </span><span class="s1">renamed_variables):</span>

                            <span class="s1">name = name[</span><span class="s5">3</span><span class="s1">:]</span>
                            <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">done:</span>
                                <span class="s1">done[name] = value</span>

            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># bogus variable reference (e.g. &quot;prefix=$/opt/python&quot;);</span>
                <span class="s0"># just drop it since we can't deal</span>
                <span class="s1">done[name] = value</span>
                <span class="s1">variables.remove(name)</span>

    <span class="s0"># strip spurious spaces</span>
    <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">done.items():</span>
        <span class="s3">if </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">done[k] = v.strip()</span>

    <span class="s0"># save the results in the global dictionary</span>
    <span class="s1">vars.update(done)</span>
    <span class="s3">return </span><span class="s1">vars</span>


<span class="s3">def </span><span class="s1">get_makefile_filename():</span>
    <span class="s2">&quot;&quot;&quot;Return the path of the Makefile.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">_PYTHON_BUILD:</span>
        <span class="s3">return </span><span class="s1">os.path.join(_PROJECT_BASE</span><span class="s3">, </span><span class="s4">&quot;Makefile&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">hasattr(sys</span><span class="s3">, </span><span class="s4">'abiflags'</span><span class="s1">):</span>
        <span class="s1">config_dir_name = </span><span class="s4">'config-%s%s' </span><span class="s1">% (_PY_VERSION_SHORT</span><span class="s3">, </span><span class="s1">sys.abiflags)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">config_dir_name = </span><span class="s4">'config'</span>
    <span class="s3">return </span><span class="s1">os.path.join(get_path(</span><span class="s4">'stdlib'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">config_dir_name</span><span class="s3">, </span><span class="s4">'Makefile'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_init_posix(vars):</span>
    <span class="s2">&quot;&quot;&quot;Initialize the module as appropriate for POSIX systems.&quot;&quot;&quot;</span>
    <span class="s0"># load the installed Makefile:</span>
    <span class="s1">makefile = get_makefile_filename()</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">_parse_makefile(makefile</span><span class="s3">, </span><span class="s1">vars)</span>
    <span class="s3">except </span><span class="s1">IOError </span><span class="s3">as </span><span class="s1">e:</span>
        <span class="s1">msg = </span><span class="s4">&quot;invalid Python installation: unable to open %s&quot; </span><span class="s1">% makefile</span>
        <span class="s3">if </span><span class="s1">hasattr(e</span><span class="s3">, </span><span class="s4">&quot;strerror&quot;</span><span class="s1">):</span>
            <span class="s1">msg = msg + </span><span class="s4">&quot; (%s)&quot; </span><span class="s1">% e.strerror</span>
        <span class="s3">raise </span><span class="s1">IOError(msg)</span>
    <span class="s0"># load the installed pyconfig.h:</span>
    <span class="s1">config_h = get_config_h_filename()</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">with </span><span class="s1">open(config_h) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">parse_config_h(f</span><span class="s3">, </span><span class="s1">vars)</span>
    <span class="s3">except </span><span class="s1">IOError </span><span class="s3">as </span><span class="s1">e:</span>
        <span class="s1">msg = </span><span class="s4">&quot;invalid Python installation: unable to open %s&quot; </span><span class="s1">% config_h</span>
        <span class="s3">if </span><span class="s1">hasattr(e</span><span class="s3">, </span><span class="s4">&quot;strerror&quot;</span><span class="s1">):</span>
            <span class="s1">msg = msg + </span><span class="s4">&quot; (%s)&quot; </span><span class="s1">% e.strerror</span>
        <span class="s3">raise </span><span class="s1">IOError(msg)</span>
    <span class="s0"># On AIX, there are wrong paths to the linker scripts in the Makefile</span>
    <span class="s0"># -- these paths are relative to the Python source, but when installed</span>
    <span class="s0"># the scripts are in another directory.</span>
    <span class="s3">if </span><span class="s1">_PYTHON_BUILD:</span>
        <span class="s1">vars[</span><span class="s4">'LDSHARED'</span><span class="s1">] = vars[</span><span class="s4">'BLDSHARED'</span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">_init_non_posix(vars):</span>
    <span class="s2">&quot;&quot;&quot;Initialize the module as appropriate for NT&quot;&quot;&quot;</span>
    <span class="s0"># set basic install directories</span>
    <span class="s1">vars[</span><span class="s4">'LIBDEST'</span><span class="s1">] = get_path(</span><span class="s4">'stdlib'</span><span class="s1">)</span>
    <span class="s1">vars[</span><span class="s4">'BINLIBDEST'</span><span class="s1">] = get_path(</span><span class="s4">'platstdlib'</span><span class="s1">)</span>
    <span class="s1">vars[</span><span class="s4">'INCLUDEPY'</span><span class="s1">] = get_path(</span><span class="s4">'include'</span><span class="s1">)</span>
    <span class="s1">vars[</span><span class="s4">'SO'</span><span class="s1">] = </span><span class="s4">'.pyd'</span>
    <span class="s1">vars[</span><span class="s4">'EXE'</span><span class="s1">] = </span><span class="s4">'.exe'</span>
    <span class="s1">vars[</span><span class="s4">'VERSION'</span><span class="s1">] = _PY_VERSION_SHORT_NO_DOT</span>
    <span class="s1">vars[</span><span class="s4">'BINDIR'</span><span class="s1">] = os.path.dirname(_safe_realpath(sys.executable))</span>

<span class="s0">#</span>
<span class="s0"># public APIs</span>
<span class="s0">#</span>


<span class="s3">def </span><span class="s1">parse_config_h(fp</span><span class="s3">, </span><span class="s1">vars=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Parse a config.h-style file. 
 
    A dictionary containing name/value pairs is returned.  If an 
    optional dictionary is passed in as the second argument, it is 
    used instead of a new dictionary. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">vars </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">vars = {}</span>
    <span class="s1">define_rx = re.compile(</span><span class="s4">&quot;#define ([A-Z][A-Za-z0-9_]+) (.*)</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">undef_rx = re.compile(</span><span class="s4">&quot;/[*] #undef ([A-Z][A-Za-z0-9_]+) [*]/</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s3">while True</span><span class="s1">:</span>
        <span class="s1">line = fp.readline()</span>
        <span class="s3">if not </span><span class="s1">line:</span>
            <span class="s3">break</span>
        <span class="s1">m = define_rx.match(line)</span>
        <span class="s3">if </span><span class="s1">m:</span>
            <span class="s1">n</span><span class="s3">, </span><span class="s1">v = m.group(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">v = int(v)</span>
            <span class="s3">except </span><span class="s1">ValueError:</span>
                <span class="s3">pass</span>
            <span class="s1">vars[n] = v</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">m = undef_rx.match(line)</span>
            <span class="s3">if </span><span class="s1">m:</span>
                <span class="s1">vars[m.group(</span><span class="s5">1</span><span class="s1">)] = </span><span class="s5">0</span>
    <span class="s3">return </span><span class="s1">vars</span>


<span class="s3">def </span><span class="s1">get_config_h_filename():</span>
    <span class="s2">&quot;&quot;&quot;Return the path of pyconfig.h.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">_PYTHON_BUILD:</span>
        <span class="s3">if </span><span class="s1">os.name == </span><span class="s4">&quot;nt&quot;</span><span class="s1">:</span>
            <span class="s1">inc_dir = os.path.join(_PROJECT_BASE</span><span class="s3">, </span><span class="s4">&quot;PC&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">inc_dir = _PROJECT_BASE</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">inc_dir = get_path(</span><span class="s4">'platinclude'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">os.path.join(inc_dir</span><span class="s3">, </span><span class="s4">'pyconfig.h'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">get_scheme_names():</span>
    <span class="s2">&quot;&quot;&quot;Return a tuple containing the schemes names.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">tuple(sorted(_SCHEMES.sections()))</span>


<span class="s3">def </span><span class="s1">get_path_names():</span>
    <span class="s2">&quot;&quot;&quot;Return a tuple containing the paths names.&quot;&quot;&quot;</span>
    <span class="s0"># xxx see if we want a static list</span>
    <span class="s3">return </span><span class="s1">_SCHEMES.options(</span><span class="s4">'posix_prefix'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">get_paths(scheme=_get_default_scheme()</span><span class="s3">, </span><span class="s1">vars=</span><span class="s3">None, </span><span class="s1">expand=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return a mapping containing an install scheme. 
 
    ``scheme`` is the install scheme name. If not provided, it will 
    return the default scheme for the current platform. 
    &quot;&quot;&quot;</span>
    <span class="s1">_ensure_cfg_read()</span>
    <span class="s3">if </span><span class="s1">expand:</span>
        <span class="s3">return </span><span class="s1">_expand_vars(scheme</span><span class="s3">, </span><span class="s1">vars)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">dict(_SCHEMES.items(scheme))</span>


<span class="s3">def </span><span class="s1">get_path(name</span><span class="s3">, </span><span class="s1">scheme=_get_default_scheme()</span><span class="s3">, </span><span class="s1">vars=</span><span class="s3">None, </span><span class="s1">expand=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return a path corresponding to the scheme. 
 
    ``scheme`` is the install scheme name. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">get_paths(scheme</span><span class="s3">, </span><span class="s1">vars</span><span class="s3">, </span><span class="s1">expand)[name]</span>


<span class="s3">def </span><span class="s1">get_config_vars(*args):</span>
    <span class="s2">&quot;&quot;&quot;With no arguments, return a dictionary of all configuration 
    variables relevant for the current platform. 
 
    On Unix, this means every variable defined in Python's installed Makefile; 
    On Windows and Mac OS it's a much smaller set. 
 
    With arguments, return a list of values that result from looking up 
    each argument in the configuration variable dictionary. 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">_CONFIG_VARS</span>
    <span class="s3">if </span><span class="s1">_CONFIG_VARS </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">_CONFIG_VARS = {}</span>
        <span class="s0"># Normalized versions of prefix and exec_prefix are handy to have;</span>
        <span class="s0"># in fact, these are the standard versions used most places in the</span>
        <span class="s0"># distutils2 module.</span>
        <span class="s1">_CONFIG_VARS[</span><span class="s4">'prefix'</span><span class="s1">] = _PREFIX</span>
        <span class="s1">_CONFIG_VARS[</span><span class="s4">'exec_prefix'</span><span class="s1">] = _EXEC_PREFIX</span>
        <span class="s1">_CONFIG_VARS[</span><span class="s4">'py_version'</span><span class="s1">] = _PY_VERSION</span>
        <span class="s1">_CONFIG_VARS[</span><span class="s4">'py_version_short'</span><span class="s1">] = _PY_VERSION_SHORT</span>
        <span class="s1">_CONFIG_VARS[</span><span class="s4">'py_version_nodot'</span><span class="s1">] = _PY_VERSION[</span><span class="s5">0</span><span class="s1">] + _PY_VERSION[</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">_CONFIG_VARS[</span><span class="s4">'base'</span><span class="s1">] = _PREFIX</span>
        <span class="s1">_CONFIG_VARS[</span><span class="s4">'platbase'</span><span class="s1">] = _EXEC_PREFIX</span>
        <span class="s1">_CONFIG_VARS[</span><span class="s4">'projectbase'</span><span class="s1">] = _PROJECT_BASE</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">_CONFIG_VARS[</span><span class="s4">'abiflags'</span><span class="s1">] = sys.abiflags</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s0"># sys.abiflags may not be defined on all platforms.</span>
            <span class="s1">_CONFIG_VARS[</span><span class="s4">'abiflags'</span><span class="s1">] = </span><span class="s4">''</span>

        <span class="s3">if </span><span class="s1">os.name </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'nt'</span><span class="s3">, </span><span class="s4">'os2'</span><span class="s1">):</span>
            <span class="s1">_init_non_posix(_CONFIG_VARS)</span>
        <span class="s3">if </span><span class="s1">os.name == </span><span class="s4">'posix'</span><span class="s1">:</span>
            <span class="s1">_init_posix(_CONFIG_VARS)</span>
        <span class="s0"># Setting 'userbase' is done below the call to the</span>
        <span class="s0"># init function to enable using 'get_config_var' in</span>
        <span class="s0"># the init-function.</span>
        <span class="s3">if </span><span class="s1">sys.version &gt;= </span><span class="s4">'2.6'</span><span class="s1">:</span>
            <span class="s1">_CONFIG_VARS[</span><span class="s4">'userbase'</span><span class="s1">] = _getuserbase()</span>

        <span class="s3">if </span><span class="s4">'srcdir' </span><span class="s3">not in </span><span class="s1">_CONFIG_VARS:</span>
            <span class="s1">_CONFIG_VARS[</span><span class="s4">'srcdir'</span><span class="s1">] = _PROJECT_BASE</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_CONFIG_VARS[</span><span class="s4">'srcdir'</span><span class="s1">] = _safe_realpath(_CONFIG_VARS[</span><span class="s4">'srcdir'</span><span class="s1">])</span>

        <span class="s0"># Convert srcdir into an absolute path if it appears necessary.</span>
        <span class="s0"># Normally it is relative to the build directory.  However, during</span>
        <span class="s0"># testing, for example, we might be running a non-installed python</span>
        <span class="s0"># from a different directory.</span>
        <span class="s3">if </span><span class="s1">_PYTHON_BUILD </span><span class="s3">and </span><span class="s1">os.name == </span><span class="s4">&quot;posix&quot;</span><span class="s1">:</span>
            <span class="s1">base = _PROJECT_BASE</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">cwd = os.getcwd()</span>
            <span class="s3">except </span><span class="s1">OSError:</span>
                <span class="s1">cwd = </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">os.path.isabs(_CONFIG_VARS[</span><span class="s4">'srcdir'</span><span class="s1">]) </span><span class="s3">and</span>
                <span class="s1">base != cwd):</span>
                <span class="s0"># srcdir is relative and we are not in the same directory</span>
                <span class="s0"># as the executable. Assume executable is in the build</span>
                <span class="s0"># directory and make srcdir absolute.</span>
                <span class="s1">srcdir = os.path.join(base</span><span class="s3">, </span><span class="s1">_CONFIG_VARS[</span><span class="s4">'srcdir'</span><span class="s1">])</span>
                <span class="s1">_CONFIG_VARS[</span><span class="s4">'srcdir'</span><span class="s1">] = os.path.normpath(srcdir)</span>

        <span class="s3">if </span><span class="s1">sys.platform == </span><span class="s4">'darwin'</span><span class="s1">:</span>
            <span class="s1">kernel_version = os.uname()[</span><span class="s5">2</span><span class="s1">]  </span><span class="s0"># Kernel version (8.4.3)</span>
            <span class="s1">major_version = int(kernel_version.split(</span><span class="s4">'.'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">])</span>

            <span class="s3">if </span><span class="s1">major_version &lt; </span><span class="s5">8</span><span class="s1">:</span>
                <span class="s0"># On Mac OS X before 10.4, check if -arch and -isysroot</span>
                <span class="s0"># are in CFLAGS or LDFLAGS and remove them if they are.</span>
                <span class="s0"># This is needed when building extensions on a 10.3 system</span>
                <span class="s0"># using a universal build of python.</span>
                <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'LDFLAGS'</span><span class="s3">, </span><span class="s4">'BASECFLAGS'</span><span class="s3">,</span>
                        <span class="s0"># a number of derived variables. These need to be</span>
                        <span class="s0"># patched up as well.</span>
                        <span class="s4">'CFLAGS'</span><span class="s3">, </span><span class="s4">'PY_CFLAGS'</span><span class="s3">, </span><span class="s4">'BLDSHARED'</span><span class="s1">):</span>
                    <span class="s1">flags = _CONFIG_VARS[key]</span>
                    <span class="s1">flags = re.sub(</span><span class="s4">r'-arch\s+\w+\s'</span><span class="s3">, </span><span class="s4">' '</span><span class="s3">, </span><span class="s1">flags)</span>
                    <span class="s1">flags = re.sub(</span><span class="s4">'-isysroot [^ </span><span class="s3">\t</span><span class="s4">]*'</span><span class="s3">, </span><span class="s4">' '</span><span class="s3">, </span><span class="s1">flags)</span>
                    <span class="s1">_CONFIG_VARS[key] = flags</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># Allow the user to override the architecture flags using</span>
                <span class="s0"># an environment variable.</span>
                <span class="s0"># NOTE: This name was introduced by Apple in OSX 10.5 and</span>
                <span class="s0"># is used by several scripting languages distributed with</span>
                <span class="s0"># that OS release.</span>
                <span class="s3">if </span><span class="s4">'ARCHFLAGS' </span><span class="s3">in </span><span class="s1">os.environ:</span>
                    <span class="s1">arch = os.environ[</span><span class="s4">'ARCHFLAGS'</span><span class="s1">]</span>
                    <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'LDFLAGS'</span><span class="s3">, </span><span class="s4">'BASECFLAGS'</span><span class="s3">,</span>
                        <span class="s0"># a number of derived variables. These need to be</span>
                        <span class="s0"># patched up as well.</span>
                        <span class="s4">'CFLAGS'</span><span class="s3">, </span><span class="s4">'PY_CFLAGS'</span><span class="s3">, </span><span class="s4">'BLDSHARED'</span><span class="s1">):</span>

                        <span class="s1">flags = _CONFIG_VARS[key]</span>
                        <span class="s1">flags = re.sub(</span><span class="s4">r'-arch\s+\w+\s'</span><span class="s3">, </span><span class="s4">' '</span><span class="s3">, </span><span class="s1">flags)</span>
                        <span class="s1">flags = flags + </span><span class="s4">' ' </span><span class="s1">+ arch</span>
                        <span class="s1">_CONFIG_VARS[key] = flags</span>

                <span class="s0"># If we're on OSX 10.5 or later and the user tries to</span>
                <span class="s0"># compiles an extension using an SDK that is not present</span>
                <span class="s0"># on the current machine it is better to not use an SDK</span>
                <span class="s0"># than to fail.</span>
                <span class="s0">#</span>
                <span class="s0"># The major usecase for this is users using a Python.org</span>
                <span class="s0"># binary installer  on OSX 10.6: that installer uses</span>
                <span class="s0"># the 10.4u SDK, but that SDK is not installed by default</span>
                <span class="s0"># when you install Xcode.</span>
                <span class="s0">#</span>
                <span class="s1">CFLAGS = _CONFIG_VARS.get(</span><span class="s4">'CFLAGS'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
                <span class="s1">m = re.search(</span><span class="s4">r'-isysroot\s+(\S+)'</span><span class="s3">, </span><span class="s1">CFLAGS)</span>
                <span class="s3">if </span><span class="s1">m </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">sdk = m.group(</span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s3">if not </span><span class="s1">os.path.exists(sdk):</span>
                        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'LDFLAGS'</span><span class="s3">, </span><span class="s4">'BASECFLAGS'</span><span class="s3">,</span>
                             <span class="s0"># a number of derived variables. These need to be</span>
                             <span class="s0"># patched up as well.</span>
                            <span class="s4">'CFLAGS'</span><span class="s3">, </span><span class="s4">'PY_CFLAGS'</span><span class="s3">, </span><span class="s4">'BLDSHARED'</span><span class="s1">):</span>

                            <span class="s1">flags = _CONFIG_VARS[key]</span>
                            <span class="s1">flags = re.sub(</span><span class="s4">r'-isysroot\s+\S+(\s|$)'</span><span class="s3">, </span><span class="s4">' '</span><span class="s3">, </span><span class="s1">flags)</span>
                            <span class="s1">_CONFIG_VARS[key] = flags</span>

    <span class="s3">if </span><span class="s1">args:</span>
        <span class="s1">vals = []</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">args:</span>
            <span class="s1">vals.append(_CONFIG_VARS.get(name))</span>
        <span class="s3">return </span><span class="s1">vals</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_CONFIG_VARS</span>


<span class="s3">def </span><span class="s1">get_config_var(name):</span>
    <span class="s2">&quot;&quot;&quot;Return the value of a single variable using the dictionary returned by 
    'get_config_vars()'. 
 
    Equivalent to get_config_vars().get(name) 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">get_config_vars().get(name)</span>


<span class="s3">def </span><span class="s1">get_platform():</span>
    <span class="s2">&quot;&quot;&quot;Return a string that identifies the current platform. 
 
    This is used mainly to distinguish platform-specific build directories and 
    platform-specific built distributions.  Typically includes the OS name 
    and version and the architecture (as supplied by 'os.uname()'), 
    although the exact information included depends on the OS; eg. for IRIX 
    the architecture isn't particularly important (IRIX only runs on SGI 
    hardware), but for Linux the kernel version isn't particularly 
    important. 
 
    Examples of returned values: 
       linux-i586 
       linux-alpha (?) 
       solaris-2.6-sun4u 
       irix-5.3 
       irix64-6.2 
 
    Windows will return one of: 
       win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc) 
       win-ia64 (64bit Windows on Itanium) 
       win32 (all others - specifically, sys.platform is returned) 
 
    For other non-POSIX platforms, currently just returns 'sys.platform'. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">os.name == </span><span class="s4">'nt'</span><span class="s1">:</span>
        <span class="s0"># sniff sys.version for architecture.</span>
        <span class="s1">prefix = </span><span class="s4">&quot; bit (&quot;</span>
        <span class="s1">i = sys.version.find(prefix)</span>
        <span class="s3">if </span><span class="s1">i == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">sys.platform</span>
        <span class="s1">j = sys.version.find(</span><span class="s4">&quot;)&quot;</span><span class="s3">, </span><span class="s1">i)</span>
        <span class="s1">look = sys.version[i+len(prefix):j].lower()</span>
        <span class="s3">if </span><span class="s1">look == </span><span class="s4">'amd64'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">'win-amd64'</span>
        <span class="s3">if </span><span class="s1">look == </span><span class="s4">'itanium'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">'win-ia64'</span>
        <span class="s3">return </span><span class="s1">sys.platform</span>

    <span class="s3">if </span><span class="s1">os.name != </span><span class="s4">&quot;posix&quot; </span><span class="s3">or not </span><span class="s1">hasattr(os</span><span class="s3">, </span><span class="s4">'uname'</span><span class="s1">):</span>
        <span class="s0"># XXX what about the architecture? NT is Intel or Alpha,</span>
        <span class="s0"># Mac OS is M68k or PPC, etc.</span>
        <span class="s3">return </span><span class="s1">sys.platform</span>

    <span class="s0"># Try to distinguish various flavours of Unix</span>
    <span class="s1">osname</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">release</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">machine = os.uname()</span>

    <span class="s0"># Convert the OS name to lowercase, remove '/' characters</span>
    <span class="s0"># (to accommodate BSD/OS), and translate spaces (for &quot;Power Macintosh&quot;)</span>
    <span class="s1">osname = osname.lower().replace(</span><span class="s4">'/'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
    <span class="s1">machine = machine.replace(</span><span class="s4">' '</span><span class="s3">, </span><span class="s4">'_'</span><span class="s1">)</span>
    <span class="s1">machine = machine.replace(</span><span class="s4">'/'</span><span class="s3">, </span><span class="s4">'-'</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">osname[:</span><span class="s5">5</span><span class="s1">] == </span><span class="s4">&quot;linux&quot;</span><span class="s1">:</span>
        <span class="s0"># At least on Linux/Intel, 'machine' is the processor --</span>
        <span class="s0"># i386, etc.</span>
        <span class="s0"># XXX what about Alpha, SPARC, etc?</span>
        <span class="s3">return  </span><span class="s4">&quot;%s-%s&quot; </span><span class="s1">% (osname</span><span class="s3">, </span><span class="s1">machine)</span>
    <span class="s3">elif </span><span class="s1">osname[:</span><span class="s5">5</span><span class="s1">] == </span><span class="s4">&quot;sunos&quot;</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">release[</span><span class="s5">0</span><span class="s1">] &gt;= </span><span class="s4">&quot;5&quot;</span><span class="s1">:           </span><span class="s0"># SunOS 5 == Solaris 2</span>
            <span class="s1">osname = </span><span class="s4">&quot;solaris&quot;</span>
            <span class="s1">release = </span><span class="s4">&quot;%d.%s&quot; </span><span class="s1">% (int(release[</span><span class="s5">0</span><span class="s1">]) - </span><span class="s5">3</span><span class="s3">, </span><span class="s1">release[</span><span class="s5">2</span><span class="s1">:])</span>
        <span class="s0"># fall through to standard osname-release-machine representation</span>
    <span class="s3">elif </span><span class="s1">osname[:</span><span class="s5">4</span><span class="s1">] == </span><span class="s4">&quot;irix&quot;</span><span class="s1">:              </span><span class="s0"># could be &quot;irix64&quot;!</span>
        <span class="s3">return </span><span class="s4">&quot;%s-%s&quot; </span><span class="s1">% (osname</span><span class="s3">, </span><span class="s1">release)</span>
    <span class="s3">elif </span><span class="s1">osname[:</span><span class="s5">3</span><span class="s1">] == </span><span class="s4">&quot;aix&quot;</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s4">&quot;%s-%s.%s&quot; </span><span class="s1">% (osname</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">release)</span>
    <span class="s3">elif </span><span class="s1">osname[:</span><span class="s5">6</span><span class="s1">] == </span><span class="s4">&quot;cygwin&quot;</span><span class="s1">:</span>
        <span class="s1">osname = </span><span class="s4">&quot;cygwin&quot;</span>
        <span class="s1">rel_re = re.compile(</span><span class="s4">r'[\d.]+'</span><span class="s1">)</span>
        <span class="s1">m = rel_re.match(release)</span>
        <span class="s3">if </span><span class="s1">m:</span>
            <span class="s1">release = m.group()</span>
    <span class="s3">elif </span><span class="s1">osname[:</span><span class="s5">6</span><span class="s1">] == </span><span class="s4">&quot;darwin&quot;</span><span class="s1">:</span>
        <span class="s0">#</span>
        <span class="s0"># For our purposes, we'll assume that the system version from</span>
        <span class="s0"># distutils' perspective is what MACOSX_DEPLOYMENT_TARGET is set</span>
        <span class="s0"># to. This makes the compatibility story a bit more sane because the</span>
        <span class="s0"># machine is going to compile and link as if it were</span>
        <span class="s0"># MACOSX_DEPLOYMENT_TARGET.</span>
        <span class="s1">cfgvars = get_config_vars()</span>
        <span class="s1">macver = cfgvars.get(</span><span class="s4">'MACOSX_DEPLOYMENT_TARGET'</span><span class="s1">)</span>

        <span class="s3">if True</span><span class="s1">:</span>
            <span class="s0"># Always calculate the release of the running machine,</span>
            <span class="s0"># needed to determine if we can build fat binaries or not.</span>

            <span class="s1">macrelease = macver</span>
            <span class="s0"># Get the system version. Reading this plist is a documented</span>
            <span class="s0"># way to get the system version (see the documentation for</span>
            <span class="s0"># the Gestalt Manager)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">f = open(</span><span class="s4">'/System/Library/CoreServices/SystemVersion.plist'</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">IOError:</span>
                <span class="s0"># We're on a plain darwin box, fall back to the default</span>
                <span class="s0"># behaviour.</span>
                <span class="s3">pass</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">m = re.search(</span><span class="s4">r'&lt;key&gt;ProductUserVisibleVersion&lt;/key&gt;\s*'</span>
                                  <span class="s4">r'&lt;string&gt;(.*?)&lt;/string&gt;'</span><span class="s3">, </span><span class="s1">f.read())</span>
                <span class="s3">finally</span><span class="s1">:</span>
                    <span class="s1">f.close()</span>
                <span class="s3">if </span><span class="s1">m </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">macrelease = </span><span class="s4">'.'</span><span class="s1">.join(m.group(</span><span class="s5">1</span><span class="s1">).split(</span><span class="s4">'.'</span><span class="s1">)[:</span><span class="s5">2</span><span class="s1">])</span>
                <span class="s0"># else: fall back to the default behaviour</span>

        <span class="s3">if not </span><span class="s1">macver:</span>
            <span class="s1">macver = macrelease</span>

        <span class="s3">if </span><span class="s1">macver:</span>
            <span class="s1">release = macver</span>
            <span class="s1">osname = </span><span class="s4">&quot;macosx&quot;</span>

            <span class="s3">if </span><span class="s1">((macrelease + </span><span class="s4">'.'</span><span class="s1">) &gt;= </span><span class="s4">'10.4.' </span><span class="s3">and</span>
                <span class="s4">'-arch' </span><span class="s3">in </span><span class="s1">get_config_vars().get(</span><span class="s4">'CFLAGS'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">).strip()):</span>
                <span class="s0"># The universal build will build fat binaries, but not on</span>
                <span class="s0"># systems before 10.4</span>
                <span class="s0">#</span>
                <span class="s0"># Try to detect 4-way universal builds, those have machine-type</span>
                <span class="s0"># 'universal' instead of 'fat'.</span>

                <span class="s1">machine = </span><span class="s4">'fat'</span>
                <span class="s1">cflags = get_config_vars().get(</span><span class="s4">'CFLAGS'</span><span class="s1">)</span>

                <span class="s1">archs = re.findall(</span><span class="s4">r'-arch\s+(\S+)'</span><span class="s3">, </span><span class="s1">cflags)</span>
                <span class="s1">archs = tuple(sorted(set(archs)))</span>

                <span class="s3">if </span><span class="s1">len(archs) == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">machine = archs[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s3">elif </span><span class="s1">archs == (</span><span class="s4">'i386'</span><span class="s3">, </span><span class="s4">'ppc'</span><span class="s1">):</span>
                    <span class="s1">machine = </span><span class="s4">'fat'</span>
                <span class="s3">elif </span><span class="s1">archs == (</span><span class="s4">'i386'</span><span class="s3">, </span><span class="s4">'x86_64'</span><span class="s1">):</span>
                    <span class="s1">machine = </span><span class="s4">'intel'</span>
                <span class="s3">elif </span><span class="s1">archs == (</span><span class="s4">'i386'</span><span class="s3">, </span><span class="s4">'ppc'</span><span class="s3">, </span><span class="s4">'x86_64'</span><span class="s1">):</span>
                    <span class="s1">machine = </span><span class="s4">'fat3'</span>
                <span class="s3">elif </span><span class="s1">archs == (</span><span class="s4">'ppc64'</span><span class="s3">, </span><span class="s4">'x86_64'</span><span class="s1">):</span>
                    <span class="s1">machine = </span><span class="s4">'fat64'</span>
                <span class="s3">elif </span><span class="s1">archs == (</span><span class="s4">'i386'</span><span class="s3">, </span><span class="s4">'ppc'</span><span class="s3">, </span><span class="s4">'ppc64'</span><span class="s3">, </span><span class="s4">'x86_64'</span><span class="s1">):</span>
                    <span class="s1">machine = </span><span class="s4">'universal'</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span>
                       <span class="s4">&quot;Don't know machine value for archs=%r&quot; </span><span class="s1">% (archs</span><span class="s3">,</span><span class="s1">))</span>

            <span class="s3">elif </span><span class="s1">machine == </span><span class="s4">'i386'</span><span class="s1">:</span>
                <span class="s0"># On OSX the machine type returned by uname is always the</span>
                <span class="s0"># 32-bit variant, even if the executable architecture is</span>
                <span class="s0"># the 64-bit variant</span>
                <span class="s3">if </span><span class="s1">sys.maxsize &gt;= </span><span class="s5">2</span><span class="s1">**</span><span class="s5">32</span><span class="s1">:</span>
                    <span class="s1">machine = </span><span class="s4">'x86_64'</span>

            <span class="s3">elif </span><span class="s1">machine </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'PowerPC'</span><span class="s3">, </span><span class="s4">'Power_Macintosh'</span><span class="s1">):</span>
                <span class="s0"># Pick a sane name for the PPC architecture.</span>
                <span class="s0"># See 'i386' case</span>
                <span class="s3">if </span><span class="s1">sys.maxsize &gt;= </span><span class="s5">2</span><span class="s1">**</span><span class="s5">32</span><span class="s1">:</span>
                    <span class="s1">machine = </span><span class="s4">'ppc64'</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">machine = </span><span class="s4">'ppc'</span>

    <span class="s3">return </span><span class="s4">&quot;%s-%s-%s&quot; </span><span class="s1">% (osname</span><span class="s3">, </span><span class="s1">release</span><span class="s3">, </span><span class="s1">machine)</span>


<span class="s3">def </span><span class="s1">get_python_version():</span>
    <span class="s3">return </span><span class="s1">_PY_VERSION_SHORT</span>


<span class="s3">def </span><span class="s1">_print_dict(title</span><span class="s3">, </span><span class="s1">data):</span>
    <span class="s3">for </span><span class="s1">index</span><span class="s3">, </span><span class="s1">(key</span><span class="s3">, </span><span class="s1">value) </span><span class="s3">in </span><span class="s1">enumerate(sorted(data.items())):</span>
        <span class="s3">if </span><span class="s1">index == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">'%s: ' </span><span class="s1">% (title))</span>
        <span class="s1">print(</span><span class="s4">'</span><span class="s3">\t</span><span class="s4">%s = &quot;%s&quot;' </span><span class="s1">% (key</span><span class="s3">, </span><span class="s1">value))</span>


<span class="s3">def </span><span class="s1">_main():</span>
    <span class="s2">&quot;&quot;&quot;Display all information sysconfig detains.&quot;&quot;&quot;</span>
    <span class="s1">print(</span><span class="s4">'Platform: &quot;%s&quot;' </span><span class="s1">% get_platform())</span>
    <span class="s1">print(</span><span class="s4">'Python version: &quot;%s&quot;' </span><span class="s1">% get_python_version())</span>
    <span class="s1">print(</span><span class="s4">'Current installation scheme: &quot;%s&quot;' </span><span class="s1">% _get_default_scheme())</span>
    <span class="s1">print()</span>
    <span class="s1">_print_dict(</span><span class="s4">'Paths'</span><span class="s3">, </span><span class="s1">get_paths())</span>
    <span class="s1">print()</span>
    <span class="s1">_print_dict(</span><span class="s4">'Variables'</span><span class="s3">, </span><span class="s1">get_config_vars())</span>


<span class="s3">if </span><span class="s1">__name__ == </span><span class="s4">'__main__'</span><span class="s1">:</span>
    <span class="s1">_main()</span>
</pre>
</body>
</html>