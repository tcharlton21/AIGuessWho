<html>
<head>
<title>_make.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_make.py</font>
</center></td></tr></table>
<pre><span class="s0"># SPDX-License-Identifier: MIT</span>

<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">linecache</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">import </span><span class="s1">typing</span>

<span class="s2">from </span><span class="s1">operator </span><span class="s2">import </span><span class="s1">itemgetter</span>

<span class="s0"># We need to import _compat itself in addition to the _compat members to avoid</span>
<span class="s0"># having the thread-local in the globals here.</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">_compat</span><span class="s2">, </span><span class="s1">_config</span><span class="s2">, </span><span class="s1">setters</span>
<span class="s2">from </span><span class="s1">._compat </span><span class="s2">import </span><span class="s1">PY310</span><span class="s2">, </span><span class="s1">PYPY</span><span class="s2">, </span><span class="s1">_AnnotationExtractor</span><span class="s2">, </span><span class="s1">set_closure_cell</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DefaultAlreadySetError</span><span class="s2">,</span>
    <span class="s1">FrozenInstanceError</span><span class="s2">,</span>
    <span class="s1">NotAnAttrsClassError</span><span class="s2">,</span>
    <span class="s1">UnannotatedAttributeError</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s0"># This is used at least twice, so cache it here.</span>
<span class="s1">_obj_setattr = object.__setattr__</span>
<span class="s1">_init_converter_pat = </span><span class="s3">&quot;__attr_converter_%s&quot;</span>
<span class="s1">_init_factory_pat = </span><span class="s3">&quot;__attr_factory_%s&quot;</span>
<span class="s1">_classvar_prefixes = (</span>
    <span class="s3">&quot;typing.ClassVar&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;t.ClassVar&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;ClassVar&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;typing_extensions.ClassVar&quot;</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s0"># we don't use a double-underscore prefix because that triggers</span>
<span class="s0"># name mangling when trying to create a slot for the field</span>
<span class="s0"># (when slots=True)</span>
<span class="s1">_hash_cache_field = </span><span class="s3">&quot;_attrs_cached_hash&quot;</span>

<span class="s1">_empty_metadata_singleton = types.MappingProxyType({})</span>

<span class="s0"># Unique object for unequivocal getattr() defaults.</span>
<span class="s1">_sentinel = object()</span>

<span class="s1">_ng_default_on_setattr = setters.pipe(setters.convert</span><span class="s2">, </span><span class="s1">setters.validate)</span>


<span class="s2">class </span><span class="s1">_Nothing(enum.Enum):</span>
    <span class="s4">&quot;&quot;&quot; 
    Sentinel to indicate the lack of a value when ``None`` is ambiguous. 
 
    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show 
    that a value may be ``NOTHING``. 
 
    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False. 
    .. versionchanged:: 22.2.0 ``NOTHING`` is now an ``enum.Enum`` variant. 
    &quot;&quot;&quot;</span>

    <span class="s1">NOTHING = enum.auto()</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;NOTHING&quot;</span>

    <span class="s2">def </span><span class="s1">__bool__(self):</span>
        <span class="s2">return False</span>


<span class="s1">NOTHING = _Nothing.NOTHING</span>
<span class="s3">&quot;&quot;&quot; 
Sentinel to indicate the lack of a value when ``None`` is ambiguous. 
&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">_CacheHashWrapper(int):</span>
    <span class="s4">&quot;&quot;&quot; 
    An integer subclass that pickles / copies as None 
 
    This is used for non-slots classes with ``cache_hash=True``, to avoid 
    serializing a potentially (even likely) invalid hash value. Since ``None`` 
    is the default value for uncalculated hashes, whenever this is copied, 
    the copy's value for the hash should automatically reset. 
 
    See GH #613 for more details. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__reduce__(self</span><span class="s2">, </span><span class="s1">_none_constructor=type(</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_args=()):</span>
        <span class="s2">return </span><span class="s1">_none_constructor</span><span class="s2">, </span><span class="s1">_args</span>


<span class="s2">def </span><span class="s1">attrib(</span>
    <span class="s1">default=NOTHING</span><span class="s2">,</span>
    <span class="s1">validator=</span><span class="s2">None,</span>
    <span class="s1">repr=</span><span class="s2">True,</span>
    <span class="s1">cmp=</span><span class="s2">None,</span>
    <span class="s1">hash=</span><span class="s2">None,</span>
    <span class="s1">init=</span><span class="s2">True,</span>
    <span class="s1">metadata=</span><span class="s2">None,</span>
    <span class="s1">type=</span><span class="s2">None,</span>
    <span class="s1">converter=</span><span class="s2">None,</span>
    <span class="s1">factory=</span><span class="s2">None,</span>
    <span class="s1">kw_only=</span><span class="s2">False,</span>
    <span class="s1">eq=</span><span class="s2">None,</span>
    <span class="s1">order=</span><span class="s2">None,</span>
    <span class="s1">on_setattr=</span><span class="s2">None,</span>
    <span class="s1">alias=</span><span class="s2">None,</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Create a new attribute on a class. 
 
    ..  warning:: 
 
        Does *not* do anything unless the class is also decorated with 
        `attr.s`! 
 
    :param default: A value that is used if an ``attrs``-generated ``__init__`` 
        is used and no value is passed while instantiating or the attribute is 
        excluded using ``init=False``. 
 
        If the value is an instance of `attrs.Factory`, its callable will be 
        used to construct a new value (useful for mutable data types like lists 
        or dicts). 
 
        If a default is not set (or set manually to `attrs.NOTHING`), a value 
        *must* be supplied when instantiating; otherwise a `TypeError` 
        will be raised. 
 
        The default can also be set using decorator notation as shown below. 
 
    :type default: Any value 
 
    :param callable factory: Syntactic sugar for 
        ``default=attr.Factory(factory)``. 
 
    :param validator: `callable` that is called by ``attrs``-generated 
        ``__init__`` methods after the instance has been initialized.  They 
        receive the initialized instance, the :func:`~attrs.Attribute`, and the 
        passed value. 
 
        The return value is *not* inspected so the validator has to throw an 
        exception itself. 
 
        If a `list` is passed, its items are treated as validators and must 
        all pass. 
 
        Validators can be globally disabled and re-enabled using 
        `get_run_validators`. 
 
        The validator can also be set using decorator notation as shown below. 
 
    :type validator: `callable` or a `list` of `callable`\\ s. 
 
    :param repr: Include this attribute in the generated ``__repr__`` 
        method. If ``True``, include the attribute; if ``False``, omit it. By 
        default, the built-in ``repr()`` function is used. To override how the 
        attribute value is formatted, pass a ``callable`` that takes a single 
        value and returns a string. Note that the resulting string is used 
        as-is, i.e. it will be used directly *instead* of calling ``repr()`` 
        (the default). 
    :type repr: a `bool` or a `callable` to use a custom function. 
 
    :param eq: If ``True`` (default), include this attribute in the 
        generated ``__eq__`` and ``__ne__`` methods that check two instances 
        for equality. To override how the attribute value is compared, 
        pass a ``callable`` that takes a single value and returns the value 
        to be compared. 
    :type eq: a `bool` or a `callable`. 
 
    :param order: If ``True`` (default), include this attributes in the 
        generated ``__lt__``, ``__le__``, ``__gt__`` and ``__ge__`` methods. 
        To override how the attribute value is ordered, 
        pass a ``callable`` that takes a single value and returns the value 
        to be ordered. 
    :type order: a `bool` or a `callable`. 
 
    :param cmp: Setting *cmp* is equivalent to setting *eq* and *order* to the 
        same value. Must not be mixed with *eq* or *order*. 
    :type cmp: a `bool` or a `callable`. 
 
    :param Optional[bool] hash: Include this attribute in the generated 
        ``__hash__`` method.  If ``None`` (default), mirror *eq*'s value.  This 
        is the correct behavior according the Python spec.  Setting this value 
        to anything else than ``None`` is *discouraged*. 
    :param bool init: Include this attribute in the generated ``__init__`` 
        method.  It is possible to set this to ``False`` and set a default 
        value.  In that case this attributed is unconditionally initialized 
        with the specified default value or factory. 
    :param callable converter: `callable` that is called by 
        ``attrs``-generated ``__init__`` methods to convert attribute's value 
        to the desired format.  It is given the passed-in value, and the 
        returned value will be used as the new value of the attribute.  The 
        value is converted before being passed to the validator, if any. 
    :param metadata: An arbitrary mapping, to be used by third-party 
        components.  See `extending-metadata`. 
 
    :param type: The type of the attribute. Nowadays, the preferred method to 
        specify the type is using a variable annotation (see :pep:`526`). 
        This argument is provided for backward compatibility. 
        Regardless of the approach used, the type will be stored on 
        ``Attribute.type``. 
 
        Please note that ``attrs`` doesn't do anything with this metadata by 
        itself. You can use it as part of your own code or for 
        `static type checking &lt;types&gt;`. 
    :param kw_only: Make this attribute keyword-only in the generated 
        ``__init__`` (if ``init`` is ``False``, this parameter is ignored). 
    :param on_setattr: Allows to overwrite the *on_setattr* setting from 
        `attr.s`. If left `None`, the *on_setattr* value from `attr.s` is used. 
        Set to `attrs.setters.NO_OP` to run **no** `setattr` hooks for this 
        attribute -- regardless of the setting in `attr.s`. 
    :type on_setattr: `callable`, or a list of callables, or `None`, or 
        `attrs.setters.NO_OP` 
    :param Optional[str] alias: Override this attribute's parameter name in the 
        generated ``__init__`` method. If left `None`, default to ``name`` 
        stripped of leading underscores. See `private-attributes`. 
 
    .. versionadded:: 15.2.0 *convert* 
    .. versionadded:: 16.3.0 *metadata* 
    .. versionchanged:: 17.1.0 *validator* can be a ``list`` now. 
    .. versionchanged:: 17.1.0 
       *hash* is ``None`` and therefore mirrors *eq* by default. 
    .. versionadded:: 17.3.0 *type* 
    .. deprecated:: 17.4.0 *convert* 
    .. versionadded:: 17.4.0 *converter* as a replacement for the deprecated 
       *convert* to achieve consistency with other noun-based arguments. 
    .. versionadded:: 18.1.0 
       ``factory=f`` is syntactic sugar for ``default=attr.Factory(f)``. 
    .. versionadded:: 18.2.0 *kw_only* 
    .. versionchanged:: 19.2.0 *convert* keyword argument removed. 
    .. versionchanged:: 19.2.0 *repr* also accepts a custom callable. 
    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01. 
    .. versionadded:: 19.2.0 *eq* and *order* 
    .. versionadded:: 20.1.0 *on_setattr* 
    .. versionchanged:: 20.3.0 *kw_only* backported to Python 2 
    .. versionchanged:: 21.1.0 
       *eq*, *order*, and *cmp* also accept a custom callable 
    .. versionchanged:: 21.1.0 *cmp* undeprecated 
    .. versionadded:: 22.2.0 *alias* 
    &quot;&quot;&quot;</span>
    <span class="s1">eq</span><span class="s2">, </span><span class="s1">eq_key</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">order_key = _determine_attrib_eq_order(</span>
        <span class="s1">cmp</span><span class="s2">, </span><span class="s1">eq</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, True</span>
    <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">hash </span><span class="s2">is not None and </span><span class="s1">hash </span><span class="s2">is not True and </span><span class="s1">hash </span><span class="s2">is not False</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s3">&quot;Invalid value for hash.  Must be True, False, or None.&quot;</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">factory </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">default </span><span class="s2">is not </span><span class="s1">NOTHING:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;The `default` and `factory` arguments are mutually &quot;</span>
                <span class="s3">&quot;exclusive.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">callable(factory):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The `factory` argument must be a callable.&quot;</span><span class="s1">)</span>
        <span class="s1">default = Factory(factory)</span>

    <span class="s2">if </span><span class="s1">metadata </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">metadata = {}</span>

    <span class="s0"># Apply syntactic sugar by auto-wrapping.</span>
    <span class="s2">if </span><span class="s1">isinstance(on_setattr</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s1">on_setattr = setters.pipe(*on_setattr)</span>

    <span class="s2">if </span><span class="s1">validator </span><span class="s2">and </span><span class="s1">isinstance(validator</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s1">validator = and_(*validator)</span>

    <span class="s2">if </span><span class="s1">converter </span><span class="s2">and </span><span class="s1">isinstance(converter</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s1">converter = pipe(*converter)</span>

    <span class="s2">return </span><span class="s1">_CountingAttr(</span>
        <span class="s1">default=default</span><span class="s2">,</span>
        <span class="s1">validator=validator</span><span class="s2">,</span>
        <span class="s1">repr=repr</span><span class="s2">,</span>
        <span class="s1">cmp=</span><span class="s2">None,</span>
        <span class="s1">hash=hash</span><span class="s2">,</span>
        <span class="s1">init=init</span><span class="s2">,</span>
        <span class="s1">converter=converter</span><span class="s2">,</span>
        <span class="s1">metadata=metadata</span><span class="s2">,</span>
        <span class="s1">type=type</span><span class="s2">,</span>
        <span class="s1">kw_only=kw_only</span><span class="s2">,</span>
        <span class="s1">eq=eq</span><span class="s2">,</span>
        <span class="s1">eq_key=eq_key</span><span class="s2">,</span>
        <span class="s1">order=order</span><span class="s2">,</span>
        <span class="s1">order_key=order_key</span><span class="s2">,</span>
        <span class="s1">on_setattr=on_setattr</span><span class="s2">,</span>
        <span class="s1">alias=alias</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_compile_and_eval(script</span><span class="s2">, </span><span class="s1">globs</span><span class="s2">, </span><span class="s1">locs=</span><span class="s2">None, </span><span class="s1">filename=</span><span class="s3">&quot;&quot;</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    &quot;Exec&quot; the script with the given global (globs) and local (locs) variables. 
    &quot;&quot;&quot;</span>
    <span class="s1">bytecode = compile(script</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s3">&quot;exec&quot;</span><span class="s1">)</span>
    <span class="s1">eval(bytecode</span><span class="s2">, </span><span class="s1">globs</span><span class="s2">, </span><span class="s1">locs)</span>


<span class="s2">def </span><span class="s1">_make_method(name</span><span class="s2">, </span><span class="s1">script</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">globs):</span>
    <span class="s4">&quot;&quot;&quot; 
    Create the method with the script given and return the method object. 
    &quot;&quot;&quot;</span>
    <span class="s1">locs = {}</span>

    <span class="s0"># In order of debuggers like PDB being able to step through the code,</span>
    <span class="s0"># we add a fake linecache entry.</span>
    <span class="s1">count = </span><span class="s5">1</span>
    <span class="s1">base_filename = filename</span>
    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s1">linecache_tuple = (</span>
            <span class="s1">len(script)</span><span class="s2">,</span>
            <span class="s2">None,</span>
            <span class="s1">script.splitlines(</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">filename</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">old_val = linecache.cache.setdefault(filename</span><span class="s2">, </span><span class="s1">linecache_tuple)</span>
        <span class="s2">if </span><span class="s1">old_val == linecache_tuple:</span>
            <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">filename = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">base_filename[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">}</span><span class="s3">-</span><span class="s2">{</span><span class="s1">count</span><span class="s2">}</span><span class="s3">&gt;&quot;</span>
            <span class="s1">count += </span><span class="s5">1</span>

    <span class="s1">_compile_and_eval(script</span><span class="s2">, </span><span class="s1">globs</span><span class="s2">, </span><span class="s1">locs</span><span class="s2">, </span><span class="s1">filename)</span>

    <span class="s2">return </span><span class="s1">locs[name]</span>


<span class="s2">def </span><span class="s1">_make_attr_tuple_class(cls_name</span><span class="s2">, </span><span class="s1">attr_names):</span>
    <span class="s4">&quot;&quot;&quot; 
    Create a tuple subclass to hold `Attribute`s for an `attrs` class. 
 
    The subclass is a bare tuple with properties for names. 
 
    class MyClassAttributes(tuple): 
        __slots__ = () 
        x = property(itemgetter(0)) 
    &quot;&quot;&quot;</span>
    <span class="s1">attr_class_name = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">cls_name</span><span class="s2">}</span><span class="s3">Attributes&quot;</span>
    <span class="s1">attr_class_template = [</span>
        <span class="s3">f&quot;class </span><span class="s2">{</span><span class="s1">attr_class_name</span><span class="s2">}</span><span class="s3">(tuple):&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;    __slots__ = ()&quot;</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s2">if </span><span class="s1">attr_names:</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">attr_name </span><span class="s2">in </span><span class="s1">enumerate(attr_names):</span>
            <span class="s1">attr_class_template.append(</span>
                <span class="s3">f&quot;    </span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">} </span><span class="s3">= _attrs_property(_attrs_itemgetter(</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s3">))&quot;</span>
            <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">attr_class_template.append(</span><span class="s3">&quot;    pass&quot;</span><span class="s1">)</span>
    <span class="s1">globs = {</span><span class="s3">&quot;_attrs_itemgetter&quot;</span><span class="s1">: itemgetter</span><span class="s2">, </span><span class="s3">&quot;_attrs_property&quot;</span><span class="s1">: property}</span>
    <span class="s1">_compile_and_eval(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(attr_class_template)</span><span class="s2">, </span><span class="s1">globs)</span>
    <span class="s2">return </span><span class="s1">globs[attr_class_name]</span>


<span class="s0"># Tuple class for extracted attributes from a class definition.</span>
<span class="s0"># `base_attrs` is a subset of `attrs`.</span>
<span class="s1">_Attributes = _make_attr_tuple_class(</span>
    <span class="s3">&quot;_Attributes&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s0"># all attributes to build dunder methods for</span>
        <span class="s3">&quot;attrs&quot;</span><span class="s2">,</span>
        <span class="s0"># attributes that have been inherited</span>
        <span class="s3">&quot;base_attrs&quot;</span><span class="s2">,</span>
        <span class="s0"># map inherited attributes to their originating classes</span>
        <span class="s3">&quot;base_attrs_map&quot;</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">_is_class_var(annot):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check whether *annot* is a typing.ClassVar. 
 
    The string comparison hack is used to avoid evaluating all string 
    annotations which would put attrs-based classes at a performance 
    disadvantage compared to plain old classes. 
    &quot;&quot;&quot;</span>
    <span class="s1">annot = str(annot)</span>

    <span class="s0"># Annotation can be quoted.</span>
    <span class="s2">if </span><span class="s1">annot.startswith((</span><span class="s3">&quot;'&quot;</span><span class="s2">, </span><span class="s3">'&quot;'</span><span class="s1">)) </span><span class="s2">and </span><span class="s1">annot.endswith((</span><span class="s3">&quot;'&quot;</span><span class="s2">, </span><span class="s3">'&quot;'</span><span class="s1">)):</span>
        <span class="s1">annot = annot[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">return </span><span class="s1">annot.startswith(_classvar_prefixes)</span>


<span class="s2">def </span><span class="s1">_has_own_attribute(cls</span><span class="s2">, </span><span class="s1">attrib_name):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check whether *cls* defines *attrib_name* (and doesn't just inherit it). 
    &quot;&quot;&quot;</span>
    <span class="s1">attr = getattr(cls</span><span class="s2">, </span><span class="s1">attrib_name</span><span class="s2">, </span><span class="s1">_sentinel)</span>
    <span class="s2">if </span><span class="s1">attr </span><span class="s2">is </span><span class="s1">_sentinel:</span>
        <span class="s2">return False</span>

    <span class="s2">for </span><span class="s1">base_cls </span><span class="s2">in </span><span class="s1">cls.__mro__[</span><span class="s5">1</span><span class="s1">:]:</span>
        <span class="s1">a = getattr(base_cls</span><span class="s2">, </span><span class="s1">attrib_name</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">attr </span><span class="s2">is </span><span class="s1">a:</span>
            <span class="s2">return False</span>

    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">_get_annotations(cls):</span>
    <span class="s4">&quot;&quot;&quot; 
    Get annotations for *cls*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_has_own_attribute(cls</span><span class="s2">, </span><span class="s3">&quot;__annotations__&quot;</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">cls.__annotations__</span>

    <span class="s2">return </span><span class="s1">{}</span>


<span class="s2">def </span><span class="s1">_collect_base_attrs(cls</span><span class="s2">, </span><span class="s1">taken_attr_names):</span>
    <span class="s4">&quot;&quot;&quot; 
    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*. 
    &quot;&quot;&quot;</span>
    <span class="s1">base_attrs = []</span>
    <span class="s1">base_attr_map = {}  </span><span class="s0"># A dictionary of base attrs to their classes.</span>

    <span class="s0"># Traverse the MRO and collect attributes.</span>
    <span class="s2">for </span><span class="s1">base_cls </span><span class="s2">in </span><span class="s1">reversed(cls.__mro__[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]):</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">getattr(base_cls</span><span class="s2">, </span><span class="s3">&quot;__attrs_attrs__&quot;</span><span class="s2">, </span><span class="s1">[]):</span>
            <span class="s2">if </span><span class="s1">a.inherited </span><span class="s2">or </span><span class="s1">a.name </span><span class="s2">in </span><span class="s1">taken_attr_names:</span>
                <span class="s2">continue</span>

            <span class="s1">a = a.evolve(inherited=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">base_attrs.append(a)</span>
            <span class="s1">base_attr_map[a.name] = base_cls</span>

    <span class="s0"># For each name, only keep the freshest definition i.e. the furthest at the</span>
    <span class="s0"># back.  base_attr_map is fine because it gets overwritten with every new</span>
    <span class="s0"># instance.</span>
    <span class="s1">filtered = []</span>
    <span class="s1">seen = set()</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">reversed(base_attrs):</span>
        <span class="s2">if </span><span class="s1">a.name </span><span class="s2">in </span><span class="s1">seen:</span>
            <span class="s2">continue</span>
        <span class="s1">filtered.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">seen.add(a.name)</span>

    <span class="s2">return </span><span class="s1">filtered</span><span class="s2">, </span><span class="s1">base_attr_map</span>


<span class="s2">def </span><span class="s1">_collect_base_attrs_broken(cls</span><span class="s2">, </span><span class="s1">taken_attr_names):</span>
    <span class="s4">&quot;&quot;&quot; 
    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*. 
 
    N.B. *taken_attr_names* will be mutated. 
 
    Adhere to the old incorrect behavior. 
 
    Notably it collects from the front and considers inherited attributes which 
    leads to the buggy behavior reported in #428. 
    &quot;&quot;&quot;</span>
    <span class="s1">base_attrs = []</span>
    <span class="s1">base_attr_map = {}  </span><span class="s0"># A dictionary of base attrs to their classes.</span>

    <span class="s0"># Traverse the MRO and collect attributes.</span>
    <span class="s2">for </span><span class="s1">base_cls </span><span class="s2">in </span><span class="s1">cls.__mro__[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">getattr(base_cls</span><span class="s2">, </span><span class="s3">&quot;__attrs_attrs__&quot;</span><span class="s2">, </span><span class="s1">[]):</span>
            <span class="s2">if </span><span class="s1">a.name </span><span class="s2">in </span><span class="s1">taken_attr_names:</span>
                <span class="s2">continue</span>

            <span class="s1">a = a.evolve(inherited=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">taken_attr_names.add(a.name)</span>
            <span class="s1">base_attrs.append(a)</span>
            <span class="s1">base_attr_map[a.name] = base_cls</span>

    <span class="s2">return </span><span class="s1">base_attrs</span><span class="s2">, </span><span class="s1">base_attr_map</span>


<span class="s2">def </span><span class="s1">_transform_attrs(</span>
    <span class="s1">cls</span><span class="s2">, </span><span class="s1">these</span><span class="s2">, </span><span class="s1">auto_attribs</span><span class="s2">, </span><span class="s1">kw_only</span><span class="s2">, </span><span class="s1">collect_by_mro</span><span class="s2">, </span><span class="s1">field_transformer</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Transform all `_CountingAttr`s on a class into `Attribute`s. 
 
    If *these* is passed, use that and don't look for them on the class. 
 
    *collect_by_mro* is True, collect them in the correct MRO order, otherwise 
    use the old -- incorrect -- order.  See #428. 
 
    Return an `_Attributes`. 
    &quot;&quot;&quot;</span>
    <span class="s1">cd = cls.__dict__</span>
    <span class="s1">anns = _get_annotations(cls)</span>

    <span class="s2">if </span><span class="s1">these </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">ca_list = [(name</span><span class="s2">, </span><span class="s1">ca) </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">ca </span><span class="s2">in </span><span class="s1">these.items()]</span>
    <span class="s2">elif </span><span class="s1">auto_attribs </span><span class="s2">is True</span><span class="s1">:</span>
        <span class="s1">ca_names = {</span>
            <span class="s1">name</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">cd.items()</span>
            <span class="s2">if </span><span class="s1">isinstance(attr</span><span class="s2">, </span><span class="s1">_CountingAttr)</span>
        <span class="s1">}</span>
        <span class="s1">ca_list = []</span>
        <span class="s1">annot_names = set()</span>
        <span class="s2">for </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">type </span><span class="s2">in </span><span class="s1">anns.items():</span>
            <span class="s2">if </span><span class="s1">_is_class_var(type):</span>
                <span class="s2">continue</span>
            <span class="s1">annot_names.add(attr_name)</span>
            <span class="s1">a = cd.get(attr_name</span><span class="s2">, </span><span class="s1">NOTHING)</span>

            <span class="s2">if not </span><span class="s1">isinstance(a</span><span class="s2">, </span><span class="s1">_CountingAttr):</span>
                <span class="s2">if </span><span class="s1">a </span><span class="s2">is </span><span class="s1">NOTHING:</span>
                    <span class="s1">a = attrib()</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">a = attrib(default=a)</span>
            <span class="s1">ca_list.append((attr_name</span><span class="s2">, </span><span class="s1">a))</span>

        <span class="s1">unannotated = ca_names - annot_names</span>
        <span class="s2">if </span><span class="s1">len(unannotated) &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">UnannotatedAttributeError(</span>
                <span class="s3">&quot;The following `attr.ib`s lack a type annotation: &quot;</span>
                <span class="s1">+ </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(</span>
                    <span class="s1">sorted(unannotated</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">n: cd.get(n).counter)</span>
                <span class="s1">)</span>
                <span class="s1">+ </span><span class="s3">&quot;.&quot;</span>
            <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">ca_list = sorted(</span>
            <span class="s1">(</span>
                <span class="s1">(name</span><span class="s2">, </span><span class="s1">attr)</span>
                <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">cd.items()</span>
                <span class="s2">if </span><span class="s1">isinstance(attr</span><span class="s2">, </span><span class="s1">_CountingAttr)</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">key=</span><span class="s2">lambda </span><span class="s1">e: e[</span><span class="s5">1</span><span class="s1">].counter</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">own_attrs = [</span>
        <span class="s1">Attribute.from_counting_attr(</span>
            <span class="s1">name=attr_name</span><span class="s2">, </span><span class="s1">ca=ca</span><span class="s2">, </span><span class="s1">type=anns.get(attr_name)</span>
        <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">ca </span><span class="s2">in </span><span class="s1">ca_list</span>
    <span class="s1">]</span>

    <span class="s2">if </span><span class="s1">collect_by_mro:</span>
        <span class="s1">base_attrs</span><span class="s2">, </span><span class="s1">base_attr_map = _collect_base_attrs(</span>
            <span class="s1">cls</span><span class="s2">, </span><span class="s1">{a.name </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">own_attrs}</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">base_attrs</span><span class="s2">, </span><span class="s1">base_attr_map = _collect_base_attrs_broken(</span>
            <span class="s1">cls</span><span class="s2">, </span><span class="s1">{a.name </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">own_attrs}</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">kw_only:</span>
        <span class="s1">own_attrs = [a.evolve(kw_only=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">own_attrs]</span>
        <span class="s1">base_attrs = [a.evolve(kw_only=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">base_attrs]</span>

    <span class="s1">attrs = base_attrs + own_attrs</span>

    <span class="s0"># Mandatory vs non-mandatory attr order only matters when they are part of</span>
    <span class="s0"># the __init__ signature and when they aren't kw_only (which are moved to</span>
    <span class="s0"># the end and can be mandatory or non-mandatory in any order, as they will</span>
    <span class="s0"># be specified as keyword args anyway). Check the order of those attrs:</span>
    <span class="s1">had_default = </span><span class="s2">False</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">(a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs </span><span class="s2">if </span><span class="s1">a.init </span><span class="s2">is not False and </span><span class="s1">a.kw_only </span><span class="s2">is False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">had_default </span><span class="s2">is True and </span><span class="s1">a.default </span><span class="s2">is </span><span class="s1">NOTHING:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;No mandatory attributes allowed after an attribute with a &quot;</span>
                <span class="s3">f&quot;default value or factory.  Attribute in question: </span><span class="s2">{</span><span class="s1">a</span><span class="s2">!r}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">had_default </span><span class="s2">is False and </span><span class="s1">a.default </span><span class="s2">is not </span><span class="s1">NOTHING:</span>
            <span class="s1">had_default = </span><span class="s2">True</span>

    <span class="s2">if </span><span class="s1">field_transformer </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">attrs = field_transformer(cls</span><span class="s2">, </span><span class="s1">attrs)</span>

    <span class="s0"># Resolve default field alias after executing field_transformer.</span>
    <span class="s0"># This allows field_transformer to differentiate between explicit vs</span>
    <span class="s0"># default aliases and supply their own defaults.</span>
    <span class="s1">attrs = [</span>
        <span class="s1">a.evolve(alias=_default_init_alias_for(a.name)) </span><span class="s2">if not </span><span class="s1">a.alias </span><span class="s2">else </span><span class="s1">a</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span>
    <span class="s1">]</span>

    <span class="s0"># Create AttrsClass *after* applying the field_transformer since it may</span>
    <span class="s0"># add or remove attributes!</span>
    <span class="s1">attr_names = [a.name </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs]</span>
    <span class="s1">AttrsClass = _make_attr_tuple_class(cls.__name__</span><span class="s2">, </span><span class="s1">attr_names)</span>

    <span class="s2">return </span><span class="s1">_Attributes((AttrsClass(attrs)</span><span class="s2">, </span><span class="s1">base_attrs</span><span class="s2">, </span><span class="s1">base_attr_map))</span>


<span class="s2">if </span><span class="s1">PYPY:</span>

    <span class="s2">def </span><span class="s1">_frozen_setattrs(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s4">&quot;&quot;&quot; 
        Attached to frozen classes as __setattr__. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(self</span><span class="s2">, </span><span class="s1">BaseException) </span><span class="s2">and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(</span>
            <span class="s3">&quot;__cause__&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;__context__&quot;</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s1">BaseException.__setattr__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value)</span>
            <span class="s2">return</span>

        <span class="s2">raise </span><span class="s1">FrozenInstanceError()</span>

<span class="s2">else</span><span class="s1">:</span>

    <span class="s2">def </span><span class="s1">_frozen_setattrs(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s4">&quot;&quot;&quot; 
        Attached to frozen classes as __setattr__. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">FrozenInstanceError()</span>


<span class="s2">def </span><span class="s1">_frozen_delattrs(self</span><span class="s2">, </span><span class="s1">name):</span>
    <span class="s4">&quot;&quot;&quot; 
    Attached to frozen classes as __delattr__. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">FrozenInstanceError()</span>


<span class="s2">class </span><span class="s1">_ClassBuilder:</span>
    <span class="s4">&quot;&quot;&quot; 
    Iteratively build *one* class. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span>
        <span class="s3">&quot;_attr_names&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_attrs&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_base_attr_map&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_base_names&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_cache_hash&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_cls&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_cls_dict&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_delete_attribs&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_frozen&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_has_pre_init&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_has_post_init&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_is_exc&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_on_setattr&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_slots&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_weakref_slot&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_wrote_own_setattr&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_has_custom_setattr&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">these</span><span class="s2">,</span>
        <span class="s1">slots</span><span class="s2">,</span>
        <span class="s1">frozen</span><span class="s2">,</span>
        <span class="s1">weakref_slot</span><span class="s2">,</span>
        <span class="s1">getstate_setstate</span><span class="s2">,</span>
        <span class="s1">auto_attribs</span><span class="s2">,</span>
        <span class="s1">kw_only</span><span class="s2">,</span>
        <span class="s1">cache_hash</span><span class="s2">,</span>
        <span class="s1">is_exc</span><span class="s2">,</span>
        <span class="s1">collect_by_mro</span><span class="s2">,</span>
        <span class="s1">on_setattr</span><span class="s2">,</span>
        <span class="s1">has_custom_setattr</span><span class="s2">,</span>
        <span class="s1">field_transformer</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">attrs</span><span class="s2">, </span><span class="s1">base_attrs</span><span class="s2">, </span><span class="s1">base_map = _transform_attrs(</span>
            <span class="s1">cls</span><span class="s2">,</span>
            <span class="s1">these</span><span class="s2">,</span>
            <span class="s1">auto_attribs</span><span class="s2">,</span>
            <span class="s1">kw_only</span><span class="s2">,</span>
            <span class="s1">collect_by_mro</span><span class="s2">,</span>
            <span class="s1">field_transformer</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">self._cls = cls</span>
        <span class="s1">self._cls_dict = dict(cls.__dict__) </span><span class="s2">if </span><span class="s1">slots </span><span class="s2">else </span><span class="s1">{}</span>
        <span class="s1">self._attrs = attrs</span>
        <span class="s1">self._base_names = {a.name </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">base_attrs}</span>
        <span class="s1">self._base_attr_map = base_map</span>
        <span class="s1">self._attr_names = tuple(a.name </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs)</span>
        <span class="s1">self._slots = slots</span>
        <span class="s1">self._frozen = frozen</span>
        <span class="s1">self._weakref_slot = weakref_slot</span>
        <span class="s1">self._cache_hash = cache_hash</span>
        <span class="s1">self._has_pre_init = bool(getattr(cls</span><span class="s2">, </span><span class="s3">&quot;__attrs_pre_init__&quot;</span><span class="s2">, False</span><span class="s1">))</span>
        <span class="s1">self._has_post_init = bool(getattr(cls</span><span class="s2">, </span><span class="s3">&quot;__attrs_post_init__&quot;</span><span class="s2">, False</span><span class="s1">))</span>
        <span class="s1">self._delete_attribs = </span><span class="s2">not </span><span class="s1">bool(these)</span>
        <span class="s1">self._is_exc = is_exc</span>
        <span class="s1">self._on_setattr = on_setattr</span>

        <span class="s1">self._has_custom_setattr = has_custom_setattr</span>
        <span class="s1">self._wrote_own_setattr = </span><span class="s2">False</span>

        <span class="s1">self._cls_dict[</span><span class="s3">&quot;__attrs_attrs__&quot;</span><span class="s1">] = self._attrs</span>

        <span class="s2">if </span><span class="s1">frozen:</span>
            <span class="s1">self._cls_dict[</span><span class="s3">&quot;__setattr__&quot;</span><span class="s1">] = _frozen_setattrs</span>
            <span class="s1">self._cls_dict[</span><span class="s3">&quot;__delattr__&quot;</span><span class="s1">] = _frozen_delattrs</span>

            <span class="s1">self._wrote_own_setattr = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">on_setattr </span><span class="s2">in </span><span class="s1">(</span>
            <span class="s1">_ng_default_on_setattr</span><span class="s2">,</span>
            <span class="s1">setters.validate</span><span class="s2">,</span>
            <span class="s1">setters.convert</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s1">has_validator = has_converter = </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs:</span>
                <span class="s2">if </span><span class="s1">a.validator </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">has_validator = </span><span class="s2">True</span>
                <span class="s2">if </span><span class="s1">a.converter </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">has_converter = </span><span class="s2">True</span>

                <span class="s2">if </span><span class="s1">has_validator </span><span class="s2">and </span><span class="s1">has_converter:</span>
                    <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">(</span>
                    <span class="s1">on_setattr == _ng_default_on_setattr</span>
                    <span class="s2">and not </span><span class="s1">(has_validator </span><span class="s2">or </span><span class="s1">has_converter)</span>
                <span class="s1">)</span>
                <span class="s2">or </span><span class="s1">(on_setattr == setters.validate </span><span class="s2">and not </span><span class="s1">has_validator)</span>
                <span class="s2">or </span><span class="s1">(on_setattr == setters.convert </span><span class="s2">and not </span><span class="s1">has_converter)</span>
            <span class="s1">):</span>
                <span class="s0"># If class-level on_setattr is set to convert + validate, but</span>
                <span class="s0"># there's no field to convert or validate, pretend like there's</span>
                <span class="s0"># no on_setattr.</span>
                <span class="s1">self._on_setattr = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">getstate_setstate:</span>
            <span class="s1">(</span>
                <span class="s1">self._cls_dict[</span><span class="s3">&quot;__getstate__&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">self._cls_dict[</span><span class="s3">&quot;__setstate__&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">) = self._make_getstate_setstate()</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s3">f&quot;&lt;_ClassBuilder(cls=</span><span class="s2">{</span><span class="s1">self._cls.__name__</span><span class="s2">}</span><span class="s3">)&gt;&quot;</span>

    <span class="s2">if </span><span class="s1">PY310:</span>
        <span class="s2">import </span><span class="s1">abc</span>

        <span class="s2">def </span><span class="s1">build_class(self):</span>
            <span class="s4">&quot;&quot;&quot; 
            Finalize class based on the accumulated configuration. 
 
            Builder cannot be used after calling this method. 
            &quot;&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">self._slots </span><span class="s2">is True</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._create_slots_class()</span>

            <span class="s2">return </span><span class="s1">self.abc.update_abstractmethods(</span>
                <span class="s1">self._patch_original_class()</span>
            <span class="s1">)</span>

    <span class="s2">else</span><span class="s1">:</span>

        <span class="s2">def </span><span class="s1">build_class(self):</span>
            <span class="s4">&quot;&quot;&quot; 
            Finalize class based on the accumulated configuration. 
 
            Builder cannot be used after calling this method. 
            &quot;&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">self._slots </span><span class="s2">is True</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._create_slots_class()</span>

            <span class="s2">return </span><span class="s1">self._patch_original_class()</span>

    <span class="s2">def </span><span class="s1">_patch_original_class(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Apply accumulated methods and return the class. 
        &quot;&quot;&quot;</span>
        <span class="s1">cls = self._cls</span>
        <span class="s1">base_names = self._base_names</span>

        <span class="s0"># Clean class of attribute definitions (`attr.ib()`s).</span>
        <span class="s2">if </span><span class="s1">self._delete_attribs:</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._attr_names:</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">name </span><span class="s2">not in </span><span class="s1">base_names</span>
                    <span class="s2">and </span><span class="s1">getattr(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">_sentinel) </span><span class="s2">is not </span><span class="s1">_sentinel</span>
                <span class="s1">):</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">delattr(cls</span><span class="s2">, </span><span class="s1">name)</span>
                    <span class="s2">except </span><span class="s1">AttributeError:</span>
                        <span class="s0"># This can happen if a base class defines a class</span>
                        <span class="s0"># variable and we want to set an attribute with the</span>
                        <span class="s0"># same name by using only a type annotation.</span>
                        <span class="s2">pass</span>

        <span class="s0"># Attach our dunder methods.</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self._cls_dict.items():</span>
            <span class="s1">setattr(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value)</span>

        <span class="s0"># If we've inherited an attrs __setattr__ and don't write our own,</span>
        <span class="s0"># reset it to object's.</span>
        <span class="s2">if not </span><span class="s1">self._wrote_own_setattr </span><span class="s2">and </span><span class="s1">getattr(</span>
            <span class="s1">cls</span><span class="s2">, </span><span class="s3">&quot;__attrs_own_setattr__&quot;</span><span class="s2">, False</span>
        <span class="s1">):</span>
            <span class="s1">cls.__attrs_own_setattr__ = </span><span class="s2">False</span>

            <span class="s2">if not </span><span class="s1">self._has_custom_setattr:</span>
                <span class="s1">cls.__setattr__ = _obj_setattr</span>

        <span class="s2">return </span><span class="s1">cls</span>

    <span class="s2">def </span><span class="s1">_create_slots_class(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Build and return a new class with a `__slots__` attribute. 
        &quot;&quot;&quot;</span>
        <span class="s1">cd = {</span>
            <span class="s1">k: v</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self._cls_dict.items()</span>
            <span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">tuple(self._attr_names) + (</span><span class="s3">&quot;__dict__&quot;</span><span class="s2">, </span><span class="s3">&quot;__weakref__&quot;</span><span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s0"># If our class doesn't have its own implementation of __setattr__</span>
        <span class="s0"># (either from the user or by us), check the bases, if one of them has</span>
        <span class="s0"># an attrs-made __setattr__, that needs to be reset. We don't walk the</span>
        <span class="s0"># MRO because we only care about our immediate base classes.</span>
        <span class="s0"># XXX: This can be confused by subclassing a slotted attrs class with</span>
        <span class="s0"># XXX: a non-attrs class and subclass the resulting class with an attrs</span>
        <span class="s0"># XXX: class.  See `test_slotted_confused` for details.  For now that's</span>
        <span class="s0"># XXX: OK with us.</span>
        <span class="s2">if not </span><span class="s1">self._wrote_own_setattr:</span>
            <span class="s1">cd[</span><span class="s3">&quot;__attrs_own_setattr__&quot;</span><span class="s1">] = </span><span class="s2">False</span>

            <span class="s2">if not </span><span class="s1">self._has_custom_setattr:</span>
                <span class="s2">for </span><span class="s1">base_cls </span><span class="s2">in </span><span class="s1">self._cls.__bases__:</span>
                    <span class="s2">if </span><span class="s1">base_cls.__dict__.get(</span><span class="s3">&quot;__attrs_own_setattr__&quot;</span><span class="s2">, False</span><span class="s1">):</span>
                        <span class="s1">cd[</span><span class="s3">&quot;__setattr__&quot;</span><span class="s1">] = _obj_setattr</span>
                        <span class="s2">break</span>

        <span class="s0"># Traverse the MRO to collect existing slots</span>
        <span class="s0"># and check for an existing __weakref__.</span>
        <span class="s1">existing_slots = dict()</span>
        <span class="s1">weakref_inherited = </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">base_cls </span><span class="s2">in </span><span class="s1">self._cls.__mro__[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">base_cls.__dict__.get(</span><span class="s3">&quot;__weakref__&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">weakref_inherited = </span><span class="s2">True</span>
            <span class="s1">existing_slots.update(</span>
                <span class="s1">{</span>
                    <span class="s1">name: getattr(base_cls</span><span class="s2">, </span><span class="s1">name)</span>
                    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">getattr(base_cls</span><span class="s2">, </span><span class="s3">&quot;__slots__&quot;</span><span class="s2">, </span><span class="s1">[])</span>
                <span class="s1">}</span>
            <span class="s1">)</span>

        <span class="s1">base_names = set(self._base_names)</span>

        <span class="s1">names = self._attr_names</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self._weakref_slot</span>
            <span class="s2">and </span><span class="s3">&quot;__weakref__&quot; </span><span class="s2">not in </span><span class="s1">getattr(self._cls</span><span class="s2">, </span><span class="s3">&quot;__slots__&quot;</span><span class="s2">, </span><span class="s1">())</span>
            <span class="s2">and </span><span class="s3">&quot;__weakref__&quot; </span><span class="s2">not in </span><span class="s1">names</span>
            <span class="s2">and not </span><span class="s1">weakref_inherited</span>
        <span class="s1">):</span>
            <span class="s1">names += (</span><span class="s3">&quot;__weakref__&quot;</span><span class="s2">,</span><span class="s1">)</span>

        <span class="s0"># We only add the names of attributes that aren't inherited.</span>
        <span class="s0"># Setting __slots__ to inherited attributes wastes memory.</span>
        <span class="s1">slot_names = [name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names </span><span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">base_names]</span>
        <span class="s0"># There are slots for attributes from current class</span>
        <span class="s0"># that are defined in parent classes.</span>
        <span class="s0"># As their descriptors may be overridden by a child class,</span>
        <span class="s0"># we collect them here and update the class dict</span>
        <span class="s1">reused_slots = {</span>
            <span class="s1">slot: slot_descriptor</span>
            <span class="s2">for </span><span class="s1">slot</span><span class="s2">, </span><span class="s1">slot_descriptor </span><span class="s2">in </span><span class="s1">existing_slots.items()</span>
            <span class="s2">if </span><span class="s1">slot </span><span class="s2">in </span><span class="s1">slot_names</span>
        <span class="s1">}</span>
        <span class="s1">slot_names = [name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">slot_names </span><span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">reused_slots]</span>
        <span class="s1">cd.update(reused_slots)</span>
        <span class="s2">if </span><span class="s1">self._cache_hash:</span>
            <span class="s1">slot_names.append(_hash_cache_field)</span>
        <span class="s1">cd[</span><span class="s3">&quot;__slots__&quot;</span><span class="s1">] = tuple(slot_names)</span>

        <span class="s1">cd[</span><span class="s3">&quot;__qualname__&quot;</span><span class="s1">] = self._cls.__qualname__</span>

        <span class="s0"># Create new class based on old class and our methods.</span>
        <span class="s1">cls = type(self._cls)(self._cls.__name__</span><span class="s2">, </span><span class="s1">self._cls.__bases__</span><span class="s2">, </span><span class="s1">cd)</span>

        <span class="s0"># The following is a fix for</span>
        <span class="s0"># &lt;https://github.com/python-attrs/attrs/issues/102&gt;.</span>
        <span class="s0"># If a method mentions `__class__` or uses the no-arg super(), the</span>
        <span class="s0"># compiler will bake a reference to the class in the method itself</span>
        <span class="s0"># as `method.__closure__`.  Since we replace the class with a</span>
        <span class="s0"># clone, we rewrite these references so it keeps working.</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">cls.__dict__.values():</span>
            <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">(classmethod</span><span class="s2">, </span><span class="s1">staticmethod)):</span>
                <span class="s0"># Class- and staticmethods hide their functions inside.</span>
                <span class="s0"># These might need to be rewritten as well.</span>
                <span class="s1">closure_cells = getattr(item.__func__</span><span class="s2">, </span><span class="s3">&quot;__closure__&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">property):</span>
                <span class="s0"># Workaround for property `super()` shortcut (PY3-only).</span>
                <span class="s0"># There is no universal way for other descriptors.</span>
                <span class="s1">closure_cells = getattr(item.fget</span><span class="s2">, </span><span class="s3">&quot;__closure__&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">closure_cells = getattr(item</span><span class="s2">, </span><span class="s3">&quot;__closure__&quot;</span><span class="s2">, None</span><span class="s1">)</span>

            <span class="s2">if not </span><span class="s1">closure_cells:  </span><span class="s0"># Catch None or the empty list.</span>
                <span class="s2">continue</span>
            <span class="s2">for </span><span class="s1">cell </span><span class="s2">in </span><span class="s1">closure_cells:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">match = cell.cell_contents </span><span class="s2">is </span><span class="s1">self._cls</span>
                <span class="s2">except </span><span class="s1">ValueError:  </span><span class="s0"># ValueError: Cell is empty</span>
                    <span class="s2">pass</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">match:</span>
                        <span class="s1">set_closure_cell(cell</span><span class="s2">, </span><span class="s1">cls)</span>

        <span class="s2">return </span><span class="s1">cls</span>

    <span class="s2">def </span><span class="s1">add_repr(self</span><span class="s2">, </span><span class="s1">ns):</span>
        <span class="s1">self._cls_dict[</span><span class="s3">&quot;__repr__&quot;</span><span class="s1">] = self._add_method_dunders(</span>
            <span class="s1">_make_repr(self._attrs</span><span class="s2">, </span><span class="s1">ns</span><span class="s2">, </span><span class="s1">self._cls)</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_str(self):</span>
        <span class="s1">repr = self._cls_dict.get(</span><span class="s3">&quot;__repr__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">repr </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;__str__ can only be generated if a __repr__ exists.&quot;</span>
            <span class="s1">)</span>

        <span class="s2">def </span><span class="s1">__str__(self):</span>
            <span class="s2">return </span><span class="s1">self.__repr__()</span>

        <span class="s1">self._cls_dict[</span><span class="s3">&quot;__str__&quot;</span><span class="s1">] = self._add_method_dunders(__str__)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_make_getstate_setstate(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Create custom __setstate__ and __getstate__ methods. 
        &quot;&quot;&quot;</span>
        <span class="s0"># __weakref__ is not writable.</span>
        <span class="s1">state_attr_names = tuple(</span>
            <span class="s1">an </span><span class="s2">for </span><span class="s1">an </span><span class="s2">in </span><span class="s1">self._attr_names </span><span class="s2">if </span><span class="s1">an != </span><span class="s3">&quot;__weakref__&quot;</span>
        <span class="s1">)</span>

        <span class="s2">def </span><span class="s1">slots_getstate(self):</span>
            <span class="s4">&quot;&quot;&quot; 
            Automatically created by attrs. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">{name: getattr(self</span><span class="s2">, </span><span class="s1">name) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">state_attr_names}</span>

        <span class="s1">hash_caching_enabled = self._cache_hash</span>

        <span class="s2">def </span><span class="s1">slots_setstate(self</span><span class="s2">, </span><span class="s1">state):</span>
            <span class="s4">&quot;&quot;&quot; 
            Automatically created by attrs. 
            &quot;&quot;&quot;</span>
            <span class="s1">__bound_setattr = _obj_setattr.__get__(self)</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">state_attr_names:</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">state:</span>
                    <span class="s1">__bound_setattr(name</span><span class="s2">, </span><span class="s1">state[name])</span>

            <span class="s0"># The hash code cache is not included when the object is</span>
            <span class="s0"># serialized, but it still needs to be initialized to None to</span>
            <span class="s0"># indicate that the first call to __hash__ should be a cache</span>
            <span class="s0"># miss.</span>
            <span class="s2">if </span><span class="s1">hash_caching_enabled:</span>
                <span class="s1">__bound_setattr(_hash_cache_field</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">slots_getstate</span><span class="s2">, </span><span class="s1">slots_setstate</span>

    <span class="s2">def </span><span class="s1">make_unhashable(self):</span>
        <span class="s1">self._cls_dict[</span><span class="s3">&quot;__hash__&quot;</span><span class="s1">] = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_hash(self):</span>
        <span class="s1">self._cls_dict[</span><span class="s3">&quot;__hash__&quot;</span><span class="s1">] = self._add_method_dunders(</span>
            <span class="s1">_make_hash(</span>
                <span class="s1">self._cls</span><span class="s2">,</span>
                <span class="s1">self._attrs</span><span class="s2">,</span>
                <span class="s1">frozen=self._frozen</span><span class="s2">,</span>
                <span class="s1">cache_hash=self._cache_hash</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_init(self):</span>
        <span class="s1">self._cls_dict[</span><span class="s3">&quot;__init__&quot;</span><span class="s1">] = self._add_method_dunders(</span>
            <span class="s1">_make_init(</span>
                <span class="s1">self._cls</span><span class="s2">,</span>
                <span class="s1">self._attrs</span><span class="s2">,</span>
                <span class="s1">self._has_pre_init</span><span class="s2">,</span>
                <span class="s1">self._has_post_init</span><span class="s2">,</span>
                <span class="s1">self._frozen</span><span class="s2">,</span>
                <span class="s1">self._slots</span><span class="s2">,</span>
                <span class="s1">self._cache_hash</span><span class="s2">,</span>
                <span class="s1">self._base_attr_map</span><span class="s2">,</span>
                <span class="s1">self._is_exc</span><span class="s2">,</span>
                <span class="s1">self._on_setattr</span><span class="s2">,</span>
                <span class="s1">attrs_init=</span><span class="s2">False,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_match_args(self):</span>
        <span class="s1">self._cls_dict[</span><span class="s3">&quot;__match_args__&quot;</span><span class="s1">] = tuple(</span>
            <span class="s1">field.name</span>
            <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">self._attrs</span>
            <span class="s2">if </span><span class="s1">field.init </span><span class="s2">and not </span><span class="s1">field.kw_only</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">add_attrs_init(self):</span>
        <span class="s1">self._cls_dict[</span><span class="s3">&quot;__attrs_init__&quot;</span><span class="s1">] = self._add_method_dunders(</span>
            <span class="s1">_make_init(</span>
                <span class="s1">self._cls</span><span class="s2">,</span>
                <span class="s1">self._attrs</span><span class="s2">,</span>
                <span class="s1">self._has_pre_init</span><span class="s2">,</span>
                <span class="s1">self._has_post_init</span><span class="s2">,</span>
                <span class="s1">self._frozen</span><span class="s2">,</span>
                <span class="s1">self._slots</span><span class="s2">,</span>
                <span class="s1">self._cache_hash</span><span class="s2">,</span>
                <span class="s1">self._base_attr_map</span><span class="s2">,</span>
                <span class="s1">self._is_exc</span><span class="s2">,</span>
                <span class="s1">self._on_setattr</span><span class="s2">,</span>
                <span class="s1">attrs_init=</span><span class="s2">True,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_eq(self):</span>
        <span class="s1">cd = self._cls_dict</span>

        <span class="s1">cd[</span><span class="s3">&quot;__eq__&quot;</span><span class="s1">] = self._add_method_dunders(</span>
            <span class="s1">_make_eq(self._cls</span><span class="s2">, </span><span class="s1">self._attrs)</span>
        <span class="s1">)</span>
        <span class="s1">cd[</span><span class="s3">&quot;__ne__&quot;</span><span class="s1">] = self._add_method_dunders(_make_ne())</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_order(self):</span>
        <span class="s1">cd = self._cls_dict</span>

        <span class="s1">cd[</span><span class="s3">&quot;__lt__&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cd[</span><span class="s3">&quot;__le__&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cd[</span><span class="s3">&quot;__gt__&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cd[</span><span class="s3">&quot;__ge__&quot;</span><span class="s1">] = (</span>
            <span class="s1">self._add_method_dunders(meth)</span>
            <span class="s2">for </span><span class="s1">meth </span><span class="s2">in </span><span class="s1">_make_order(self._cls</span><span class="s2">, </span><span class="s1">self._attrs)</span>
        <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">add_setattr(self):</span>
        <span class="s2">if </span><span class="s1">self._frozen:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s1">sa_attrs = {}</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self._attrs:</span>
            <span class="s1">on_setattr = a.on_setattr </span><span class="s2">or </span><span class="s1">self._on_setattr</span>
            <span class="s2">if </span><span class="s1">on_setattr </span><span class="s2">and </span><span class="s1">on_setattr </span><span class="s2">is not </span><span class="s1">setters.NO_OP:</span>
                <span class="s1">sa_attrs[a.name] = a</span><span class="s2">, </span><span class="s1">on_setattr</span>

        <span class="s2">if not </span><span class="s1">sa_attrs:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s2">if </span><span class="s1">self._has_custom_setattr:</span>
            <span class="s0"># We need to write a __setattr__ but there already is one!</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Can't combine custom __setattr__ with on_setattr hooks.&quot;</span>
            <span class="s1">)</span>

        <span class="s0"># docstring comes from _add_method_dunders</span>
        <span class="s2">def </span><span class="s1">__setattr__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">val):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">a</span><span class="s2">, </span><span class="s1">hook = sa_attrs[name]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s1">nval = val</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nval = hook(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">val)</span>

            <span class="s1">_obj_setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">nval)</span>

        <span class="s1">self._cls_dict[</span><span class="s3">&quot;__attrs_own_setattr__&quot;</span><span class="s1">] = </span><span class="s2">True</span>
        <span class="s1">self._cls_dict[</span><span class="s3">&quot;__setattr__&quot;</span><span class="s1">] = self._add_method_dunders(__setattr__)</span>
        <span class="s1">self._wrote_own_setattr = </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_add_method_dunders(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s4">&quot;&quot;&quot; 
        Add __module__ and __qualname__ to a *method* if possible. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">method.__module__ = self._cls.__module__</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">method.__qualname__ = </span><span class="s3">&quot;.&quot;</span><span class="s1">.join(</span>
                <span class="s1">(self._cls.__qualname__</span><span class="s2">, </span><span class="s1">method.__name__)</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">method.__doc__ = (</span>
                <span class="s3">&quot;Method generated by attrs for class &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self._cls.__qualname__</span><span class="s2">}</span><span class="s3">.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>

        <span class="s2">return </span><span class="s1">method</span>


<span class="s2">def </span><span class="s1">_determine_attrs_eq_order(cmp</span><span class="s2">, </span><span class="s1">eq</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">default_eq):</span>
    <span class="s4">&quot;&quot;&quot; 
    Validate the combination of *cmp*, *eq*, and *order*. Derive the effective 
    values of eq and order.  If *eq* is None, set it to *default_eq*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">cmp </span><span class="s2">is not None and </span><span class="s1">any((eq </span><span class="s2">is not None, </span><span class="s1">order </span><span class="s2">is not None</span><span class="s1">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Don't mix `cmp` with `eq' and `order`.&quot;</span><span class="s1">)</span>

    <span class="s0"># cmp takes precedence due to bw-compatibility.</span>
    <span class="s2">if </span><span class="s1">cmp </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">cmp</span><span class="s2">, </span><span class="s1">cmp</span>

    <span class="s0"># If left None, equality is set to the specified default and ordering</span>
    <span class="s0"># mirrors equality.</span>
    <span class="s2">if </span><span class="s1">eq </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">eq = default_eq</span>

    <span class="s2">if </span><span class="s1">order </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">order = eq</span>

    <span class="s2">if </span><span class="s1">eq </span><span class="s2">is False and </span><span class="s1">order </span><span class="s2">is True</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;`order` can only be True if `eq` is True too.&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">eq</span><span class="s2">, </span><span class="s1">order</span>


<span class="s2">def </span><span class="s1">_determine_attrib_eq_order(cmp</span><span class="s2">, </span><span class="s1">eq</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">default_eq):</span>
    <span class="s4">&quot;&quot;&quot; 
    Validate the combination of *cmp*, *eq*, and *order*. Derive the effective 
    values of eq and order.  If *eq* is None, set it to *default_eq*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">cmp </span><span class="s2">is not None and </span><span class="s1">any((eq </span><span class="s2">is not None, </span><span class="s1">order </span><span class="s2">is not None</span><span class="s1">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Don't mix `cmp` with `eq' and `order`.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">decide_callable_or_boolean(value):</span>
        <span class="s4">&quot;&quot;&quot; 
        Decide whether a key function is used. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">callable(value):</span>
            <span class="s1">value</span><span class="s2">, </span><span class="s1">key = </span><span class="s2">True, </span><span class="s1">value</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">key = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">value</span><span class="s2">, </span><span class="s1">key</span>

    <span class="s0"># cmp takes precedence due to bw-compatibility.</span>
    <span class="s2">if </span><span class="s1">cmp </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">cmp</span><span class="s2">, </span><span class="s1">cmp_key = decide_callable_or_boolean(cmp)</span>
        <span class="s2">return </span><span class="s1">cmp</span><span class="s2">, </span><span class="s1">cmp_key</span><span class="s2">, </span><span class="s1">cmp</span><span class="s2">, </span><span class="s1">cmp_key</span>

    <span class="s0"># If left None, equality is set to the specified default and ordering</span>
    <span class="s0"># mirrors equality.</span>
    <span class="s2">if </span><span class="s1">eq </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">eq</span><span class="s2">, </span><span class="s1">eq_key = default_eq</span><span class="s2">, None</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">eq</span><span class="s2">, </span><span class="s1">eq_key = decide_callable_or_boolean(eq)</span>

    <span class="s2">if </span><span class="s1">order </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">order</span><span class="s2">, </span><span class="s1">order_key = eq</span><span class="s2">, </span><span class="s1">eq_key</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">order</span><span class="s2">, </span><span class="s1">order_key = decide_callable_or_boolean(order)</span>

    <span class="s2">if </span><span class="s1">eq </span><span class="s2">is False and </span><span class="s1">order </span><span class="s2">is True</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;`order` can only be True if `eq` is True too.&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">eq</span><span class="s2">, </span><span class="s1">eq_key</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">order_key</span>


<span class="s2">def </span><span class="s1">_determine_whether_to_implement(</span>
    <span class="s1">cls</span><span class="s2">, </span><span class="s1">flag</span><span class="s2">, </span><span class="s1">auto_detect</span><span class="s2">, </span><span class="s1">dunders</span><span class="s2">, </span><span class="s1">default=</span><span class="s2">True</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check whether we should implement a set of methods for *cls*. 
 
    *flag* is the argument passed into @attr.s like 'init', *auto_detect* the 
    same as passed into @attr.s and *dunders* is a tuple of attribute names 
    whose presence signal that the user has implemented it themselves. 
 
    Return *default* if no reason for either for or against is found. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">flag </span><span class="s2">is True or </span><span class="s1">flag </span><span class="s2">is False</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">flag</span>

    <span class="s2">if </span><span class="s1">flag </span><span class="s2">is None and </span><span class="s1">auto_detect </span><span class="s2">is False</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">default</span>

    <span class="s0"># Logically, flag is None and auto_detect is True here.</span>
    <span class="s2">for </span><span class="s1">dunder </span><span class="s2">in </span><span class="s1">dunders:</span>
        <span class="s2">if </span><span class="s1">_has_own_attribute(cls</span><span class="s2">, </span><span class="s1">dunder):</span>
            <span class="s2">return False</span>

    <span class="s2">return </span><span class="s1">default</span>


<span class="s2">def </span><span class="s1">attrs(</span>
    <span class="s1">maybe_cls=</span><span class="s2">None,</span>
    <span class="s1">these=</span><span class="s2">None,</span>
    <span class="s1">repr_ns=</span><span class="s2">None,</span>
    <span class="s1">repr=</span><span class="s2">None,</span>
    <span class="s1">cmp=</span><span class="s2">None,</span>
    <span class="s1">hash=</span><span class="s2">None,</span>
    <span class="s1">init=</span><span class="s2">None,</span>
    <span class="s1">slots=</span><span class="s2">False,</span>
    <span class="s1">frozen=</span><span class="s2">False,</span>
    <span class="s1">weakref_slot=</span><span class="s2">True,</span>
    <span class="s1">str=</span><span class="s2">False,</span>
    <span class="s1">auto_attribs=</span><span class="s2">False,</span>
    <span class="s1">kw_only=</span><span class="s2">False,</span>
    <span class="s1">cache_hash=</span><span class="s2">False,</span>
    <span class="s1">auto_exc=</span><span class="s2">False,</span>
    <span class="s1">eq=</span><span class="s2">None,</span>
    <span class="s1">order=</span><span class="s2">None,</span>
    <span class="s1">auto_detect=</span><span class="s2">False,</span>
    <span class="s1">collect_by_mro=</span><span class="s2">False,</span>
    <span class="s1">getstate_setstate=</span><span class="s2">None,</span>
    <span class="s1">on_setattr=</span><span class="s2">None,</span>
    <span class="s1">field_transformer=</span><span class="s2">None,</span>
    <span class="s1">match_args=</span><span class="s2">True,</span>
    <span class="s1">unsafe_hash=</span><span class="s2">None,</span>
<span class="s1">):</span>
    <span class="s4">r&quot;&quot;&quot; 
    A class decorator that adds :term:`dunder methods` according to the 
    specified attributes using `attr.ib` or the *these* argument. 
 
    :param these: A dictionary of name to `attr.ib` mappings.  This is 
        useful to avoid the definition of your attributes within the class body 
        because you can't (e.g. if you want to add ``__repr__`` methods to 
        Django models) or don't want to. 
 
        If *these* is not ``None``, ``attrs`` will *not* search the class body 
        for attributes and will *not* remove any attributes from it. 
 
        The order is deduced from the order of the attributes inside *these*. 
 
    :type these: `dict` of `str` to `attr.ib` 
 
    :param str repr_ns: When using nested classes, there's no way in Python 2 
        to automatically detect that.  Therefore it's possible to set the 
        namespace explicitly for a more meaningful ``repr`` output. 
    :param bool auto_detect: Instead of setting the *init*, *repr*, *eq*, 
        *order*, and *hash* arguments explicitly, assume they are set to 
        ``True`` **unless any** of the involved methods for one of the 
        arguments is implemented in the *current* class (i.e. it is *not* 
        inherited from some base class). 
 
        So for example by implementing ``__eq__`` on a class yourself, 
        ``attrs`` will deduce ``eq=False`` and will create *neither* 
        ``__eq__`` *nor* ``__ne__`` (but Python classes come with a sensible 
        ``__ne__`` by default, so it *should* be enough to only implement 
        ``__eq__`` in most cases). 
 
        .. warning:: 
 
           If you prevent ``attrs`` from creating the ordering methods for you 
           (``order=False``, e.g. by implementing ``__le__``), it becomes 
           *your* responsibility to make sure its ordering is sound. The best 
           way is to use the `functools.total_ordering` decorator. 
 
 
        Passing ``True`` or ``False`` to *init*, *repr*, *eq*, *order*, 
        *cmp*, or *hash* overrides whatever *auto_detect* would determine. 
 
    :param bool repr: Create a ``__repr__`` method with a human readable 
        representation of ``attrs`` attributes.. 
    :param bool str: Create a ``__str__`` method that is identical to 
        ``__repr__``.  This is usually not necessary except for 
        `Exception`\ s. 
    :param Optional[bool] eq: If ``True`` or ``None`` (default), add ``__eq__`` 
        and ``__ne__`` methods that check two instances for equality. 
 
        They compare the instances as if they were tuples of their ``attrs`` 
        attributes if and only if the types of both classes are *identical*! 
    :param Optional[bool] order: If ``True``, add ``__lt__``, ``__le__``, 
        ``__gt__``, and ``__ge__`` methods that behave like *eq* above and 
        allow instances to be ordered. If ``None`` (default) mirror value of 
        *eq*. 
    :param Optional[bool] cmp: Setting *cmp* is equivalent to setting *eq* 
        and *order* to the same value. Must not be mixed with *eq* or *order*. 
    :param Optional[bool] unsafe_hash: If ``None`` (default), the ``__hash__`` 
        method is generated according how *eq* and *frozen* are set. 
 
        1. If *both* are True, ``attrs`` will generate a ``__hash__`` for you. 
        2. If *eq* is True and *frozen* is False, ``__hash__`` will be set to 
           None, marking it unhashable (which it is). 
        3. If *eq* is False, ``__hash__`` will be left untouched meaning the 
           ``__hash__`` method of the base class will be used (if base class is 
           ``object``, this means it will fall back to id-based hashing.). 
 
        Although not recommended, you can decide for yourself and force 
        ``attrs`` to create one (e.g. if the class is immutable even though you 
        didn't freeze it programmatically) by passing ``True`` or not.  Both of 
        these cases are rather special and should be used carefully. 
 
        See our documentation on `hashing`, Python's documentation on 
        `object.__hash__`, and the `GitHub issue that led to the default \ 
        behavior &lt;https://github.com/python-attrs/attrs/issues/136&gt;`_ for more 
        details. 
    :param Optional[bool] hash: Alias for *unsafe_hash*. *unsafe_hash* takes 
        precedence. 
    :param bool init: Create a ``__init__`` method that initializes the 
        ``attrs`` attributes. Leading underscores are stripped for the argument 
        name. If a ``__attrs_pre_init__`` method exists on the class, it will 
        be called before the class is initialized. If a ``__attrs_post_init__`` 
        method exists on the class, it will be called after the class is fully 
        initialized. 
 
        If ``init`` is ``False``, an ``__attrs_init__`` method will be 
        injected instead. This allows you to define a custom ``__init__`` 
        method that can do pre-init work such as ``super().__init__()``, 
        and then call ``__attrs_init__()`` and ``__attrs_post_init__()``. 
    :param bool slots: Create a :term:`slotted class &lt;slotted classes&gt;` that's 
        more memory-efficient. Slotted classes are generally superior to the 
        default dict classes, but have some gotchas you should know about, so 
        we encourage you to read the :term:`glossary entry &lt;slotted classes&gt;`. 
    :param bool frozen: Make instances immutable after initialization.  If 
        someone attempts to modify a frozen instance, 
        `attr.exceptions.FrozenInstanceError` is raised. 
 
        .. note:: 
 
            1. This is achieved by installing a custom ``__setattr__`` method 
               on your class, so you can't implement your own. 
 
            2. True immutability is impossible in Python. 
 
            3. This *does* have a minor a runtime performance `impact 
               &lt;how-frozen&gt;` when initializing new instances.  In other words: 
               ``__init__`` is slightly slower with ``frozen=True``. 
 
            4. If a class is frozen, you cannot modify ``self`` in 
               ``__attrs_post_init__`` or a self-written ``__init__``. You can 
               circumvent that limitation by using 
               ``object.__setattr__(self, &quot;attribute_name&quot;, value)``. 
 
            5. Subclasses of a frozen class are frozen too. 
 
    :param bool weakref_slot: Make instances weak-referenceable.  This has no 
        effect unless ``slots`` is also enabled. 
    :param bool auto_attribs: If ``True``, collect :pep:`526`-annotated 
        attributes from the class body. 
 
        In this case, you **must** annotate every field.  If ``attrs`` 
        encounters a field that is set to an `attr.ib` but lacks a type 
        annotation, an `attr.exceptions.UnannotatedAttributeError` is 
        raised.  Use ``field_name: typing.Any = attr.ib(...)`` if you don't 
        want to set a type. 
 
        If you assign a value to those attributes (e.g. ``x: int = 42``), that 
        value becomes the default value like if it were passed using 
        ``attr.ib(default=42)``.  Passing an instance of `attrs.Factory` also 
        works as expected in most cases (see warning below). 
 
        Attributes annotated as `typing.ClassVar`, and attributes that are 
        neither annotated nor set to an `attr.ib` are **ignored**. 
 
        .. warning:: 
           For features that use the attribute name to create decorators (e.g. 
           `validators &lt;validators&gt;`), you still *must* assign `attr.ib` to 
           them. Otherwise Python will either not find the name or try to use 
           the default value to call e.g. ``validator`` on it. 
 
           These errors can be quite confusing and probably the most common bug 
           report on our bug tracker. 
 
    :param bool kw_only: Make all attributes keyword-only 
        in the generated ``__init__`` (if ``init`` is ``False``, this 
        parameter is ignored). 
    :param bool cache_hash: Ensure that the object's hash code is computed 
        only once and stored on the object.  If this is set to ``True``, 
        hashing must be either explicitly or implicitly enabled for this 
        class.  If the hash code is cached, avoid any reassignments of 
        fields involved in hash code computation or mutations of the objects 
        those fields point to after object creation.  If such changes occur, 
        the behavior of the object's hash code is undefined. 
    :param bool auto_exc: If the class subclasses `BaseException` 
        (which implicitly includes any subclass of any exception), the 
        following happens to behave like a well-behaved Python exceptions 
        class: 
 
        - the values for *eq*, *order*, and *hash* are ignored and the 
          instances compare and hash by the instance's ids (N.B. ``attrs`` will 
          *not* remove existing implementations of ``__hash__`` or the equality 
          methods. It just won't add own ones.), 
        - all attributes that are either passed into ``__init__`` or have a 
          default value are additionally available as a tuple in the ``args`` 
          attribute, 
        - the value of *str* is ignored leaving ``__str__`` to base classes. 
    :param bool collect_by_mro: Setting this to `True` fixes the way ``attrs`` 
       collects attributes from base classes.  The default behavior is 
       incorrect in certain cases of multiple inheritance.  It should be on by 
       default but is kept off for backward-compatibility. 
 
       See issue `#428 &lt;https://github.com/python-attrs/attrs/issues/428&gt;`_ for 
       more details. 
 
    :param Optional[bool] getstate_setstate: 
       .. note:: 
          This is usually only interesting for slotted classes and you should 
          probably just set *auto_detect* to `True`. 
 
       If `True`, ``__getstate__`` and 
       ``__setstate__`` are generated and attached to the class. This is 
       necessary for slotted classes to be pickleable. If left `None`, it's 
       `True` by default for slotted classes and ``False`` for dict classes. 
 
       If *auto_detect* is `True`, and *getstate_setstate* is left `None`, 
       and **either** ``__getstate__`` or ``__setstate__`` is detected directly 
       on the class (i.e. not inherited), it is set to `False` (this is usually 
       what you want). 
 
    :param on_setattr: A callable that is run whenever the user attempts to set 
        an attribute (either by assignment like ``i.x = 42`` or by using 
        `setattr` like ``setattr(i, &quot;x&quot;, 42)``). It receives the same arguments 
        as validators: the instance, the attribute that is being modified, and 
        the new value. 
 
        If no exception is raised, the attribute is set to the return value of 
        the callable. 
 
        If a list of callables is passed, they're automatically wrapped in an 
        `attrs.setters.pipe`. 
    :type on_setattr: `callable`, or a list of callables, or `None`, or 
        `attrs.setters.NO_OP` 
 
    :param Optional[callable] field_transformer: 
        A function that is called with the original class object and all 
        fields right before ``attrs`` finalizes the class.  You can use 
        this, e.g., to automatically add converters or validators to 
        fields based on their types.  See `transform-fields` for more details. 
 
    :param bool match_args: 
        If `True` (default), set ``__match_args__`` on the class to support 
        :pep:`634` (Structural Pattern Matching). It is a tuple of all 
        non-keyword-only ``__init__`` parameter names on Python 3.10 and later. 
        Ignored on older Python versions. 
 
    .. versionadded:: 16.0.0 *slots* 
    .. versionadded:: 16.1.0 *frozen* 
    .. versionadded:: 16.3.0 *str* 
    .. versionadded:: 16.3.0 Support for ``__attrs_post_init__``. 
    .. versionchanged:: 17.1.0 
       *hash* supports ``None`` as value which is also the default now. 
    .. versionadded:: 17.3.0 *auto_attribs* 
    .. versionchanged:: 18.1.0 
       If *these* is passed, no attributes are deleted from the class body. 
    .. versionchanged:: 18.1.0 If *these* is ordered, the order is retained. 
    .. versionadded:: 18.2.0 *weakref_slot* 
    .. deprecated:: 18.2.0 
       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now raise a 
       `DeprecationWarning` if the classes compared are subclasses of 
       each other. ``__eq`` and ``__ne__`` never tried to compared subclasses 
       to each other. 
    .. versionchanged:: 19.2.0 
       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now do not consider 
       subclasses comparable anymore. 
    .. versionadded:: 18.2.0 *kw_only* 
    .. versionadded:: 18.2.0 *cache_hash* 
    .. versionadded:: 19.1.0 *auto_exc* 
    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01. 
    .. versionadded:: 19.2.0 *eq* and *order* 
    .. versionadded:: 20.1.0 *auto_detect* 
    .. versionadded:: 20.1.0 *collect_by_mro* 
    .. versionadded:: 20.1.0 *getstate_setstate* 
    .. versionadded:: 20.1.0 *on_setattr* 
    .. versionadded:: 20.3.0 *field_transformer* 
    .. versionchanged:: 21.1.0 
       ``init=False`` injects ``__attrs_init__`` 
    .. versionchanged:: 21.1.0 Support for ``__attrs_pre_init__`` 
    .. versionchanged:: 21.1.0 *cmp* undeprecated 
    .. versionadded:: 21.3.0 *match_args* 
    .. versionadded:: 22.2.0 
       *unsafe_hash* as an alias for *hash* (for :pep:`681` compliance). 
    &quot;&quot;&quot;</span>
    <span class="s1">eq_</span><span class="s2">, </span><span class="s1">order_ = _determine_attrs_eq_order(cmp</span><span class="s2">, </span><span class="s1">eq</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s0"># unsafe_hash takes precedence due to PEP 681.</span>
    <span class="s2">if </span><span class="s1">unsafe_hash </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">hash = unsafe_hash</span>

    <span class="s2">if </span><span class="s1">isinstance(on_setattr</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s1">on_setattr = setters.pipe(*on_setattr)</span>

    <span class="s2">def </span><span class="s1">wrap(cls):</span>
        <span class="s1">is_frozen = frozen </span><span class="s2">or </span><span class="s1">_has_frozen_base_class(cls)</span>
        <span class="s1">is_exc = auto_exc </span><span class="s2">is True and </span><span class="s1">issubclass(cls</span><span class="s2">, </span><span class="s1">BaseException)</span>
        <span class="s1">has_own_setattr = auto_detect </span><span class="s2">and </span><span class="s1">_has_own_attribute(</span>
            <span class="s1">cls</span><span class="s2">, </span><span class="s3">&quot;__setattr__&quot;</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">has_own_setattr </span><span class="s2">and </span><span class="s1">is_frozen:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Can't freeze a class with a custom __setattr__.&quot;</span><span class="s1">)</span>

        <span class="s1">builder = _ClassBuilder(</span>
            <span class="s1">cls</span><span class="s2">,</span>
            <span class="s1">these</span><span class="s2">,</span>
            <span class="s1">slots</span><span class="s2">,</span>
            <span class="s1">is_frozen</span><span class="s2">,</span>
            <span class="s1">weakref_slot</span><span class="s2">,</span>
            <span class="s1">_determine_whether_to_implement(</span>
                <span class="s1">cls</span><span class="s2">,</span>
                <span class="s1">getstate_setstate</span><span class="s2">,</span>
                <span class="s1">auto_detect</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s3">&quot;__getstate__&quot;</span><span class="s2">, </span><span class="s3">&quot;__setstate__&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">default=slots</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">auto_attribs</span><span class="s2">,</span>
            <span class="s1">kw_only</span><span class="s2">,</span>
            <span class="s1">cache_hash</span><span class="s2">,</span>
            <span class="s1">is_exc</span><span class="s2">,</span>
            <span class="s1">collect_by_mro</span><span class="s2">,</span>
            <span class="s1">on_setattr</span><span class="s2">,</span>
            <span class="s1">has_own_setattr</span><span class="s2">,</span>
            <span class="s1">field_transformer</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">_determine_whether_to_implement(</span>
            <span class="s1">cls</span><span class="s2">, </span><span class="s1">repr</span><span class="s2">, </span><span class="s1">auto_detect</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;__repr__&quot;</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">builder.add_repr(repr_ns)</span>
        <span class="s2">if </span><span class="s1">str </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s1">builder.add_str()</span>

        <span class="s1">eq = _determine_whether_to_implement(</span>
            <span class="s1">cls</span><span class="s2">, </span><span class="s1">eq_</span><span class="s2">, </span><span class="s1">auto_detect</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;__eq__&quot;</span><span class="s2">, </span><span class="s3">&quot;__ne__&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">is_exc </span><span class="s2">and </span><span class="s1">eq </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s1">builder.add_eq()</span>
        <span class="s2">if not </span><span class="s1">is_exc </span><span class="s2">and </span><span class="s1">_determine_whether_to_implement(</span>
            <span class="s1">cls</span><span class="s2">, </span><span class="s1">order_</span><span class="s2">, </span><span class="s1">auto_detect</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;__lt__&quot;</span><span class="s2">, </span><span class="s3">&quot;__le__&quot;</span><span class="s2">, </span><span class="s3">&quot;__gt__&quot;</span><span class="s2">, </span><span class="s3">&quot;__ge__&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">builder.add_order()</span>

        <span class="s1">builder.add_setattr()</span>

        <span class="s2">nonlocal </span><span class="s1">hash</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">hash </span><span class="s2">is None</span>
            <span class="s2">and </span><span class="s1">auto_detect </span><span class="s2">is True</span>
            <span class="s2">and </span><span class="s1">_has_own_attribute(cls</span><span class="s2">, </span><span class="s3">&quot;__hash__&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">hash = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">hash </span><span class="s2">is not True and </span><span class="s1">hash </span><span class="s2">is not False and </span><span class="s1">hash </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s0"># Can't use `hash in` because 1 == True for example.</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">&quot;Invalid value for hash.  Must be True, False, or None.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">hash </span><span class="s2">is False or </span><span class="s1">(hash </span><span class="s2">is None and </span><span class="s1">eq </span><span class="s2">is False</span><span class="s1">) </span><span class="s2">or </span><span class="s1">is_exc:</span>
            <span class="s0"># Don't do anything. Should fall back to __object__'s __hash__</span>
            <span class="s0"># which is by id.</span>
            <span class="s2">if </span><span class="s1">cache_hash:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;Invalid value for cache_hash.  To use hash caching,&quot;</span>
                    <span class="s3">&quot; hashing must be either explicitly or implicitly &quot;</span>
                    <span class="s3">&quot;enabled.&quot;</span>
                <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">hash </span><span class="s2">is True or </span><span class="s1">(</span>
            <span class="s1">hash </span><span class="s2">is None and </span><span class="s1">eq </span><span class="s2">is True and </span><span class="s1">is_frozen </span><span class="s2">is True</span>
        <span class="s1">):</span>
            <span class="s0"># Build a __hash__ if told so, or if it's safe.</span>
            <span class="s1">builder.add_hash()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Raise TypeError on attempts to hash.</span>
            <span class="s2">if </span><span class="s1">cache_hash:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;Invalid value for cache_hash.  To use hash caching,&quot;</span>
                    <span class="s3">&quot; hashing must be either explicitly or implicitly &quot;</span>
                    <span class="s3">&quot;enabled.&quot;</span>
                <span class="s1">)</span>
            <span class="s1">builder.make_unhashable()</span>

        <span class="s2">if </span><span class="s1">_determine_whether_to_implement(</span>
            <span class="s1">cls</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, </span><span class="s1">auto_detect</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;__init__&quot;</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">builder.add_init()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">builder.add_attrs_init()</span>
            <span class="s2">if </span><span class="s1">cache_hash:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;Invalid value for cache_hash.  To use hash caching,&quot;</span>
                    <span class="s3">&quot; init must be True.&quot;</span>
                <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">PY310</span>
            <span class="s2">and </span><span class="s1">match_args</span>
            <span class="s2">and not </span><span class="s1">_has_own_attribute(cls</span><span class="s2">, </span><span class="s3">&quot;__match_args__&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">builder.add_match_args()</span>

        <span class="s2">return </span><span class="s1">builder.build_class()</span>

    <span class="s0"># maybe_cls's type depends on the usage of the decorator.  It's a class</span>
    <span class="s0"># if it's used as `@attrs` but ``None`` if used as `@attrs()`.</span>
    <span class="s2">if </span><span class="s1">maybe_cls </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">wrap</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">wrap(maybe_cls)</span>


<span class="s1">_attrs = attrs</span>
<span class="s3">&quot;&quot;&quot; 
Internal alias so we can use it in functions that take an argument called 
*attrs*. 
&quot;&quot;&quot;</span>


<span class="s2">def </span><span class="s1">_has_frozen_base_class(cls):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check whether *cls* has a frozen ancestor by looking at its 
    __setattr__. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">cls.__setattr__ </span><span class="s2">is </span><span class="s1">_frozen_setattrs</span>


<span class="s2">def </span><span class="s1">_generate_unique_filename(cls</span><span class="s2">, </span><span class="s1">func_name):</span>
    <span class="s4">&quot;&quot;&quot; 
    Create a &quot;filename&quot; suitable for a function being generated. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s3">f&quot;&lt;attrs generated </span><span class="s2">{</span><span class="s1">func_name</span><span class="s2">} {</span><span class="s1">cls.__module__</span><span class="s2">}</span><span class="s3">.&quot;</span>
        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">getattr(cls</span><span class="s2">, </span><span class="s3">'__qualname__'</span><span class="s2">, </span><span class="s1">cls.__name__)</span><span class="s2">}</span><span class="s3">&gt;&quot;</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_make_hash(cls</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">frozen</span><span class="s2">, </span><span class="s1">cache_hash):</span>
    <span class="s1">attrs = tuple(</span>
        <span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs </span><span class="s2">if </span><span class="s1">a.hash </span><span class="s2">is True or </span><span class="s1">(a.hash </span><span class="s2">is None and </span><span class="s1">a.eq </span><span class="s2">is True</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s1">tab = </span><span class="s3">&quot;        &quot;</span>

    <span class="s1">unique_filename = _generate_unique_filename(cls</span><span class="s2">, </span><span class="s3">&quot;hash&quot;</span><span class="s1">)</span>
    <span class="s1">type_hash = hash(unique_filename)</span>
    <span class="s0"># If eq is custom generated, we need to include the functions in globs</span>
    <span class="s1">globs = {}</span>

    <span class="s1">hash_def = </span><span class="s3">&quot;def __hash__(self&quot;</span>
    <span class="s1">hash_func = </span><span class="s3">&quot;hash((&quot;</span>
    <span class="s1">closing_braces = </span><span class="s3">&quot;))&quot;</span>
    <span class="s2">if not </span><span class="s1">cache_hash:</span>
        <span class="s1">hash_def += </span><span class="s3">&quot;):&quot;</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">hash_def += </span><span class="s3">&quot;, *&quot;</span>

        <span class="s1">hash_def += (</span>
            <span class="s3">&quot;, _cache_wrapper=&quot;</span>
            <span class="s1">+ </span><span class="s3">&quot;__import__('attr._make')._make._CacheHashWrapper):&quot;</span>
        <span class="s1">)</span>
        <span class="s1">hash_func = </span><span class="s3">&quot;_cache_wrapper(&quot; </span><span class="s1">+ hash_func</span>
        <span class="s1">closing_braces += </span><span class="s3">&quot;)&quot;</span>

    <span class="s1">method_lines = [hash_def]</span>

    <span class="s2">def </span><span class="s1">append_hash_computation_lines(prefix</span><span class="s2">, </span><span class="s1">indent):</span>
        <span class="s4">&quot;&quot;&quot; 
        Generate the code for actually computing the hash code. 
        Below this will either be returned directly or used to compute 
        a value which is then cached, depending on the value of cache_hash 
        &quot;&quot;&quot;</span>

        <span class="s1">method_lines.extend(</span>
            <span class="s1">[</span>
                <span class="s1">indent + prefix + hash_func</span><span class="s2">,</span>
                <span class="s1">indent + </span><span class="s3">f&quot;        </span><span class="s2">{</span><span class="s1">type_hash</span><span class="s2">}</span><span class="s3">,&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs:</span>
            <span class="s2">if </span><span class="s1">a.eq_key:</span>
                <span class="s1">cmp_name = </span><span class="s3">f&quot;_</span><span class="s2">{</span><span class="s1">a.name</span><span class="s2">}</span><span class="s3">_key&quot;</span>
                <span class="s1">globs[cmp_name] = a.eq_key</span>
                <span class="s1">method_lines.append(</span>
                    <span class="s1">indent + </span><span class="s3">f&quot;        </span><span class="s2">{</span><span class="s1">cmp_name</span><span class="s2">}</span><span class="s3">(self.</span><span class="s2">{</span><span class="s1">a.name</span><span class="s2">}</span><span class="s3">),&quot;</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">method_lines.append(indent + </span><span class="s3">f&quot;        self.</span><span class="s2">{</span><span class="s1">a.name</span><span class="s2">}</span><span class="s3">,&quot;</span><span class="s1">)</span>

        <span class="s1">method_lines.append(indent + </span><span class="s3">&quot;    &quot; </span><span class="s1">+ closing_braces)</span>

    <span class="s2">if </span><span class="s1">cache_hash:</span>
        <span class="s1">method_lines.append(tab + </span><span class="s3">f&quot;if self.</span><span class="s2">{</span><span class="s1">_hash_cache_field</span><span class="s2">} </span><span class="s3">is None:&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">frozen:</span>
            <span class="s1">append_hash_computation_lines(</span>
                <span class="s3">f&quot;object.__setattr__(self, '</span><span class="s2">{</span><span class="s1">_hash_cache_field</span><span class="s2">}</span><span class="s3">', &quot;</span><span class="s2">, </span><span class="s1">tab * </span><span class="s5">2</span>
            <span class="s1">)</span>
            <span class="s1">method_lines.append(tab * </span><span class="s5">2 </span><span class="s1">+ </span><span class="s3">&quot;)&quot;</span><span class="s1">)  </span><span class="s0"># close __setattr__</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">append_hash_computation_lines(</span>
                <span class="s3">f&quot;self.</span><span class="s2">{</span><span class="s1">_hash_cache_field</span><span class="s2">} </span><span class="s3">= &quot;</span><span class="s2">, </span><span class="s1">tab * </span><span class="s5">2</span>
            <span class="s1">)</span>
        <span class="s1">method_lines.append(tab + </span><span class="s3">f&quot;return self.</span><span class="s2">{</span><span class="s1">_hash_cache_field</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">append_hash_computation_lines(</span><span class="s3">&quot;return &quot;</span><span class="s2">, </span><span class="s1">tab)</span>

    <span class="s1">script = </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(method_lines)</span>
    <span class="s2">return </span><span class="s1">_make_method(</span><span class="s3">&quot;__hash__&quot;</span><span class="s2">, </span><span class="s1">script</span><span class="s2">, </span><span class="s1">unique_filename</span><span class="s2">, </span><span class="s1">globs)</span>


<span class="s2">def </span><span class="s1">_add_hash(cls</span><span class="s2">, </span><span class="s1">attrs):</span>
    <span class="s4">&quot;&quot;&quot; 
    Add a hash method to *cls*. 
    &quot;&quot;&quot;</span>
    <span class="s1">cls.__hash__ = _make_hash(cls</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">frozen=</span><span class="s2">False, </span><span class="s1">cache_hash=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">cls</span>


<span class="s2">def </span><span class="s1">_make_ne():</span>
    <span class="s4">&quot;&quot;&quot; 
    Create __ne__ method. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s4">&quot;&quot;&quot; 
        Check equality and either forward a NotImplemented or 
        return the result negated. 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self.__eq__(other)</span>
        <span class="s2">if </span><span class="s1">result </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return not </span><span class="s1">result</span>

    <span class="s2">return </span><span class="s1">__ne__</span>


<span class="s2">def </span><span class="s1">_make_eq(cls</span><span class="s2">, </span><span class="s1">attrs):</span>
    <span class="s4">&quot;&quot;&quot; 
    Create __eq__ method for *cls* with *attrs*. 
    &quot;&quot;&quot;</span>
    <span class="s1">attrs = [a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs </span><span class="s2">if </span><span class="s1">a.eq]</span>

    <span class="s1">unique_filename = _generate_unique_filename(cls</span><span class="s2">, </span><span class="s3">&quot;eq&quot;</span><span class="s1">)</span>
    <span class="s1">lines = [</span>
        <span class="s3">&quot;def __eq__(self, other):&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;    if other.__class__ is not self.__class__:&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;        return NotImplemented&quot;</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s0"># We can't just do a big self.x = other.x and... clause due to</span>
    <span class="s0"># irregularities like nan == nan is false but (nan,) == (nan,) is true.</span>
    <span class="s1">globs = {}</span>
    <span class="s2">if </span><span class="s1">attrs:</span>
        <span class="s1">lines.append(</span><span class="s3">&quot;    return  (&quot;</span><span class="s1">)</span>
        <span class="s1">others = [</span><span class="s3">&quot;    ) == (&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs:</span>
            <span class="s2">if </span><span class="s1">a.eq_key:</span>
                <span class="s1">cmp_name = </span><span class="s3">f&quot;_</span><span class="s2">{</span><span class="s1">a.name</span><span class="s2">}</span><span class="s3">_key&quot;</span>
                <span class="s0"># Add the key function to the global namespace</span>
                <span class="s0"># of the evaluated function.</span>
                <span class="s1">globs[cmp_name] = a.eq_key</span>
                <span class="s1">lines.append(</span><span class="s3">f&quot;        </span><span class="s2">{</span><span class="s1">cmp_name</span><span class="s2">}</span><span class="s3">(self.</span><span class="s2">{</span><span class="s1">a.name</span><span class="s2">}</span><span class="s3">),&quot;</span><span class="s1">)</span>
                <span class="s1">others.append(</span><span class="s3">f&quot;        </span><span class="s2">{</span><span class="s1">cmp_name</span><span class="s2">}</span><span class="s3">(other.</span><span class="s2">{</span><span class="s1">a.name</span><span class="s2">}</span><span class="s3">),&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">lines.append(</span><span class="s3">f&quot;        self.</span><span class="s2">{</span><span class="s1">a.name</span><span class="s2">}</span><span class="s3">,&quot;</span><span class="s1">)</span>
                <span class="s1">others.append(</span><span class="s3">f&quot;        other.</span><span class="s2">{</span><span class="s1">a.name</span><span class="s2">}</span><span class="s3">,&quot;</span><span class="s1">)</span>

        <span class="s1">lines += others + [</span><span class="s3">&quot;    )&quot;</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">lines.append(</span><span class="s3">&quot;    return True&quot;</span><span class="s1">)</span>

    <span class="s1">script = </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(lines)</span>

    <span class="s2">return </span><span class="s1">_make_method(</span><span class="s3">&quot;__eq__&quot;</span><span class="s2">, </span><span class="s1">script</span><span class="s2">, </span><span class="s1">unique_filename</span><span class="s2">, </span><span class="s1">globs)</span>


<span class="s2">def </span><span class="s1">_make_order(cls</span><span class="s2">, </span><span class="s1">attrs):</span>
    <span class="s4">&quot;&quot;&quot; 
    Create ordering methods for *cls* with *attrs*. 
    &quot;&quot;&quot;</span>
    <span class="s1">attrs = [a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs </span><span class="s2">if </span><span class="s1">a.order]</span>

    <span class="s2">def </span><span class="s1">attrs_to_tuple(obj):</span>
        <span class="s4">&quot;&quot;&quot; 
        Save us some typing. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">tuple(</span>
            <span class="s1">key(value) </span><span class="s2">if </span><span class="s1">key </span><span class="s2">else </span><span class="s1">value</span>
            <span class="s2">for </span><span class="s1">value</span><span class="s2">, </span><span class="s1">key </span><span class="s2">in </span><span class="s1">(</span>
                <span class="s1">(getattr(obj</span><span class="s2">, </span><span class="s1">a.name)</span><span class="s2">, </span><span class="s1">a.order_key) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__lt__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s4">&quot;&quot;&quot; 
        Automatically created by attrs. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other.__class__ </span><span class="s2">is </span><span class="s1">self.__class__:</span>
            <span class="s2">return </span><span class="s1">attrs_to_tuple(self) &lt; attrs_to_tuple(other)</span>

        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__le__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s4">&quot;&quot;&quot; 
        Automatically created by attrs. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other.__class__ </span><span class="s2">is </span><span class="s1">self.__class__:</span>
            <span class="s2">return </span><span class="s1">attrs_to_tuple(self) &lt;= attrs_to_tuple(other)</span>

        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__gt__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s4">&quot;&quot;&quot; 
        Automatically created by attrs. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other.__class__ </span><span class="s2">is </span><span class="s1">self.__class__:</span>
            <span class="s2">return </span><span class="s1">attrs_to_tuple(self) &gt; attrs_to_tuple(other)</span>

        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__ge__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s4">&quot;&quot;&quot; 
        Automatically created by attrs. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other.__class__ </span><span class="s2">is </span><span class="s1">self.__class__:</span>
            <span class="s2">return </span><span class="s1">attrs_to_tuple(self) &gt;= attrs_to_tuple(other)</span>

        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">return </span><span class="s1">__lt__</span><span class="s2">, </span><span class="s1">__le__</span><span class="s2">, </span><span class="s1">__gt__</span><span class="s2">, </span><span class="s1">__ge__</span>


<span class="s2">def </span><span class="s1">_add_eq(cls</span><span class="s2">, </span><span class="s1">attrs=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Add equality methods to *cls* with *attrs*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">attrs = cls.__attrs_attrs__</span>

    <span class="s1">cls.__eq__ = _make_eq(cls</span><span class="s2">, </span><span class="s1">attrs)</span>
    <span class="s1">cls.__ne__ = _make_ne()</span>

    <span class="s2">return </span><span class="s1">cls</span>


<span class="s2">def </span><span class="s1">_make_repr(attrs</span><span class="s2">, </span><span class="s1">ns</span><span class="s2">, </span><span class="s1">cls):</span>
    <span class="s1">unique_filename = _generate_unique_filename(cls</span><span class="s2">, </span><span class="s3">&quot;repr&quot;</span><span class="s1">)</span>
    <span class="s0"># Figure out which attributes to include, and which function to use to</span>
    <span class="s0"># format them. The a.repr value can be either bool or a custom</span>
    <span class="s0"># callable.</span>
    <span class="s1">attr_names_with_reprs = tuple(</span>
        <span class="s1">(a.name</span><span class="s2">, </span><span class="s1">(repr </span><span class="s2">if </span><span class="s1">a.repr </span><span class="s2">is True else </span><span class="s1">a.repr)</span><span class="s2">, </span><span class="s1">a.init)</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span>
        <span class="s2">if </span><span class="s1">a.repr </span><span class="s2">is not False</span>
    <span class="s1">)</span>
    <span class="s1">globs = {</span>
        <span class="s1">name + </span><span class="s3">&quot;_repr&quot;</span><span class="s1">: r </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">attr_names_with_reprs </span><span class="s2">if </span><span class="s1">r != repr</span>
    <span class="s1">}</span>
    <span class="s1">globs[</span><span class="s3">&quot;_compat&quot;</span><span class="s1">] = _compat</span>
    <span class="s1">globs[</span><span class="s3">&quot;AttributeError&quot;</span><span class="s1">] = AttributeError</span>
    <span class="s1">globs[</span><span class="s3">&quot;NOTHING&quot;</span><span class="s1">] = NOTHING</span>
    <span class="s1">attribute_fragments = []</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">i </span><span class="s2">in </span><span class="s1">attr_names_with_reprs:</span>
        <span class="s1">accessor = (</span>
            <span class="s3">&quot;self.&quot; </span><span class="s1">+ name </span><span class="s2">if </span><span class="s1">i </span><span class="s2">else </span><span class="s3">'getattr(self, &quot;' </span><span class="s1">+ name + </span><span class="s3">'&quot;, NOTHING)'</span>
        <span class="s1">)</span>
        <span class="s1">fragment = (</span>
            <span class="s3">&quot;%s={%s!r}&quot; </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">accessor)</span>
            <span class="s2">if </span><span class="s1">r == repr</span>
            <span class="s2">else </span><span class="s3">&quot;%s={%s_repr(%s)}&quot; </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">accessor)</span>
        <span class="s1">)</span>
        <span class="s1">attribute_fragments.append(fragment)</span>
    <span class="s1">repr_fragment = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(attribute_fragments)</span>

    <span class="s2">if </span><span class="s1">ns </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">cls_name_fragment = </span><span class="s3">'{self.__class__.__qualname__.rsplit(&quot;&gt;.&quot;, 1)[-1]}'</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">cls_name_fragment = ns + </span><span class="s3">&quot;.{self.__class__.__name__}&quot;</span>

    <span class="s1">lines = [</span>
        <span class="s3">&quot;def __repr__(self):&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;  try:&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;    already_repring = _compat.repr_context.already_repring&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;  except AttributeError:&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;    already_repring = {id(self),}&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;    _compat.repr_context.already_repring = already_repring&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;  else:&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;    if id(self) in already_repring:&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;      return '...'&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;    else:&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;      already_repring.add(id(self))&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;  try:&quot;</span><span class="s2">,</span>
        <span class="s3">f&quot;    return f'</span><span class="s2">{</span><span class="s1">cls_name_fragment</span><span class="s2">}</span><span class="s3">(</span><span class="s2">{</span><span class="s1">repr_fragment</span><span class="s2">}</span><span class="s3">)'&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;  finally:&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;    already_repring.remove(id(self))&quot;</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">return </span><span class="s1">_make_method(</span>
        <span class="s3">&quot;__repr__&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(lines)</span><span class="s2">, </span><span class="s1">unique_filename</span><span class="s2">, </span><span class="s1">globs=globs</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_add_repr(cls</span><span class="s2">, </span><span class="s1">ns=</span><span class="s2">None, </span><span class="s1">attrs=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Add a repr method to *cls*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">attrs = cls.__attrs_attrs__</span>

    <span class="s1">cls.__repr__ = _make_repr(attrs</span><span class="s2">, </span><span class="s1">ns</span><span class="s2">, </span><span class="s1">cls)</span>
    <span class="s2">return </span><span class="s1">cls</span>


<span class="s2">def </span><span class="s1">fields(cls):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return the tuple of ``attrs`` attributes for a class. 
 
    The tuple also allows accessing the fields by their names (see below for 
    examples). 
 
    :param type cls: Class to introspect. 
 
    :raise TypeError: If *cls* is not a class. 
    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs`` 
        class. 
 
    :rtype: tuple (with name accessors) of `attrs.Attribute` 
 
    ..  versionchanged:: 16.2.0 Returned tuple allows accessing the fields 
        by name. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance(cls</span><span class="s2">, </span><span class="s1">type):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Passed object must be a class.&quot;</span><span class="s1">)</span>
    <span class="s1">attrs = getattr(cls</span><span class="s2">, </span><span class="s3">&quot;__attrs_attrs__&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotAnAttrsClassError(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">cls</span><span class="s2">!r} </span><span class="s3">is not an attrs-decorated class.&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">attrs</span>


<span class="s2">def </span><span class="s1">fields_dict(cls):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return an ordered dictionary of ``attrs`` attributes for a class, whose 
    keys are the attribute names. 
 
    :param type cls: Class to introspect. 
 
    :raise TypeError: If *cls* is not a class. 
    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs`` 
        class. 
 
    :rtype: dict 
 
    .. versionadded:: 18.1.0 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance(cls</span><span class="s2">, </span><span class="s1">type):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Passed object must be a class.&quot;</span><span class="s1">)</span>
    <span class="s1">attrs = getattr(cls</span><span class="s2">, </span><span class="s3">&quot;__attrs_attrs__&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotAnAttrsClassError(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">cls</span><span class="s2">!r} </span><span class="s3">is not an attrs-decorated class.&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">{a.name: a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs}</span>


<span class="s2">def </span><span class="s1">validate(inst):</span>
    <span class="s4">&quot;&quot;&quot; 
    Validate all attributes on *inst* that have a validator. 
 
    Leaves all exceptions through. 
 
    :param inst: Instance of a class with ``attrs`` attributes. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_config._run_validators </span><span class="s2">is False</span><span class="s1">:</span>
        <span class="s2">return</span>

    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">fields(inst.__class__):</span>
        <span class="s1">v = a.validator</span>
        <span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">v(inst</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">getattr(inst</span><span class="s2">, </span><span class="s1">a.name))</span>


<span class="s2">def </span><span class="s1">_is_slot_cls(cls):</span>
    <span class="s2">return </span><span class="s3">&quot;__slots__&quot; </span><span class="s2">in </span><span class="s1">cls.__dict__</span>


<span class="s2">def </span><span class="s1">_is_slot_attr(a_name</span><span class="s2">, </span><span class="s1">base_attr_map):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check if the attribute name comes from a slot class. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">a_name </span><span class="s2">in </span><span class="s1">base_attr_map </span><span class="s2">and </span><span class="s1">_is_slot_cls(base_attr_map[a_name])</span>


<span class="s2">def </span><span class="s1">_make_init(</span>
    <span class="s1">cls</span><span class="s2">,</span>
    <span class="s1">attrs</span><span class="s2">,</span>
    <span class="s1">pre_init</span><span class="s2">,</span>
    <span class="s1">post_init</span><span class="s2">,</span>
    <span class="s1">frozen</span><span class="s2">,</span>
    <span class="s1">slots</span><span class="s2">,</span>
    <span class="s1">cache_hash</span><span class="s2">,</span>
    <span class="s1">base_attr_map</span><span class="s2">,</span>
    <span class="s1">is_exc</span><span class="s2">,</span>
    <span class="s1">cls_on_setattr</span><span class="s2">,</span>
    <span class="s1">attrs_init</span><span class="s2">,</span>
<span class="s1">):</span>
    <span class="s1">has_cls_on_setattr = (</span>
        <span class="s1">cls_on_setattr </span><span class="s2">is not None and </span><span class="s1">cls_on_setattr </span><span class="s2">is not </span><span class="s1">setters.NO_OP</span>
    <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">frozen </span><span class="s2">and </span><span class="s1">has_cls_on_setattr:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Frozen classes can't use on_setattr.&quot;</span><span class="s1">)</span>

    <span class="s1">needs_cached_setattr = cache_hash </span><span class="s2">or </span><span class="s1">frozen</span>
    <span class="s1">filtered_attrs = []</span>
    <span class="s1">attr_dict = {}</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s2">if not </span><span class="s1">a.init </span><span class="s2">and </span><span class="s1">a.default </span><span class="s2">is </span><span class="s1">NOTHING:</span>
            <span class="s2">continue</span>

        <span class="s1">filtered_attrs.append(a)</span>
        <span class="s1">attr_dict[a.name] = a</span>

        <span class="s2">if </span><span class="s1">a.on_setattr </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">frozen </span><span class="s2">is True</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Frozen classes can't use on_setattr.&quot;</span><span class="s1">)</span>

            <span class="s1">needs_cached_setattr = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">has_cls_on_setattr </span><span class="s2">and </span><span class="s1">a.on_setattr </span><span class="s2">is not </span><span class="s1">setters.NO_OP:</span>
            <span class="s1">needs_cached_setattr = </span><span class="s2">True</span>

    <span class="s1">unique_filename = _generate_unique_filename(cls</span><span class="s2">, </span><span class="s3">&quot;init&quot;</span><span class="s1">)</span>

    <span class="s1">script</span><span class="s2">, </span><span class="s1">globs</span><span class="s2">, </span><span class="s1">annotations = _attrs_to_init_script(</span>
        <span class="s1">filtered_attrs</span><span class="s2">,</span>
        <span class="s1">frozen</span><span class="s2">,</span>
        <span class="s1">slots</span><span class="s2">,</span>
        <span class="s1">pre_init</span><span class="s2">,</span>
        <span class="s1">post_init</span><span class="s2">,</span>
        <span class="s1">cache_hash</span><span class="s2">,</span>
        <span class="s1">base_attr_map</span><span class="s2">,</span>
        <span class="s1">is_exc</span><span class="s2">,</span>
        <span class="s1">needs_cached_setattr</span><span class="s2">,</span>
        <span class="s1">has_cls_on_setattr</span><span class="s2">,</span>
        <span class="s1">attrs_init</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">if </span><span class="s1">cls.__module__ </span><span class="s2">in </span><span class="s1">sys.modules:</span>
        <span class="s0"># This makes typing.get_type_hints(CLS.__init__) resolve string types.</span>
        <span class="s1">globs.update(sys.modules[cls.__module__].__dict__)</span>

    <span class="s1">globs.update({</span><span class="s3">&quot;NOTHING&quot;</span><span class="s1">: NOTHING</span><span class="s2">, </span><span class="s3">&quot;attr_dict&quot;</span><span class="s1">: attr_dict})</span>

    <span class="s2">if </span><span class="s1">needs_cached_setattr:</span>
        <span class="s0"># Save the lookup overhead in __init__ if we need to circumvent</span>
        <span class="s0"># setattr hooks.</span>
        <span class="s1">globs[</span><span class="s3">&quot;_cached_setattr_get&quot;</span><span class="s1">] = _obj_setattr.__get__</span>

    <span class="s1">init = _make_method(</span>
        <span class="s3">&quot;__attrs_init__&quot; </span><span class="s2">if </span><span class="s1">attrs_init </span><span class="s2">else </span><span class="s3">&quot;__init__&quot;</span><span class="s2">,</span>
        <span class="s1">script</span><span class="s2">,</span>
        <span class="s1">unique_filename</span><span class="s2">,</span>
        <span class="s1">globs</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">init.__annotations__ = annotations</span>

    <span class="s2">return </span><span class="s1">init</span>


<span class="s2">def </span><span class="s1">_setattr(attr_name</span><span class="s2">, </span><span class="s1">value_var</span><span class="s2">, </span><span class="s1">has_on_setattr):</span>
    <span class="s4">&quot;&quot;&quot; 
    Use the cached object.setattr to set *attr_name* to *value_var*. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s3">f&quot;_setattr('</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s3">', </span><span class="s2">{</span><span class="s1">value_var</span><span class="s2">}</span><span class="s3">)&quot;</span>


<span class="s2">def </span><span class="s1">_setattr_with_converter(attr_name</span><span class="s2">, </span><span class="s1">value_var</span><span class="s2">, </span><span class="s1">has_on_setattr):</span>
    <span class="s4">&quot;&quot;&quot; 
    Use the cached object.setattr to set *attr_name* to *value_var*, but run 
    its converter first. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s3">&quot;_setattr('%s', %s(%s))&quot; </span><span class="s1">% (</span>
        <span class="s1">attr_name</span><span class="s2">,</span>
        <span class="s1">_init_converter_pat % (attr_name</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">value_var</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_assign(attr_name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">has_on_setattr):</span>
    <span class="s4">&quot;&quot;&quot; 
    Unless *attr_name* has an on_setattr hook, use normal assignment. Otherwise 
    relegate to _setattr. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">has_on_setattr:</span>
        <span class="s2">return </span><span class="s1">_setattr(attr_name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s3">f&quot;self.</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">} </span><span class="s3">= </span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s3">&quot;</span>


<span class="s2">def </span><span class="s1">_assign_with_converter(attr_name</span><span class="s2">, </span><span class="s1">value_var</span><span class="s2">, </span><span class="s1">has_on_setattr):</span>
    <span class="s4">&quot;&quot;&quot; 
    Unless *attr_name* has an on_setattr hook, use normal assignment after 
    conversion. Otherwise relegate to _setattr_with_converter. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">has_on_setattr:</span>
        <span class="s2">return </span><span class="s1">_setattr_with_converter(attr_name</span><span class="s2">, </span><span class="s1">value_var</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s3">&quot;self.%s = %s(%s)&quot; </span><span class="s1">% (</span>
        <span class="s1">attr_name</span><span class="s2">,</span>
        <span class="s1">_init_converter_pat % (attr_name</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">value_var</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_attrs_to_init_script(</span>
    <span class="s1">attrs</span><span class="s2">,</span>
    <span class="s1">frozen</span><span class="s2">,</span>
    <span class="s1">slots</span><span class="s2">,</span>
    <span class="s1">pre_init</span><span class="s2">,</span>
    <span class="s1">post_init</span><span class="s2">,</span>
    <span class="s1">cache_hash</span><span class="s2">,</span>
    <span class="s1">base_attr_map</span><span class="s2">,</span>
    <span class="s1">is_exc</span><span class="s2">,</span>
    <span class="s1">needs_cached_setattr</span><span class="s2">,</span>
    <span class="s1">has_cls_on_setattr</span><span class="s2">,</span>
    <span class="s1">attrs_init</span><span class="s2">,</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return a script of an initializer for *attrs* and a dict of globals. 
 
    The globals are expected by the generated script. 
 
    If *frozen* is True, we cannot set the attributes directly so we use 
    a cached ``object.__setattr__``. 
    &quot;&quot;&quot;</span>
    <span class="s1">lines = []</span>
    <span class="s2">if </span><span class="s1">pre_init:</span>
        <span class="s1">lines.append(</span><span class="s3">&quot;self.__attrs_pre_init__()&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">needs_cached_setattr:</span>
        <span class="s1">lines.append(</span>
            <span class="s0"># Circumvent the __setattr__ descriptor to save one lookup per</span>
            <span class="s0"># assignment.</span>
            <span class="s0"># Note _setattr will be used again below if cache_hash is True</span>
            <span class="s3">&quot;_setattr = _cached_setattr_get(self)&quot;</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">frozen </span><span class="s2">is True</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">slots </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s1">fmt_setter = _setattr</span>
            <span class="s1">fmt_setter_with_converter = _setattr_with_converter</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Dict frozen classes assign directly to __dict__.</span>
            <span class="s0"># But only if the attribute doesn't come from an ancestor slot</span>
            <span class="s0"># class.</span>
            <span class="s0"># Note _inst_dict will be used again below if cache_hash is True</span>
            <span class="s1">lines.append(</span><span class="s3">&quot;_inst_dict = self.__dict__&quot;</span><span class="s1">)</span>

            <span class="s2">def </span><span class="s1">fmt_setter(attr_name</span><span class="s2">, </span><span class="s1">value_var</span><span class="s2">, </span><span class="s1">has_on_setattr):</span>
                <span class="s2">if </span><span class="s1">_is_slot_attr(attr_name</span><span class="s2">, </span><span class="s1">base_attr_map):</span>
                    <span class="s2">return </span><span class="s1">_setattr(attr_name</span><span class="s2">, </span><span class="s1">value_var</span><span class="s2">, </span><span class="s1">has_on_setattr)</span>

                <span class="s2">return </span><span class="s3">f&quot;_inst_dict['</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s3">'] = </span><span class="s2">{</span><span class="s1">value_var</span><span class="s2">}</span><span class="s3">&quot;</span>

            <span class="s2">def </span><span class="s1">fmt_setter_with_converter(</span>
                <span class="s1">attr_name</span><span class="s2">, </span><span class="s1">value_var</span><span class="s2">, </span><span class="s1">has_on_setattr</span>
            <span class="s1">):</span>
                <span class="s2">if </span><span class="s1">has_on_setattr </span><span class="s2">or </span><span class="s1">_is_slot_attr(attr_name</span><span class="s2">, </span><span class="s1">base_attr_map):</span>
                    <span class="s2">return </span><span class="s1">_setattr_with_converter(</span>
                        <span class="s1">attr_name</span><span class="s2">, </span><span class="s1">value_var</span><span class="s2">, </span><span class="s1">has_on_setattr</span>
                    <span class="s1">)</span>

                <span class="s2">return </span><span class="s3">&quot;_inst_dict['%s'] = %s(%s)&quot; </span><span class="s1">% (</span>
                    <span class="s1">attr_name</span><span class="s2">,</span>
                    <span class="s1">_init_converter_pat % (attr_name</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">value_var</span><span class="s2">,</span>
                <span class="s1">)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># Not frozen.</span>
        <span class="s1">fmt_setter = _assign</span>
        <span class="s1">fmt_setter_with_converter = _assign_with_converter</span>

    <span class="s1">args = []</span>
    <span class="s1">kw_only_args = []</span>
    <span class="s1">attrs_to_validate = []</span>

    <span class="s0"># This is a dictionary of names to validator and converter callables.</span>
    <span class="s0"># Injecting this into __init__ globals lets us avoid lookups.</span>
    <span class="s1">names_for_globals = {}</span>
    <span class="s1">annotations = {</span><span class="s3">&quot;return&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">}</span>

    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s2">if </span><span class="s1">a.validator:</span>
            <span class="s1">attrs_to_validate.append(a)</span>

        <span class="s1">attr_name = a.name</span>
        <span class="s1">has_on_setattr = a.on_setattr </span><span class="s2">is not None or </span><span class="s1">(</span>
            <span class="s1">a.on_setattr </span><span class="s2">is not </span><span class="s1">setters.NO_OP </span><span class="s2">and </span><span class="s1">has_cls_on_setattr</span>
        <span class="s1">)</span>
        <span class="s0"># a.alias is set to maybe-mangled attr_name in _ClassBuilder if not</span>
        <span class="s0"># explicitly provided</span>
        <span class="s1">arg_name = a.alias</span>

        <span class="s1">has_factory = isinstance(a.default</span><span class="s2">, </span><span class="s1">Factory)</span>
        <span class="s2">if </span><span class="s1">has_factory </span><span class="s2">and </span><span class="s1">a.default.takes_self:</span>
            <span class="s1">maybe_self = </span><span class="s3">&quot;self&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">maybe_self = </span><span class="s3">&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">a.init </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">has_factory:</span>
                <span class="s1">init_factory_name = _init_factory_pat % (a.name</span><span class="s2">,</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">a.converter </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">lines.append(</span>
                        <span class="s1">fmt_setter_with_converter(</span>
                            <span class="s1">attr_name</span><span class="s2">,</span>
                            <span class="s1">init_factory_name + </span><span class="s3">f&quot;(</span><span class="s2">{</span><span class="s1">maybe_self</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s2">,</span>
                            <span class="s1">has_on_setattr</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                    <span class="s1">conv_name = _init_converter_pat % (a.name</span><span class="s2">,</span><span class="s1">)</span>
                    <span class="s1">names_for_globals[conv_name] = a.converter</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">lines.append(</span>
                        <span class="s1">fmt_setter(</span>
                            <span class="s1">attr_name</span><span class="s2">,</span>
                            <span class="s1">init_factory_name + </span><span class="s3">f&quot;(</span><span class="s2">{</span><span class="s1">maybe_self</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s2">,</span>
                            <span class="s1">has_on_setattr</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s1">names_for_globals[init_factory_name] = a.default.factory</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">a.converter </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">lines.append(</span>
                        <span class="s1">fmt_setter_with_converter(</span>
                            <span class="s1">attr_name</span><span class="s2">,</span>
                            <span class="s3">f&quot;attr_dict['</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s3">'].default&quot;</span><span class="s2">,</span>
                            <span class="s1">has_on_setattr</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                    <span class="s1">conv_name = _init_converter_pat % (a.name</span><span class="s2">,</span><span class="s1">)</span>
                    <span class="s1">names_for_globals[conv_name] = a.converter</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">lines.append(</span>
                        <span class="s1">fmt_setter(</span>
                            <span class="s1">attr_name</span><span class="s2">,</span>
                            <span class="s3">f&quot;attr_dict['</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s3">'].default&quot;</span><span class="s2">,</span>
                            <span class="s1">has_on_setattr</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">a.default </span><span class="s2">is not </span><span class="s1">NOTHING </span><span class="s2">and not </span><span class="s1">has_factory:</span>
            <span class="s1">arg = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">arg_name</span><span class="s2">}</span><span class="s3">=attr_dict['</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s3">'].default&quot;</span>
            <span class="s2">if </span><span class="s1">a.kw_only:</span>
                <span class="s1">kw_only_args.append(arg)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">args.append(arg)</span>

            <span class="s2">if </span><span class="s1">a.converter </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">lines.append(</span>
                    <span class="s1">fmt_setter_with_converter(</span>
                        <span class="s1">attr_name</span><span class="s2">, </span><span class="s1">arg_name</span><span class="s2">, </span><span class="s1">has_on_setattr</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">names_for_globals[</span>
                    <span class="s1">_init_converter_pat % (a.name</span><span class="s2">,</span><span class="s1">)</span>
                <span class="s1">] = a.converter</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">lines.append(fmt_setter(attr_name</span><span class="s2">, </span><span class="s1">arg_name</span><span class="s2">, </span><span class="s1">has_on_setattr))</span>

        <span class="s2">elif </span><span class="s1">has_factory:</span>
            <span class="s1">arg = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">arg_name</span><span class="s2">}</span><span class="s3">=NOTHING&quot;</span>
            <span class="s2">if </span><span class="s1">a.kw_only:</span>
                <span class="s1">kw_only_args.append(arg)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">args.append(arg)</span>
            <span class="s1">lines.append(</span><span class="s3">f&quot;if </span><span class="s2">{</span><span class="s1">arg_name</span><span class="s2">} </span><span class="s3">is not NOTHING:&quot;</span><span class="s1">)</span>

            <span class="s1">init_factory_name = _init_factory_pat % (a.name</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">a.converter </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">lines.append(</span>
                    <span class="s3">&quot;    &quot;</span>
                    <span class="s1">+ fmt_setter_with_converter(</span>
                        <span class="s1">attr_name</span><span class="s2">, </span><span class="s1">arg_name</span><span class="s2">, </span><span class="s1">has_on_setattr</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">lines.append(</span><span class="s3">&quot;else:&quot;</span><span class="s1">)</span>
                <span class="s1">lines.append(</span>
                    <span class="s3">&quot;    &quot;</span>
                    <span class="s1">+ fmt_setter_with_converter(</span>
                        <span class="s1">attr_name</span><span class="s2">,</span>
                        <span class="s1">init_factory_name + </span><span class="s3">&quot;(&quot; </span><span class="s1">+ maybe_self + </span><span class="s3">&quot;)&quot;</span><span class="s2">,</span>
                        <span class="s1">has_on_setattr</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">names_for_globals[</span>
                    <span class="s1">_init_converter_pat % (a.name</span><span class="s2">,</span><span class="s1">)</span>
                <span class="s1">] = a.converter</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">lines.append(</span>
                    <span class="s3">&quot;    &quot; </span><span class="s1">+ fmt_setter(attr_name</span><span class="s2">, </span><span class="s1">arg_name</span><span class="s2">, </span><span class="s1">has_on_setattr)</span>
                <span class="s1">)</span>
                <span class="s1">lines.append(</span><span class="s3">&quot;else:&quot;</span><span class="s1">)</span>
                <span class="s1">lines.append(</span>
                    <span class="s3">&quot;    &quot;</span>
                    <span class="s1">+ fmt_setter(</span>
                        <span class="s1">attr_name</span><span class="s2">,</span>
                        <span class="s1">init_factory_name + </span><span class="s3">&quot;(&quot; </span><span class="s1">+ maybe_self + </span><span class="s3">&quot;)&quot;</span><span class="s2">,</span>
                        <span class="s1">has_on_setattr</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">names_for_globals[init_factory_name] = a.default.factory</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">a.kw_only:</span>
                <span class="s1">kw_only_args.append(arg_name)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">args.append(arg_name)</span>

            <span class="s2">if </span><span class="s1">a.converter </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">lines.append(</span>
                    <span class="s1">fmt_setter_with_converter(</span>
                        <span class="s1">attr_name</span><span class="s2">, </span><span class="s1">arg_name</span><span class="s2">, </span><span class="s1">has_on_setattr</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">names_for_globals[</span>
                    <span class="s1">_init_converter_pat % (a.name</span><span class="s2">,</span><span class="s1">)</span>
                <span class="s1">] = a.converter</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">lines.append(fmt_setter(attr_name</span><span class="s2">, </span><span class="s1">arg_name</span><span class="s2">, </span><span class="s1">has_on_setattr))</span>

        <span class="s2">if </span><span class="s1">a.init </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">a.type </span><span class="s2">is not None and </span><span class="s1">a.converter </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">annotations[arg_name] = a.type</span>
            <span class="s2">elif </span><span class="s1">a.converter </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s0"># Try to get the type from the converter.</span>
                <span class="s1">t = _AnnotationExtractor(a.converter).get_first_param_type()</span>
                <span class="s2">if </span><span class="s1">t:</span>
                    <span class="s1">annotations[arg_name] = t</span>

    <span class="s2">if </span><span class="s1">attrs_to_validate:  </span><span class="s0"># we can skip this if there are no validators.</span>
        <span class="s1">names_for_globals[</span><span class="s3">&quot;_config&quot;</span><span class="s1">] = _config</span>
        <span class="s1">lines.append(</span><span class="s3">&quot;if _config._run_validators is True:&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs_to_validate:</span>
            <span class="s1">val_name = </span><span class="s3">&quot;__attr_validator_&quot; </span><span class="s1">+ a.name</span>
            <span class="s1">attr_name = </span><span class="s3">&quot;__attr_&quot; </span><span class="s1">+ a.name</span>
            <span class="s1">lines.append(</span><span class="s3">f&quot;    </span><span class="s2">{</span><span class="s1">val_name</span><span class="s2">}</span><span class="s3">(self, </span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s3">, self.</span><span class="s2">{</span><span class="s1">a.name</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>
            <span class="s1">names_for_globals[val_name] = a.validator</span>
            <span class="s1">names_for_globals[attr_name] = a</span>

    <span class="s2">if </span><span class="s1">post_init:</span>
        <span class="s1">lines.append(</span><span class="s3">&quot;self.__attrs_post_init__()&quot;</span><span class="s1">)</span>

    <span class="s0"># because this is set only after __attrs_post_init__ is called, a crash</span>
    <span class="s0"># will result if post-init tries to access the hash code.  This seemed</span>
    <span class="s0"># preferable to setting this beforehand, in which case alteration to</span>
    <span class="s0"># field values during post-init combined with post-init accessing the</span>
    <span class="s0"># hash code would result in silent bugs.</span>
    <span class="s2">if </span><span class="s1">cache_hash:</span>
        <span class="s2">if </span><span class="s1">frozen:</span>
            <span class="s2">if </span><span class="s1">slots:</span>
                <span class="s0"># if frozen and slots, then _setattr defined above</span>
                <span class="s1">init_hash_cache = </span><span class="s3">&quot;_setattr('%s', %s)&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># if frozen and not slots, then _inst_dict defined above</span>
                <span class="s1">init_hash_cache = </span><span class="s3">&quot;_inst_dict['%s'] = %s&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">init_hash_cache = </span><span class="s3">&quot;self.%s = %s&quot;</span>
        <span class="s1">lines.append(init_hash_cache % (_hash_cache_field</span><span class="s2">, </span><span class="s3">&quot;None&quot;</span><span class="s1">))</span>

    <span class="s0"># For exceptions we rely on BaseException.__init__ for proper</span>
    <span class="s0"># initialization.</span>
    <span class="s2">if </span><span class="s1">is_exc:</span>
        <span class="s1">vals = </span><span class="s3">&quot;,&quot;</span><span class="s1">.join(</span><span class="s3">f&quot;self.</span><span class="s2">{</span><span class="s1">a.name</span><span class="s2">}</span><span class="s3">&quot; </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs </span><span class="s2">if </span><span class="s1">a.init)</span>

        <span class="s1">lines.append(</span><span class="s3">f&quot;BaseException.__init__(self, </span><span class="s2">{</span><span class="s1">vals</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>

    <span class="s1">args = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(args)</span>
    <span class="s2">if </span><span class="s1">kw_only_args:</span>
        <span class="s1">args += </span><span class="s3">&quot;%s*, %s&quot; </span><span class="s1">% (</span>
            <span class="s3">&quot;, &quot; </span><span class="s2">if </span><span class="s1">args </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s2">,  </span><span class="s0"># leading comma</span>
            <span class="s3">&quot;, &quot;</span><span class="s1">.join(kw_only_args)</span><span class="s2">,  </span><span class="s0"># kw_only args</span>
        <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">(</span>
        <span class="s3">&quot;def %s(self, %s):</span><span class="s2">\n    </span><span class="s3">%s</span><span class="s2">\n</span><span class="s3">&quot;</span>
        <span class="s1">% (</span>
            <span class="s1">(</span><span class="s3">&quot;__attrs_init__&quot; </span><span class="s2">if </span><span class="s1">attrs_init </span><span class="s2">else </span><span class="s3">&quot;__init__&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">args</span><span class="s2">,</span>
            <span class="s3">&quot;</span><span class="s2">\n    </span><span class="s3">&quot;</span><span class="s1">.join(lines) </span><span class="s2">if </span><span class="s1">lines </span><span class="s2">else </span><span class="s3">&quot;pass&quot;</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">names_for_globals</span><span class="s2">,</span>
        <span class="s1">annotations</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_default_init_alias_for(name: str) -&gt; str:</span>
    <span class="s4">&quot;&quot;&quot; 
    The default __init__ parameter name for a field. 
 
    This performs private-name adjustment via leading-unscore stripping, 
    and is the default value of Attribute.alias if not provided. 
    &quot;&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">name.lstrip(</span><span class="s3">&quot;_&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Attribute:</span>
    <span class="s4">&quot;&quot;&quot; 
    *Read-only* representation of an attribute. 
 
    The class has *all* arguments of `attr.ib` (except for ``factory`` 
    which is only syntactic sugar for ``default=Factory(...)`` plus the 
    following: 
 
    - ``name`` (`str`): The name of the attribute. 
    - ``alias`` (`str`): The __init__ parameter name of the attribute, after 
      any explicit overrides and default private-attribute-name handling. 
    - ``inherited`` (`bool`): Whether or not that attribute has been inherited 
      from a base class. 
    - ``eq_key`` and ``order_key`` (`typing.Callable` or `None`): The callables 
      that are used for comparing and ordering objects by this attribute, 
      respectively. These are set by passing a callable to `attr.ib`'s ``eq``, 
      ``order``, or ``cmp`` arguments. See also :ref:`comparison customization 
      &lt;custom-comparison&gt;`. 
 
    Instances of this class are frequently used for introspection purposes 
    like: 
 
    - `fields` returns a tuple of them. 
    - Validators get them passed as the first argument. 
    - The :ref:`field transformer &lt;transform-fields&gt;` hook receives a list of 
      them. 
    - The ``alias`` property exposes the __init__ parameter name of the field, 
      with any overrides and default private-attribute handling applied. 
 
 
    .. versionadded:: 20.1.0 *inherited* 
    .. versionadded:: 20.1.0 *on_setattr* 
    .. versionchanged:: 20.2.0 *inherited* is not taken into account for 
        equality checks and hashing anymore. 
    .. versionadded:: 21.1.0 *eq_key* and *order_key* 
    .. versionadded:: 22.2.0 *alias* 
 
    For the full version history of the fields, see `attr.ib`. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span>
        <span class="s3">&quot;name&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;default&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;validator&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;repr&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;eq&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;eq_key&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;order&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;order_key&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;hash&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;init&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;metadata&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;type&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;converter&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;kw_only&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;inherited&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;on_setattr&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;alias&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">,</span>
        <span class="s1">default</span><span class="s2">,</span>
        <span class="s1">validator</span><span class="s2">,</span>
        <span class="s1">repr</span><span class="s2">,</span>
        <span class="s1">cmp</span><span class="s2">,  </span><span class="s0"># XXX: unused, remove along with other cmp code.</span>
        <span class="s1">hash</span><span class="s2">,</span>
        <span class="s1">init</span><span class="s2">,</span>
        <span class="s1">inherited</span><span class="s2">,</span>
        <span class="s1">metadata=</span><span class="s2">None,</span>
        <span class="s1">type=</span><span class="s2">None,</span>
        <span class="s1">converter=</span><span class="s2">None,</span>
        <span class="s1">kw_only=</span><span class="s2">False,</span>
        <span class="s1">eq=</span><span class="s2">None,</span>
        <span class="s1">eq_key=</span><span class="s2">None,</span>
        <span class="s1">order=</span><span class="s2">None,</span>
        <span class="s1">order_key=</span><span class="s2">None,</span>
        <span class="s1">on_setattr=</span><span class="s2">None,</span>
        <span class="s1">alias=</span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">eq</span><span class="s2">, </span><span class="s1">eq_key</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">order_key = _determine_attrib_eq_order(</span>
            <span class="s1">cmp</span><span class="s2">, </span><span class="s1">eq_key </span><span class="s2">or </span><span class="s1">eq</span><span class="s2">, </span><span class="s1">order_key </span><span class="s2">or </span><span class="s1">order</span><span class="s2">, True</span>
        <span class="s1">)</span>

        <span class="s0"># Cache this descriptor here to speed things up later.</span>
        <span class="s1">bound_setattr = _obj_setattr.__get__(self)</span>

        <span class="s0"># Despite the big red warning, people *do* instantiate `Attribute`</span>
        <span class="s0"># themselves.</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;default&quot;</span><span class="s2">, </span><span class="s1">default)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;validator&quot;</span><span class="s2">, </span><span class="s1">validator)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;repr&quot;</span><span class="s2">, </span><span class="s1">repr)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;eq&quot;</span><span class="s2">, </span><span class="s1">eq)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;eq_key&quot;</span><span class="s2">, </span><span class="s1">eq_key)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;order&quot;</span><span class="s2">, </span><span class="s1">order)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;order_key&quot;</span><span class="s2">, </span><span class="s1">order_key)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;hash&quot;</span><span class="s2">, </span><span class="s1">hash)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;init&quot;</span><span class="s2">, </span><span class="s1">init)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;converter&quot;</span><span class="s2">, </span><span class="s1">converter)</span>
        <span class="s1">bound_setattr(</span>
            <span class="s3">&quot;metadata&quot;</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">types.MappingProxyType(dict(metadata))  </span><span class="s0"># Shallow copy</span>
                <span class="s2">if </span><span class="s1">metadata</span>
                <span class="s2">else </span><span class="s1">_empty_metadata_singleton</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;type&quot;</span><span class="s2">, </span><span class="s1">type)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;kw_only&quot;</span><span class="s2">, </span><span class="s1">kw_only)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;inherited&quot;</span><span class="s2">, </span><span class="s1">inherited)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;on_setattr&quot;</span><span class="s2">, </span><span class="s1">on_setattr)</span>
        <span class="s1">bound_setattr(</span><span class="s3">&quot;alias&quot;</span><span class="s2">, </span><span class="s1">alias)</span>

    <span class="s2">def </span><span class="s1">__setattr__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">raise </span><span class="s1">FrozenInstanceError()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_counting_attr(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">ca</span><span class="s2">, </span><span class="s1">type=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># type holds the annotated value. deal with conflicts:</span>
        <span class="s2">if </span><span class="s1">type </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">type = ca.type</span>
        <span class="s2">elif </span><span class="s1">ca.type </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Type annotation and type argument cannot both be present&quot;</span>
            <span class="s1">)</span>
        <span class="s1">inst_dict = {</span>
            <span class="s1">k: getattr(ca</span><span class="s2">, </span><span class="s1">k)</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">Attribute.__slots__</span>
            <span class="s2">if </span><span class="s1">k</span>
            <span class="s2">not in </span><span class="s1">(</span>
                <span class="s3">&quot;name&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;validator&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;default&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;type&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;inherited&quot;</span><span class="s2">,</span>
            <span class="s1">)  </span><span class="s0"># exclude methods and deprecated alias</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=name</span><span class="s2">,</span>
            <span class="s1">validator=ca._validator</span><span class="s2">,</span>
            <span class="s1">default=ca._default</span><span class="s2">,</span>
            <span class="s1">type=type</span><span class="s2">,</span>
            <span class="s1">cmp=</span><span class="s2">None,</span>
            <span class="s1">inherited=</span><span class="s2">False,</span>
            <span class="s1">**inst_dict</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s0"># Don't use attr.evolve since fields(Attribute) doesn't work</span>
    <span class="s2">def </span><span class="s1">evolve(self</span><span class="s2">, </span><span class="s1">**changes):</span>
        <span class="s4">&quot;&quot;&quot; 
        Copy *self* and apply *changes*. 
 
        This works similarly to `attr.evolve` but that function does not work 
        with ``Attribute``. 
 
        It is mainly meant to be used for `transform-fields`. 
 
        .. versionadded:: 20.3.0 
        &quot;&quot;&quot;</span>
        <span class="s1">new = copy.copy(self)</span>

        <span class="s1">new._setattrs(changes.items())</span>

        <span class="s2">return </span><span class="s1">new</span>

    <span class="s0"># Don't use _add_pickle since fields(Attribute) doesn't work</span>
    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Play nice with pickle. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">tuple(</span>
            <span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">name) </span><span class="s2">if </span><span class="s1">name != </span><span class="s3">&quot;metadata&quot; </span><span class="s2">else </span><span class="s1">dict(self.metadata)</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.__slots__</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state):</span>
        <span class="s4">&quot;&quot;&quot; 
        Play nice with pickle. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._setattrs(zip(self.__slots__</span><span class="s2">, </span><span class="s1">state))</span>

    <span class="s2">def </span><span class="s1">_setattrs(self</span><span class="s2">, </span><span class="s1">name_values_pairs):</span>
        <span class="s1">bound_setattr = _obj_setattr.__get__(self)</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">name_values_pairs:</span>
            <span class="s2">if </span><span class="s1">name != </span><span class="s3">&quot;metadata&quot;</span><span class="s1">:</span>
                <span class="s1">bound_setattr(name</span><span class="s2">, </span><span class="s1">value)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">bound_setattr(</span>
                    <span class="s1">name</span><span class="s2">,</span>
                    <span class="s1">types.MappingProxyType(dict(value))</span>
                    <span class="s2">if </span><span class="s1">value</span>
                    <span class="s2">else </span><span class="s1">_empty_metadata_singleton</span><span class="s2">,</span>
                <span class="s1">)</span>


<span class="s1">_a = [</span>
    <span class="s1">Attribute(</span>
        <span class="s1">name=name</span><span class="s2">,</span>
        <span class="s1">default=NOTHING</span><span class="s2">,</span>
        <span class="s1">validator=</span><span class="s2">None,</span>
        <span class="s1">repr=</span><span class="s2">True,</span>
        <span class="s1">cmp=</span><span class="s2">None,</span>
        <span class="s1">eq=</span><span class="s2">True,</span>
        <span class="s1">order=</span><span class="s2">False,</span>
        <span class="s1">hash=(name != </span><span class="s3">&quot;metadata&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">init=</span><span class="s2">True,</span>
        <span class="s1">inherited=</span><span class="s2">False,</span>
        <span class="s1">alias=_default_init_alias_for(name)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">Attribute.__slots__</span>
<span class="s1">]</span>

<span class="s1">Attribute = _add_hash(</span>
    <span class="s1">_add_eq(</span>
        <span class="s1">_add_repr(Attribute</span><span class="s2">, </span><span class="s1">attrs=_a)</span><span class="s2">,</span>
        <span class="s1">attrs=[a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">_a </span><span class="s2">if </span><span class="s1">a.name != </span><span class="s3">&quot;inherited&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">attrs=[a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">_a </span><span class="s2">if </span><span class="s1">a.hash </span><span class="s2">and </span><span class="s1">a.name != </span><span class="s3">&quot;inherited&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">class </span><span class="s1">_CountingAttr:</span>
    <span class="s4">&quot;&quot;&quot; 
    Intermediate representation of attributes that uses a counter to preserve 
    the order in which the attributes have been defined. 
 
    *Internal* data structure of the attrs library.  Running into is most 
    likely the result of a bug like a forgotten `@attr.s` decorator. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span>
        <span class="s3">&quot;counter&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_default&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;repr&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;eq&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;eq_key&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;order&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;order_key&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;hash&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;init&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;metadata&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_validator&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;converter&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;type&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;kw_only&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;on_setattr&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;alias&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">__attrs_attrs__ = tuple(</span>
        <span class="s1">Attribute(</span>
            <span class="s1">name=name</span><span class="s2">,</span>
            <span class="s1">alias=_default_init_alias_for(name)</span><span class="s2">,</span>
            <span class="s1">default=NOTHING</span><span class="s2">,</span>
            <span class="s1">validator=</span><span class="s2">None,</span>
            <span class="s1">repr=</span><span class="s2">True,</span>
            <span class="s1">cmp=</span><span class="s2">None,</span>
            <span class="s1">hash=</span><span class="s2">True,</span>
            <span class="s1">init=</span><span class="s2">True,</span>
            <span class="s1">kw_only=</span><span class="s2">False,</span>
            <span class="s1">eq=</span><span class="s2">True,</span>
            <span class="s1">eq_key=</span><span class="s2">None,</span>
            <span class="s1">order=</span><span class="s2">False,</span>
            <span class="s1">order_key=</span><span class="s2">None,</span>
            <span class="s1">inherited=</span><span class="s2">False,</span>
            <span class="s1">on_setattr=</span><span class="s2">None,</span>
        <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(</span>
            <span class="s3">&quot;counter&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;_default&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;repr&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;eq&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;order&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;hash&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;init&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;on_setattr&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;alias&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s1">) + (</span>
        <span class="s1">Attribute(</span>
            <span class="s1">name=</span><span class="s3">&quot;metadata&quot;</span><span class="s2">,</span>
            <span class="s1">alias=</span><span class="s3">&quot;metadata&quot;</span><span class="s2">,</span>
            <span class="s1">default=</span><span class="s2">None,</span>
            <span class="s1">validator=</span><span class="s2">None,</span>
            <span class="s1">repr=</span><span class="s2">True,</span>
            <span class="s1">cmp=</span><span class="s2">None,</span>
            <span class="s1">hash=</span><span class="s2">False,</span>
            <span class="s1">init=</span><span class="s2">True,</span>
            <span class="s1">kw_only=</span><span class="s2">False,</span>
            <span class="s1">eq=</span><span class="s2">True,</span>
            <span class="s1">eq_key=</span><span class="s2">None,</span>
            <span class="s1">order=</span><span class="s2">False,</span>
            <span class="s1">order_key=</span><span class="s2">None,</span>
            <span class="s1">inherited=</span><span class="s2">False,</span>
            <span class="s1">on_setattr=</span><span class="s2">None,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">cls_counter = </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">default</span><span class="s2">,</span>
        <span class="s1">validator</span><span class="s2">,</span>
        <span class="s1">repr</span><span class="s2">,</span>
        <span class="s1">cmp</span><span class="s2">,</span>
        <span class="s1">hash</span><span class="s2">,</span>
        <span class="s1">init</span><span class="s2">,</span>
        <span class="s1">converter</span><span class="s2">,</span>
        <span class="s1">metadata</span><span class="s2">,</span>
        <span class="s1">type</span><span class="s2">,</span>
        <span class="s1">kw_only</span><span class="s2">,</span>
        <span class="s1">eq</span><span class="s2">,</span>
        <span class="s1">eq_key</span><span class="s2">,</span>
        <span class="s1">order</span><span class="s2">,</span>
        <span class="s1">order_key</span><span class="s2">,</span>
        <span class="s1">on_setattr</span><span class="s2">,</span>
        <span class="s1">alias</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">_CountingAttr.cls_counter += </span><span class="s5">1</span>
        <span class="s1">self.counter = _CountingAttr.cls_counter</span>
        <span class="s1">self._default = default</span>
        <span class="s1">self._validator = validator</span>
        <span class="s1">self.converter = converter</span>
        <span class="s1">self.repr = repr</span>
        <span class="s1">self.eq = eq</span>
        <span class="s1">self.eq_key = eq_key</span>
        <span class="s1">self.order = order</span>
        <span class="s1">self.order_key = order_key</span>
        <span class="s1">self.hash = hash</span>
        <span class="s1">self.init = init</span>
        <span class="s1">self.metadata = metadata</span>
        <span class="s1">self.type = type</span>
        <span class="s1">self.kw_only = kw_only</span>
        <span class="s1">self.on_setattr = on_setattr</span>
        <span class="s1">self.alias = alias</span>

    <span class="s2">def </span><span class="s1">validator(self</span><span class="s2">, </span><span class="s1">meth):</span>
        <span class="s4">&quot;&quot;&quot; 
        Decorator that adds *meth* to the list of validators. 
 
        Returns *meth* unchanged. 
 
        .. versionadded:: 17.1.0 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._validator </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._validator = meth</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._validator = and_(self._validator</span><span class="s2">, </span><span class="s1">meth)</span>
        <span class="s2">return </span><span class="s1">meth</span>

    <span class="s2">def </span><span class="s1">default(self</span><span class="s2">, </span><span class="s1">meth):</span>
        <span class="s4">&quot;&quot;&quot; 
        Decorator that allows to set the default for an attribute. 
 
        Returns *meth* unchanged. 
 
        :raises DefaultAlreadySetError: If default has been set before. 
 
        .. versionadded:: 17.1.0 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._default </span><span class="s2">is not </span><span class="s1">NOTHING:</span>
            <span class="s2">raise </span><span class="s1">DefaultAlreadySetError()</span>

        <span class="s1">self._default = Factory(meth</span><span class="s2">, </span><span class="s1">takes_self=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">meth</span>


<span class="s1">_CountingAttr = _add_eq(_add_repr(_CountingAttr))</span>


<span class="s2">class </span><span class="s1">Factory:</span>
    <span class="s4">&quot;&quot;&quot; 
    Stores a factory callable. 
 
    If passed as the default value to `attrs.field`, the factory is used to 
    generate a new value. 
 
    :param callable factory: A callable that takes either none or exactly one 
        mandatory positional argument depending on *takes_self*. 
    :param bool takes_self: Pass the partially initialized instance that is 
        being initialized as a positional argument. 
 
    .. versionadded:: 17.1.0  *takes_self* 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s3">&quot;factory&quot;</span><span class="s2">, </span><span class="s3">&quot;takes_self&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">factory</span><span class="s2">, </span><span class="s1">takes_self=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        `Factory` is part of the default machinery so if we want a default 
        value here, we have to implement it ourselves. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.factory = factory</span>
        <span class="s1">self.takes_self = takes_self</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Play nice with pickle. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">tuple(getattr(self</span><span class="s2">, </span><span class="s1">name) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.__slots__)</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state):</span>
        <span class="s4">&quot;&quot;&quot; 
        Play nice with pickle. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">zip(self.__slots__</span><span class="s2">, </span><span class="s1">state):</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value)</span>


<span class="s1">_f = [</span>
    <span class="s1">Attribute(</span>
        <span class="s1">name=name</span><span class="s2">,</span>
        <span class="s1">default=NOTHING</span><span class="s2">,</span>
        <span class="s1">validator=</span><span class="s2">None,</span>
        <span class="s1">repr=</span><span class="s2">True,</span>
        <span class="s1">cmp=</span><span class="s2">None,</span>
        <span class="s1">eq=</span><span class="s2">True,</span>
        <span class="s1">order=</span><span class="s2">False,</span>
        <span class="s1">hash=</span><span class="s2">True,</span>
        <span class="s1">init=</span><span class="s2">True,</span>
        <span class="s1">inherited=</span><span class="s2">False,</span>
    <span class="s1">)</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">Factory.__slots__</span>
<span class="s1">]</span>

<span class="s1">Factory = _add_hash(_add_eq(_add_repr(Factory</span><span class="s2">, </span><span class="s1">attrs=_f)</span><span class="s2">, </span><span class="s1">attrs=_f)</span><span class="s2">, </span><span class="s1">attrs=_f)</span>


<span class="s2">def </span><span class="s1">make_class(name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">bases=(object</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">**attributes_arguments):</span>
    <span class="s4">&quot;&quot;&quot; 
    A quick way to create a new class called *name* with *attrs*. 
 
    :param str name: The name for the new class. 
 
    :param attrs: A list of names or a dictionary of mappings of names to 
        attributes. 
 
        The order is deduced from the order of the names or attributes inside 
        *attrs*.  Otherwise the order of the definition of the attributes is 
        used. 
    :type attrs: `list` or `dict` 
 
    :param tuple bases: Classes that the new class will subclass. 
 
    :param attributes_arguments: Passed unmodified to `attr.s`. 
 
    :return: A new class with *attrs*. 
    :rtype: type 
 
    .. versionadded:: 17.1.0 *bases* 
    .. versionchanged:: 18.1.0 If *attrs* is ordered, the order is retained. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(attrs</span><span class="s2">, </span><span class="s1">dict):</span>
        <span class="s1">cls_dict = attrs</span>
    <span class="s2">elif </span><span class="s1">isinstance(attrs</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s1">cls_dict = {a: attrib() </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs}</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;attrs argument must be a dict or a list.&quot;</span><span class="s1">)</span>

    <span class="s1">pre_init = cls_dict.pop(</span><span class="s3">&quot;__attrs_pre_init__&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">post_init = cls_dict.pop(</span><span class="s3">&quot;__attrs_post_init__&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">user_init = cls_dict.pop(</span><span class="s3">&quot;__init__&quot;</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s1">body = {}</span>
    <span class="s2">if </span><span class="s1">pre_init </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">body[</span><span class="s3">&quot;__attrs_pre_init__&quot;</span><span class="s1">] = pre_init</span>
    <span class="s2">if </span><span class="s1">post_init </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">body[</span><span class="s3">&quot;__attrs_post_init__&quot;</span><span class="s1">] = post_init</span>
    <span class="s2">if </span><span class="s1">user_init </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">body[</span><span class="s3">&quot;__init__&quot;</span><span class="s1">] = user_init</span>

    <span class="s1">type_ = types.new_class(name</span><span class="s2">, </span><span class="s1">bases</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">, lambda </span><span class="s1">ns: ns.update(body))</span>

    <span class="s0"># For pickling to work, the __module__ variable needs to be set to the</span>
    <span class="s0"># frame where the class is created.  Bypass this step in environments where</span>
    <span class="s0"># sys._getframe is not defined (Jython for example) or sys._getframe is not</span>
    <span class="s0"># defined for arguments greater than 0 (IronPython).</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">type_.__module__ = sys._getframe(</span><span class="s5">1</span><span class="s1">).f_globals.get(</span>
            <span class="s3">&quot;__name__&quot;</span><span class="s2">, </span><span class="s3">&quot;__main__&quot;</span>
        <span class="s1">)</span>
    <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
        <span class="s2">pass</span>

    <span class="s0"># We do it here for proper warnings with meaningful stacklevel.</span>
    <span class="s1">cmp = attributes_arguments.pop(</span><span class="s3">&quot;cmp&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">(</span>
        <span class="s1">attributes_arguments[</span><span class="s3">&quot;eq&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">attributes_arguments[</span><span class="s3">&quot;order&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">) = _determine_attrs_eq_order(</span>
        <span class="s1">cmp</span><span class="s2">,</span>
        <span class="s1">attributes_arguments.get(</span><span class="s3">&quot;eq&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">attributes_arguments.get(</span><span class="s3">&quot;order&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s2">True,</span>
    <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">_attrs(these=cls_dict</span><span class="s2">, </span><span class="s1">**attributes_arguments)(type_)</span>


<span class="s0"># These are required by within this module so we define them here and merely</span>
<span class="s0"># import into .validators / .converters.</span>


<span class="s1">@attrs(slots=</span><span class="s2">True, </span><span class="s1">hash=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">_AndValidator:</span>
    <span class="s4">&quot;&quot;&quot; 
    Compose many validators to a single one. 
    &quot;&quot;&quot;</span>

    <span class="s1">_validators = attrib()</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">inst</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self._validators:</span>
            <span class="s1">v(inst</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">value)</span>


<span class="s2">def </span><span class="s1">and_(*validators):</span>
    <span class="s4">&quot;&quot;&quot; 
    A validator that composes multiple validators into one. 
 
    When called on a value, it runs all wrapped validators. 
 
    :param callables validators: Arbitrary number of validators. 
 
    .. versionadded:: 17.1.0 
    &quot;&quot;&quot;</span>
    <span class="s1">vals = []</span>
    <span class="s2">for </span><span class="s1">validator </span><span class="s2">in </span><span class="s1">validators:</span>
        <span class="s1">vals.extend(</span>
            <span class="s1">validator._validators</span>
            <span class="s2">if </span><span class="s1">isinstance(validator</span><span class="s2">, </span><span class="s1">_AndValidator)</span>
            <span class="s2">else </span><span class="s1">[validator]</span>
        <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">_AndValidator(tuple(vals))</span>


<span class="s2">def </span><span class="s1">pipe(*converters):</span>
    <span class="s4">&quot;&quot;&quot; 
    A converter that composes multiple converters into one. 
 
    When called on a value, it runs all wrapped converters, returning the 
    *last* value. 
 
    Type annotations will be inferred from the wrapped converters', if 
    they have any. 
 
    :param callables converters: Arbitrary number of converters. 
 
    .. versionadded:: 20.1.0 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">pipe_converter(val):</span>
        <span class="s2">for </span><span class="s1">converter </span><span class="s2">in </span><span class="s1">converters:</span>
            <span class="s1">val = converter(val)</span>

        <span class="s2">return </span><span class="s1">val</span>

    <span class="s2">if not </span><span class="s1">converters:</span>
        <span class="s0"># If the converter list is empty, pipe_converter is the identity.</span>
        <span class="s1">A = typing.TypeVar(</span><span class="s3">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">pipe_converter.__annotations__ = {</span><span class="s3">&quot;val&quot;</span><span class="s1">: A</span><span class="s2">, </span><span class="s3">&quot;return&quot;</span><span class="s1">: A}</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># Get parameter type from first converter.</span>
        <span class="s1">t = _AnnotationExtractor(converters[</span><span class="s5">0</span><span class="s1">]).get_first_param_type()</span>
        <span class="s2">if </span><span class="s1">t:</span>
            <span class="s1">pipe_converter.__annotations__[</span><span class="s3">&quot;val&quot;</span><span class="s1">] = t</span>

        <span class="s0"># Get return type from last converter.</span>
        <span class="s1">rt = _AnnotationExtractor(converters[-</span><span class="s5">1</span><span class="s1">]).get_return_type()</span>
        <span class="s2">if </span><span class="s1">rt:</span>
            <span class="s1">pipe_converter.__annotations__[</span><span class="s3">&quot;return&quot;</span><span class="s1">] = rt</span>

    <span class="s2">return </span><span class="s1">pipe_converter</span>
</pre>
</body>
</html>