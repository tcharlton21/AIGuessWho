<html>
<head>
<title>tarfile.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #a5c261;}
.s6 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tarfile.py</font>
</center></td></tr></table>
<pre><span class="s0">#-------------------------------------------------------------------</span>
<span class="s0"># tarfile.py</span>
<span class="s0">#-------------------------------------------------------------------</span>
<span class="s0"># Copyright (C) 2002 Lars Gustaebel &lt;lars@gustaebel.de&gt;</span>
<span class="s0"># All rights reserved.</span>
<span class="s0">#</span>
<span class="s0"># Permission  is  hereby granted,  free  of charge,  to  any person</span>
<span class="s0"># obtaining a  copy of  this software  and associated documentation</span>
<span class="s0"># files  (the  &quot;Software&quot;),  to   deal  in  the  Software   without</span>
<span class="s0"># restriction,  including  without limitation  the  rights to  use,</span>
<span class="s0"># copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="s0"># copies  of  the  Software,  and to  permit  persons  to  whom the</span>
<span class="s0"># Software  is  furnished  to  do  so,  subject  to  the  following</span>
<span class="s0"># conditions:</span>
<span class="s0">#</span>
<span class="s0"># The above copyright  notice and this  permission notice shall  be</span>
<span class="s0"># included in all copies or substantial portions of the Software.</span>
<span class="s0">#</span>
<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS  IS&quot;, WITHOUT WARRANTY OF ANY  KIND,</span>
<span class="s0"># EXPRESS OR IMPLIED, INCLUDING  BUT NOT LIMITED TO  THE WARRANTIES</span>
<span class="s0"># OF  MERCHANTABILITY,  FITNESS   FOR  A  PARTICULAR   PURPOSE  AND</span>
<span class="s0"># NONINFRINGEMENT.  IN  NO  EVENT SHALL  THE  AUTHORS  OR COPYRIGHT</span>
<span class="s0"># HOLDERS  BE LIABLE  FOR ANY  CLAIM, DAMAGES  OR OTHER  LIABILITY,</span>
<span class="s0"># WHETHER  IN AN  ACTION OF  CONTRACT, TORT  OR OTHERWISE,  ARISING</span>
<span class="s0"># FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
<span class="s0"># OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="s0">#</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">print_function</span>

<span class="s3">&quot;&quot;&quot;Read from and write to tar format archives. 
&quot;&quot;&quot;</span>

<span class="s1">__version__ = </span><span class="s3">&quot;$Revision$&quot;</span>

<span class="s1">version     = </span><span class="s3">&quot;0.9.0&quot;</span>
<span class="s1">__author__  = </span><span class="s3">&quot;Lars Gust</span><span class="s2">\u00e4</span><span class="s3">bel (lars@gustaebel.de)&quot;</span>
<span class="s1">__date__    = </span><span class="s3">&quot;$Date: 2011-02-25 17:42:01 +0200 (Fri, 25 Feb 2011) $&quot;</span>
<span class="s1">__cvsid__   = </span><span class="s3">&quot;$Id: tarfile.py 88586 2011-02-25 15:42:01Z marc-andre.lemburg $&quot;</span>
<span class="s1">__credits__ = </span><span class="s3">&quot;Gustavo Niemeyer, Niels Gust</span><span class="s2">\u00e4</span><span class="s3">bel, Richard Townsend.&quot;</span>

<span class="s0">#---------</span>
<span class="s0"># Imports</span>
<span class="s0">#---------</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">stat</span>
<span class="s2">import </span><span class="s1">errno</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">re</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">grp</span><span class="s2">, </span><span class="s1">pwd</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">grp = pwd = </span><span class="s2">None</span>

<span class="s0"># os.symlink on Windows prior to 6.0 raises NotImplementedError</span>
<span class="s1">symlink_exception = (AttributeError</span><span class="s2">, </span><span class="s1">NotImplementedError)</span>
<span class="s2">try</span><span class="s1">:</span>
    <span class="s0"># WindowsError (1314) will be raised if the caller does not hold the</span>
    <span class="s0"># SeCreateSymbolicLinkPrivilege privilege</span>
    <span class="s1">symlink_exception += (WindowsError</span><span class="s2">,</span><span class="s1">)</span>
<span class="s2">except </span><span class="s1">NameError:</span>
    <span class="s2">pass</span>

<span class="s0"># from tarfile import *</span>
<span class="s1">__all__ = [</span><span class="s3">&quot;TarFile&quot;</span><span class="s2">, </span><span class="s3">&quot;TarInfo&quot;</span><span class="s2">, </span><span class="s3">&quot;is_tarfile&quot;</span><span class="s2">, </span><span class="s3">&quot;TarError&quot;</span><span class="s1">]</span>

<span class="s2">if </span><span class="s1">sys.version_info[</span><span class="s4">0</span><span class="s1">] &lt; </span><span class="s4">3</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">__builtin__ </span><span class="s2">as </span><span class="s1">builtins</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">builtins</span>

<span class="s1">_open = builtins.open   </span><span class="s0"># Since 'open' is TarFile.open</span>

<span class="s0">#---------------------------------------------------------</span>
<span class="s0"># tar constants</span>
<span class="s0">#---------------------------------------------------------</span>
<span class="s1">NUL = </span><span class="s5">b&quot;</span><span class="s2">\0</span><span class="s5">&quot;                     </span><span class="s0"># the null character</span>
<span class="s1">BLOCKSIZE = </span><span class="s4">512                 </span><span class="s0"># length of processing blocks</span>
<span class="s1">RECORDSIZE = BLOCKSIZE * </span><span class="s4">20     </span><span class="s0"># length of records</span>
<span class="s1">GNU_MAGIC = </span><span class="s5">b&quot;ustar  </span><span class="s2">\0</span><span class="s5">&quot;        </span><span class="s0"># magic gnu tar string</span>
<span class="s1">POSIX_MAGIC = </span><span class="s5">b&quot;ustar</span><span class="s2">\x00</span><span class="s5">00&quot;    </span><span class="s0"># magic posix tar string</span>

<span class="s1">LENGTH_NAME = </span><span class="s4">100               </span><span class="s0"># maximum length of a filename</span>
<span class="s1">LENGTH_LINK = </span><span class="s4">100               </span><span class="s0"># maximum length of a linkname</span>
<span class="s1">LENGTH_PREFIX = </span><span class="s4">155             </span><span class="s0"># maximum length of the prefix field</span>

<span class="s1">REGTYPE = </span><span class="s5">b&quot;0&quot;                  </span><span class="s0"># regular file</span>
<span class="s1">AREGTYPE = </span><span class="s5">b&quot;</span><span class="s2">\0</span><span class="s5">&quot;                </span><span class="s0"># regular file</span>
<span class="s1">LNKTYPE = </span><span class="s5">b&quot;1&quot;                  </span><span class="s0"># link (inside tarfile)</span>
<span class="s1">SYMTYPE = </span><span class="s5">b&quot;2&quot;                  </span><span class="s0"># symbolic link</span>
<span class="s1">CHRTYPE = </span><span class="s5">b&quot;3&quot;                  </span><span class="s0"># character special device</span>
<span class="s1">BLKTYPE = </span><span class="s5">b&quot;4&quot;                  </span><span class="s0"># block special device</span>
<span class="s1">DIRTYPE = </span><span class="s5">b&quot;5&quot;                  </span><span class="s0"># directory</span>
<span class="s1">FIFOTYPE = </span><span class="s5">b&quot;6&quot;                 </span><span class="s0"># fifo special device</span>
<span class="s1">CONTTYPE = </span><span class="s5">b&quot;7&quot;                 </span><span class="s0"># contiguous file</span>

<span class="s1">GNUTYPE_LONGNAME = </span><span class="s5">b&quot;L&quot;         </span><span class="s0"># GNU tar longname</span>
<span class="s1">GNUTYPE_LONGLINK = </span><span class="s5">b&quot;K&quot;         </span><span class="s0"># GNU tar longlink</span>
<span class="s1">GNUTYPE_SPARSE = </span><span class="s5">b&quot;S&quot;           </span><span class="s0"># GNU tar sparse file</span>

<span class="s1">XHDTYPE = </span><span class="s5">b&quot;x&quot;                  </span><span class="s0"># POSIX.1-2001 extended header</span>
<span class="s1">XGLTYPE = </span><span class="s5">b&quot;g&quot;                  </span><span class="s0"># POSIX.1-2001 global header</span>
<span class="s1">SOLARIS_XHDTYPE = </span><span class="s5">b&quot;X&quot;          </span><span class="s0"># Solaris extended header</span>

<span class="s1">USTAR_FORMAT = </span><span class="s4">0                </span><span class="s0"># POSIX.1-1988 (ustar) format</span>
<span class="s1">GNU_FORMAT = </span><span class="s4">1                  </span><span class="s0"># GNU tar format</span>
<span class="s1">PAX_FORMAT = </span><span class="s4">2                  </span><span class="s0"># POSIX.1-2001 (pax) format</span>
<span class="s1">DEFAULT_FORMAT = GNU_FORMAT</span>

<span class="s0">#---------------------------------------------------------</span>
<span class="s0"># tarfile constants</span>
<span class="s0">#---------------------------------------------------------</span>
<span class="s0"># File types that tarfile supports:</span>
<span class="s1">SUPPORTED_TYPES = (REGTYPE</span><span class="s2">, </span><span class="s1">AREGTYPE</span><span class="s2">, </span><span class="s1">LNKTYPE</span><span class="s2">,</span>
                   <span class="s1">SYMTYPE</span><span class="s2">, </span><span class="s1">DIRTYPE</span><span class="s2">, </span><span class="s1">FIFOTYPE</span><span class="s2">,</span>
                   <span class="s1">CONTTYPE</span><span class="s2">, </span><span class="s1">CHRTYPE</span><span class="s2">, </span><span class="s1">BLKTYPE</span><span class="s2">,</span>
                   <span class="s1">GNUTYPE_LONGNAME</span><span class="s2">, </span><span class="s1">GNUTYPE_LONGLINK</span><span class="s2">,</span>
                   <span class="s1">GNUTYPE_SPARSE)</span>

<span class="s0"># File types that will be treated as a regular file.</span>
<span class="s1">REGULAR_TYPES = (REGTYPE</span><span class="s2">, </span><span class="s1">AREGTYPE</span><span class="s2">,</span>
                 <span class="s1">CONTTYPE</span><span class="s2">, </span><span class="s1">GNUTYPE_SPARSE)</span>

<span class="s0"># File types that are part of the GNU tar format.</span>
<span class="s1">GNU_TYPES = (GNUTYPE_LONGNAME</span><span class="s2">, </span><span class="s1">GNUTYPE_LONGLINK</span><span class="s2">,</span>
             <span class="s1">GNUTYPE_SPARSE)</span>

<span class="s0"># Fields from a pax header that override a TarInfo attribute.</span>
<span class="s1">PAX_FIELDS = (</span><span class="s3">&quot;path&quot;</span><span class="s2">, </span><span class="s3">&quot;linkpath&quot;</span><span class="s2">, </span><span class="s3">&quot;size&quot;</span><span class="s2">, </span><span class="s3">&quot;mtime&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;uid&quot;</span><span class="s2">, </span><span class="s3">&quot;gid&quot;</span><span class="s2">, </span><span class="s3">&quot;uname&quot;</span><span class="s2">, </span><span class="s3">&quot;gname&quot;</span><span class="s1">)</span>

<span class="s0"># Fields from a pax header that are affected by hdrcharset.</span>
<span class="s1">PAX_NAME_FIELDS = set((</span><span class="s3">&quot;path&quot;</span><span class="s2">, </span><span class="s3">&quot;linkpath&quot;</span><span class="s2">, </span><span class="s3">&quot;uname&quot;</span><span class="s2">, </span><span class="s3">&quot;gname&quot;</span><span class="s1">))</span>

<span class="s0"># Fields in a pax header that are numbers, all other fields</span>
<span class="s0"># are treated as strings.</span>
<span class="s1">PAX_NUMBER_FIELDS = {</span>
    <span class="s3">&quot;atime&quot;</span><span class="s1">: float</span><span class="s2">,</span>
    <span class="s3">&quot;ctime&quot;</span><span class="s1">: float</span><span class="s2">,</span>
    <span class="s3">&quot;mtime&quot;</span><span class="s1">: float</span><span class="s2">,</span>
    <span class="s3">&quot;uid&quot;</span><span class="s1">: int</span><span class="s2">,</span>
    <span class="s3">&quot;gid&quot;</span><span class="s1">: int</span><span class="s2">,</span>
    <span class="s3">&quot;size&quot;</span><span class="s1">: int</span>
<span class="s1">}</span>

<span class="s0">#---------------------------------------------------------</span>
<span class="s0"># Bits used in the mode field, values in octal.</span>
<span class="s0">#---------------------------------------------------------</span>
<span class="s1">S_IFLNK = </span><span class="s4">0o120000        </span><span class="s0"># symbolic link</span>
<span class="s1">S_IFREG = </span><span class="s4">0o100000        </span><span class="s0"># regular file</span>
<span class="s1">S_IFBLK = </span><span class="s4">0o060000        </span><span class="s0"># block device</span>
<span class="s1">S_IFDIR = </span><span class="s4">0o040000        </span><span class="s0"># directory</span>
<span class="s1">S_IFCHR = </span><span class="s4">0o020000        </span><span class="s0"># character device</span>
<span class="s1">S_IFIFO = </span><span class="s4">0o010000        </span><span class="s0"># fifo</span>

<span class="s1">TSUID   = </span><span class="s4">0o4000          </span><span class="s0"># set UID on execution</span>
<span class="s1">TSGID   = </span><span class="s4">0o2000          </span><span class="s0"># set GID on execution</span>
<span class="s1">TSVTX   = </span><span class="s4">0o1000          </span><span class="s0"># reserved</span>

<span class="s1">TUREAD  = </span><span class="s4">0o400           </span><span class="s0"># read by owner</span>
<span class="s1">TUWRITE = </span><span class="s4">0o200           </span><span class="s0"># write by owner</span>
<span class="s1">TUEXEC  = </span><span class="s4">0o100           </span><span class="s0"># execute/search by owner</span>
<span class="s1">TGREAD  = </span><span class="s4">0o040           </span><span class="s0"># read by group</span>
<span class="s1">TGWRITE = </span><span class="s4">0o020           </span><span class="s0"># write by group</span>
<span class="s1">TGEXEC  = </span><span class="s4">0o010           </span><span class="s0"># execute/search by group</span>
<span class="s1">TOREAD  = </span><span class="s4">0o004           </span><span class="s0"># read by other</span>
<span class="s1">TOWRITE = </span><span class="s4">0o002           </span><span class="s0"># write by other</span>
<span class="s1">TOEXEC  = </span><span class="s4">0o001           </span><span class="s0"># execute/search by other</span>

<span class="s0">#---------------------------------------------------------</span>
<span class="s0"># initialization</span>
<span class="s0">#---------------------------------------------------------</span>
<span class="s2">if </span><span class="s1">os.name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;nt&quot;</span><span class="s2">, </span><span class="s3">&quot;ce&quot;</span><span class="s1">):</span>
    <span class="s1">ENCODING = </span><span class="s3">&quot;utf-8&quot;</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s1">ENCODING = sys.getfilesystemencoding()</span>

<span class="s0">#---------------------------------------------------------</span>
<span class="s0"># Some useful functions</span>
<span class="s0">#---------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">stn(s</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors):</span>
    <span class="s6">&quot;&quot;&quot;Convert a string to a null-terminated bytes object. 
    &quot;&quot;&quot;</span>
    <span class="s1">s = s.encode(encoding</span><span class="s2">, </span><span class="s1">errors)</span>
    <span class="s2">return </span><span class="s1">s[:length] + (length - len(s)) * NUL</span>

<span class="s2">def </span><span class="s1">nts(s</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors):</span>
    <span class="s6">&quot;&quot;&quot;Convert a null-terminated bytes object to a string. 
    &quot;&quot;&quot;</span>
    <span class="s1">p = s.find(</span><span class="s5">b&quot;</span><span class="s2">\0</span><span class="s5">&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">p != -</span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">s = s[:p]</span>
    <span class="s2">return </span><span class="s1">s.decode(encoding</span><span class="s2">, </span><span class="s1">errors)</span>

<span class="s2">def </span><span class="s1">nti(s):</span>
    <span class="s6">&quot;&quot;&quot;Convert a number field to a python number. 
    &quot;&quot;&quot;</span>
    <span class="s0"># There are two possible encodings for a number field, see</span>
    <span class="s0"># itn() below.</span>
    <span class="s2">if </span><span class="s1">s[</span><span class="s4">0</span><span class="s1">] != chr(</span><span class="s4">0o200</span><span class="s1">):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">n = int(nts(s</span><span class="s2">, </span><span class="s3">&quot;ascii&quot;</span><span class="s2">, </span><span class="s3">&quot;strict&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s3">&quot;0&quot;</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">raise </span><span class="s1">InvalidHeaderError(</span><span class="s3">&quot;invalid header&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">n = </span><span class="s4">0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(s) - </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">n &lt;&lt;= </span><span class="s4">8</span>
            <span class="s1">n += ord(s[i + </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s2">return </span><span class="s1">n</span>

<span class="s2">def </span><span class="s1">itn(n</span><span class="s2">, </span><span class="s1">digits=</span><span class="s4">8</span><span class="s2">, </span><span class="s1">format=DEFAULT_FORMAT):</span>
    <span class="s6">&quot;&quot;&quot;Convert a python number to a number field. 
    &quot;&quot;&quot;</span>
    <span class="s0"># POSIX 1003.1-1988 requires numbers to be encoded as a string of</span>
    <span class="s0"># octal digits followed by a null-byte, this allows values up to</span>
    <span class="s0"># (8**(digits-1))-1. GNU tar allows storing numbers greater than</span>
    <span class="s0"># that if necessary. A leading 0o200 byte indicates this particular</span>
    <span class="s0"># encoding, the following digits-1 bytes are a big-endian</span>
    <span class="s0"># representation. This allows values up to (256**(digits-1))-1.</span>
    <span class="s2">if </span><span class="s4">0 </span><span class="s1">&lt;= n &lt; </span><span class="s4">8 </span><span class="s1">** (digits - </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">s = (</span><span class="s3">&quot;%0*o&quot; </span><span class="s1">% (digits - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">n)).encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">) + NUL</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">format != GNU_FORMAT </span><span class="s2">or </span><span class="s1">n &gt;= </span><span class="s4">256 </span><span class="s1">** (digits - </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;overflow in number field&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">n &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># XXX We mimic GNU tar's behaviour with negative numbers,</span>
            <span class="s0"># this could raise OverflowError.</span>
            <span class="s1">n = struct.unpack(</span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s1">struct.pack(</span><span class="s3">&quot;l&quot;</span><span class="s2">, </span><span class="s1">n))[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">s = bytearray()</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(digits - </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">s.insert(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">n &amp; </span><span class="s4">0o377</span><span class="s1">)</span>
            <span class="s1">n &gt;&gt;= </span><span class="s4">8</span>
        <span class="s1">s.insert(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0o200</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">s</span>

<span class="s2">def </span><span class="s1">calc_chksums(buf):</span>
    <span class="s6">&quot;&quot;&quot;Calculate the checksum for a member's header by summing up all 
       characters except for the chksum field which is treated as if 
       it was filled with spaces. According to the GNU tar sources, 
       some tars (Sun and NeXT) calculate chksum with signed char, 
       which will be different if there are chars in the buffer with 
       the high bit set. So we calculate two checksums, unsigned and 
       signed. 
    &quot;&quot;&quot;</span>
    <span class="s1">unsigned_chksum = </span><span class="s4">256 </span><span class="s1">+ sum(struct.unpack(</span><span class="s3">&quot;148B&quot;</span><span class="s2">, </span><span class="s1">buf[:</span><span class="s4">148</span><span class="s1">]) + struct.unpack(</span><span class="s3">&quot;356B&quot;</span><span class="s2">, </span><span class="s1">buf[</span><span class="s4">156</span><span class="s1">:</span><span class="s4">512</span><span class="s1">]))</span>
    <span class="s1">signed_chksum = </span><span class="s4">256 </span><span class="s1">+ sum(struct.unpack(</span><span class="s3">&quot;148b&quot;</span><span class="s2">, </span><span class="s1">buf[:</span><span class="s4">148</span><span class="s1">]) + struct.unpack(</span><span class="s3">&quot;356b&quot;</span><span class="s2">, </span><span class="s1">buf[</span><span class="s4">156</span><span class="s1">:</span><span class="s4">512</span><span class="s1">]))</span>
    <span class="s2">return </span><span class="s1">unsigned_chksum</span><span class="s2">, </span><span class="s1">signed_chksum</span>

<span class="s2">def </span><span class="s1">copyfileobj(src</span><span class="s2">, </span><span class="s1">dst</span><span class="s2">, </span><span class="s1">length=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s6">&quot;&quot;&quot;Copy length bytes from fileobj src to fileobj dst. 
       If length is None, copy the entire content. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">length == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">length </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">buf = src.read(</span><span class="s4">16</span><span class="s1">*</span><span class="s4">1024</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">buf:</span>
                <span class="s2">break</span>
            <span class="s1">dst.write(buf)</span>
        <span class="s2">return</span>

    <span class="s1">BUFSIZE = </span><span class="s4">16 </span><span class="s1">* </span><span class="s4">1024</span>
    <span class="s1">blocks</span><span class="s2">, </span><span class="s1">remainder = divmod(length</span><span class="s2">, </span><span class="s1">BUFSIZE)</span>
    <span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">range(blocks):</span>
        <span class="s1">buf = src.read(BUFSIZE)</span>
        <span class="s2">if </span><span class="s1">len(buf) &lt; BUFSIZE:</span>
            <span class="s2">raise </span><span class="s1">IOError(</span><span class="s3">&quot;end of file reached&quot;</span><span class="s1">)</span>
        <span class="s1">dst.write(buf)</span>

    <span class="s2">if </span><span class="s1">remainder != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">buf = src.read(remainder)</span>
        <span class="s2">if </span><span class="s1">len(buf) &lt; remainder:</span>
            <span class="s2">raise </span><span class="s1">IOError(</span><span class="s3">&quot;end of file reached&quot;</span><span class="s1">)</span>
        <span class="s1">dst.write(buf)</span>
    <span class="s2">return</span>

<span class="s1">filemode_table = (</span>
    <span class="s1">((S_IFLNK</span><span class="s2">,      </span><span class="s3">&quot;l&quot;</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(S_IFREG</span><span class="s2">,      </span><span class="s3">&quot;-&quot;</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(S_IFBLK</span><span class="s2">,      </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(S_IFDIR</span><span class="s2">,      </span><span class="s3">&quot;d&quot;</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(S_IFCHR</span><span class="s2">,      </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(S_IFIFO</span><span class="s2">,      </span><span class="s3">&quot;p&quot;</span><span class="s1">))</span><span class="s2">,</span>

    <span class="s1">((TUREAD</span><span class="s2">,       </span><span class="s3">&quot;r&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((TUWRITE</span><span class="s2">,      </span><span class="s3">&quot;w&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((TUEXEC|TSUID</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(TSUID</span><span class="s2">,        </span><span class="s3">&quot;S&quot;</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(TUEXEC</span><span class="s2">,       </span><span class="s3">&quot;x&quot;</span><span class="s1">))</span><span class="s2">,</span>

    <span class="s1">((TGREAD</span><span class="s2">,       </span><span class="s3">&quot;r&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((TGWRITE</span><span class="s2">,      </span><span class="s3">&quot;w&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((TGEXEC|TSGID</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(TSGID</span><span class="s2">,        </span><span class="s3">&quot;S&quot;</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(TGEXEC</span><span class="s2">,       </span><span class="s3">&quot;x&quot;</span><span class="s1">))</span><span class="s2">,</span>

    <span class="s1">((TOREAD</span><span class="s2">,       </span><span class="s3">&quot;r&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((TOWRITE</span><span class="s2">,      </span><span class="s3">&quot;w&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">((TOEXEC|TSVTX</span><span class="s2">, </span><span class="s3">&quot;t&quot;</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(TSVTX</span><span class="s2">,        </span><span class="s3">&quot;T&quot;</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(TOEXEC</span><span class="s2">,       </span><span class="s3">&quot;x&quot;</span><span class="s1">))</span>
<span class="s1">)</span>

<span class="s2">def </span><span class="s1">filemode(mode):</span>
    <span class="s6">&quot;&quot;&quot;Convert a file's mode to a string of the form 
       -rwxrwxrwx. 
       Used by TarFile.list() 
    &quot;&quot;&quot;</span>
    <span class="s1">perm = []</span>
    <span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">filemode_table:</span>
        <span class="s2">for </span><span class="s1">bit</span><span class="s2">, </span><span class="s1">char </span><span class="s2">in </span><span class="s1">table:</span>
            <span class="s2">if </span><span class="s1">mode &amp; bit == bit:</span>
                <span class="s1">perm.append(char)</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">perm.append(</span><span class="s3">&quot;-&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s3">&quot;&quot;</span><span class="s1">.join(perm)</span>

<span class="s2">class </span><span class="s1">TarError(Exception):</span>
    <span class="s6">&quot;&quot;&quot;Base exception.&quot;&quot;&quot;</span>
    <span class="s2">pass</span>
<span class="s2">class </span><span class="s1">ExtractError(TarError):</span>
    <span class="s6">&quot;&quot;&quot;General exception for extract errors.&quot;&quot;&quot;</span>
    <span class="s2">pass</span>
<span class="s2">class </span><span class="s1">ReadError(TarError):</span>
    <span class="s6">&quot;&quot;&quot;Exception for unreadable tar archives.&quot;&quot;&quot;</span>
    <span class="s2">pass</span>
<span class="s2">class </span><span class="s1">CompressionError(TarError):</span>
    <span class="s6">&quot;&quot;&quot;Exception for unavailable compression methods.&quot;&quot;&quot;</span>
    <span class="s2">pass</span>
<span class="s2">class </span><span class="s1">StreamError(TarError):</span>
    <span class="s6">&quot;&quot;&quot;Exception for unsupported operations on stream-like TarFiles.&quot;&quot;&quot;</span>
    <span class="s2">pass</span>
<span class="s2">class </span><span class="s1">HeaderError(TarError):</span>
    <span class="s6">&quot;&quot;&quot;Base exception for header errors.&quot;&quot;&quot;</span>
    <span class="s2">pass</span>
<span class="s2">class </span><span class="s1">EmptyHeaderError(HeaderError):</span>
    <span class="s6">&quot;&quot;&quot;Exception for empty headers.&quot;&quot;&quot;</span>
    <span class="s2">pass</span>
<span class="s2">class </span><span class="s1">TruncatedHeaderError(HeaderError):</span>
    <span class="s6">&quot;&quot;&quot;Exception for truncated headers.&quot;&quot;&quot;</span>
    <span class="s2">pass</span>
<span class="s2">class </span><span class="s1">EOFHeaderError(HeaderError):</span>
    <span class="s6">&quot;&quot;&quot;Exception for end of file headers.&quot;&quot;&quot;</span>
    <span class="s2">pass</span>
<span class="s2">class </span><span class="s1">InvalidHeaderError(HeaderError):</span>
    <span class="s6">&quot;&quot;&quot;Exception for invalid headers.&quot;&quot;&quot;</span>
    <span class="s2">pass</span>
<span class="s2">class </span><span class="s1">SubsequentHeaderError(HeaderError):</span>
    <span class="s6">&quot;&quot;&quot;Exception for missing and invalid extended headers.&quot;&quot;&quot;</span>
    <span class="s2">pass</span>

<span class="s0">#---------------------------</span>
<span class="s0"># internal stream interface</span>
<span class="s0">#---------------------------</span>
<span class="s2">class </span><span class="s1">_LowLevelFile(object):</span>
    <span class="s6">&quot;&quot;&quot;Low-level file object. Supports reading and writing. 
       It is used instead of a regular file object for streaming 
       access. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">mode):</span>
        <span class="s1">mode = {</span>
            <span class="s3">&quot;r&quot;</span><span class="s1">: os.O_RDONLY</span><span class="s2">,</span>
            <span class="s3">&quot;w&quot;</span><span class="s1">: os.O_WRONLY | os.O_CREAT | os.O_TRUNC</span><span class="s2">,</span>
        <span class="s1">}[mode]</span>
        <span class="s2">if </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">&quot;O_BINARY&quot;</span><span class="s1">):</span>
            <span class="s1">mode |= os.O_BINARY</span>
        <span class="s1">self.fd = os.open(name</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s4">0o666</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s1">os.close(self.fd)</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">size):</span>
        <span class="s2">return </span><span class="s1">os.read(self.fd</span><span class="s2">, </span><span class="s1">size)</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s1">os.write(self.fd</span><span class="s2">, </span><span class="s1">s)</span>

<span class="s2">class </span><span class="s1">_Stream(object):</span>
    <span class="s6">&quot;&quot;&quot;Class that serves as an adapter between TarFile and 
       a stream-like object.  The stream-like object only 
       needs to have a read() or write() method and is accessed 
       blockwise.  Use of gzip or bzip2 compression is possible. 
       A stream-like object could be for example: sys.stdin, 
       sys.stdout, a socket, a tape device etc. 
 
       _Stream is intended to be used only internally. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">comptype</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">bufsize):</span>
        <span class="s6">&quot;&quot;&quot;Construct a _Stream object. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._extfileobj = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">fileobj </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fileobj = _LowLevelFile(name</span><span class="s2">, </span><span class="s1">mode)</span>
            <span class="s1">self._extfileobj = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">comptype == </span><span class="s3">'*'</span><span class="s1">:</span>
            <span class="s0"># Enable transparent compression detection for the</span>
            <span class="s0"># stream interface</span>
            <span class="s1">fileobj = _StreamProxy(fileobj)</span>
            <span class="s1">comptype = fileobj.getcomptype()</span>

        <span class="s1">self.name     = name </span><span class="s2">or </span><span class="s3">&quot;&quot;</span>
        <span class="s1">self.mode     = mode</span>
        <span class="s1">self.comptype = comptype</span>
        <span class="s1">self.fileobj  = fileobj</span>
        <span class="s1">self.bufsize  = bufsize</span>
        <span class="s1">self.buf      = </span><span class="s5">b&quot;&quot;</span>
        <span class="s1">self.pos      = </span><span class="s4">0</span>
        <span class="s1">self.closed   = </span><span class="s2">False</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">comptype == </span><span class="s3">&quot;gz&quot;</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">import </span><span class="s1">zlib</span>
                <span class="s2">except </span><span class="s1">ImportError:</span>
                    <span class="s2">raise </span><span class="s1">CompressionError(</span><span class="s3">&quot;zlib module is not available&quot;</span><span class="s1">)</span>
                <span class="s1">self.zlib = zlib</span>
                <span class="s1">self.crc = zlib.crc32(</span><span class="s5">b&quot;&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;r&quot;</span><span class="s1">:</span>
                    <span class="s1">self._init_read_gz()</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self._init_write_gz()</span>

            <span class="s2">if </span><span class="s1">comptype == </span><span class="s3">&quot;bz2&quot;</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">import </span><span class="s1">bz2</span>
                <span class="s2">except </span><span class="s1">ImportError:</span>
                    <span class="s2">raise </span><span class="s1">CompressionError(</span><span class="s3">&quot;bz2 module is not available&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;r&quot;</span><span class="s1">:</span>
                    <span class="s1">self.dbuf = </span><span class="s5">b&quot;&quot;</span>
                    <span class="s1">self.cmp = bz2.BZ2Decompressor()</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.cmp = bz2.BZ2Compressor()</span>
        <span class="s2">except</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">self._extfileobj:</span>
                <span class="s1">self.fileobj.close()</span>
            <span class="s1">self.closed = </span><span class="s2">True</span>
            <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">__del__(self):</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;closed&quot;</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">self.closed:</span>
            <span class="s1">self.close()</span>

    <span class="s2">def </span><span class="s1">_init_write_gz(self):</span>
        <span class="s6">&quot;&quot;&quot;Initialize for writing with gzip compression. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.cmp = self.zlib.compressobj(</span><span class="s4">9</span><span class="s2">, </span><span class="s1">self.zlib.DEFLATED</span><span class="s2">,</span>
                                            <span class="s1">-self.zlib.MAX_WBITS</span><span class="s2">,</span>
                                            <span class="s1">self.zlib.DEF_MEM_LEVEL</span><span class="s2">,</span>
                                            <span class="s4">0</span><span class="s1">)</span>
        <span class="s1">timestamp = struct.pack(</span><span class="s3">&quot;&lt;L&quot;</span><span class="s2">, </span><span class="s1">int(time.time()))</span>
        <span class="s1">self.__write(</span><span class="s5">b&quot;</span><span class="s2">\037\213\010\010</span><span class="s5">&quot; </span><span class="s1">+ timestamp + </span><span class="s5">b&quot;</span><span class="s2">\002\377</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.name.endswith(</span><span class="s3">&quot;.gz&quot;</span><span class="s1">):</span>
            <span class="s1">self.name = self.name[:-</span><span class="s4">3</span><span class="s1">]</span>
        <span class="s0"># RFC1952 says we must use ISO-8859-1 for the FNAME field.</span>
        <span class="s1">self.__write(self.name.encode(</span><span class="s3">&quot;iso-8859-1&quot;</span><span class="s2">, </span><span class="s3">&quot;replace&quot;</span><span class="s1">) + NUL)</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s6">&quot;&quot;&quot;Write string s to the stream. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.comptype == </span><span class="s3">&quot;gz&quot;</span><span class="s1">:</span>
            <span class="s1">self.crc = self.zlib.crc32(s</span><span class="s2">, </span><span class="s1">self.crc)</span>
        <span class="s1">self.pos += len(s)</span>
        <span class="s2">if </span><span class="s1">self.comptype != </span><span class="s3">&quot;tar&quot;</span><span class="s1">:</span>
            <span class="s1">s = self.cmp.compress(s)</span>
        <span class="s1">self.__write(s)</span>

    <span class="s2">def </span><span class="s1">__write(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s6">&quot;&quot;&quot;Write string s to the stream if a whole new block 
           is ready to be written. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.buf += s</span>
        <span class="s2">while </span><span class="s1">len(self.buf) &gt; self.bufsize:</span>
            <span class="s1">self.fileobj.write(self.buf[:self.bufsize])</span>
            <span class="s1">self.buf = self.buf[self.bufsize:]</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s6">&quot;&quot;&quot;Close the _Stream object. No operation should be 
           done on it afterwards. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.closed:</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;w&quot; </span><span class="s2">and </span><span class="s1">self.comptype != </span><span class="s3">&quot;tar&quot;</span><span class="s1">:</span>
            <span class="s1">self.buf += self.cmp.flush()</span>

        <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;w&quot; </span><span class="s2">and </span><span class="s1">self.buf:</span>
            <span class="s1">self.fileobj.write(self.buf)</span>
            <span class="s1">self.buf = </span><span class="s5">b&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">self.comptype == </span><span class="s3">&quot;gz&quot;</span><span class="s1">:</span>
                <span class="s0"># The native zlib crc is an unsigned 32-bit integer, but</span>
                <span class="s0"># the Python wrapper implicitly casts that to a signed C</span>
                <span class="s0"># long.  So, on a 32-bit box self.crc may &quot;look negative&quot;,</span>
                <span class="s0"># while the same crc on a 64-bit box may &quot;look positive&quot;.</span>
                <span class="s0"># To avoid irksome warnings from the `struct` module, force</span>
                <span class="s0"># it to look positive on all boxes.</span>
                <span class="s1">self.fileobj.write(struct.pack(</span><span class="s3">&quot;&lt;L&quot;</span><span class="s2">, </span><span class="s1">self.crc &amp; </span><span class="s4">0xffffffff</span><span class="s1">))</span>
                <span class="s1">self.fileobj.write(struct.pack(</span><span class="s3">&quot;&lt;L&quot;</span><span class="s2">, </span><span class="s1">self.pos &amp; </span><span class="s4">0xffffFFFF</span><span class="s1">))</span>

        <span class="s2">if not </span><span class="s1">self._extfileobj:</span>
            <span class="s1">self.fileobj.close()</span>

        <span class="s1">self.closed = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_init_read_gz(self):</span>
        <span class="s6">&quot;&quot;&quot;Initialize for reading a gzip compressed fileobj. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.cmp = self.zlib.decompressobj(-self.zlib.MAX_WBITS)</span>
        <span class="s1">self.dbuf = </span><span class="s5">b&quot;&quot;</span>

        <span class="s0"># taken from gzip.GzipFile with some alterations</span>
        <span class="s2">if </span><span class="s1">self.__read(</span><span class="s4">2</span><span class="s1">) != </span><span class="s5">b&quot;</span><span class="s2">\037\213</span><span class="s5">&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ReadError(</span><span class="s3">&quot;not a gzip file&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.__read(</span><span class="s4">1</span><span class="s1">) != </span><span class="s5">b&quot;</span><span class="s2">\010</span><span class="s5">&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">CompressionError(</span><span class="s3">&quot;unsupported compression method&quot;</span><span class="s1">)</span>

        <span class="s1">flag = ord(self.__read(</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">self.__read(</span><span class="s4">6</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">flag &amp; </span><span class="s4">4</span><span class="s1">:</span>
            <span class="s1">xlen = ord(self.__read(</span><span class="s4">1</span><span class="s1">)) + </span><span class="s4">256 </span><span class="s1">* ord(self.__read(</span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">self.read(xlen)</span>
        <span class="s2">if </span><span class="s1">flag &amp; </span><span class="s4">8</span><span class="s1">:</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s1">s = self.__read(</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s2">if not </span><span class="s1">s </span><span class="s2">or </span><span class="s1">s == NUL:</span>
                    <span class="s2">break</span>
        <span class="s2">if </span><span class="s1">flag &amp; </span><span class="s4">16</span><span class="s1">:</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s1">s = self.__read(</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s2">if not </span><span class="s1">s </span><span class="s2">or </span><span class="s1">s == NUL:</span>
                    <span class="s2">break</span>
        <span class="s2">if </span><span class="s1">flag &amp; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">self.__read(</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">tell(self):</span>
        <span class="s6">&quot;&quot;&quot;Return the stream's file pointer position. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.pos</span>

    <span class="s2">def </span><span class="s1">seek(self</span><span class="s2">, </span><span class="s1">pos=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Set the stream's file pointer to pos. Negative seeking 
           is forbidden. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">pos - self.pos &gt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">blocks</span><span class="s2">, </span><span class="s1">remainder = divmod(pos - self.pos</span><span class="s2">, </span><span class="s1">self.bufsize)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(blocks):</span>
                <span class="s1">self.read(self.bufsize)</span>
            <span class="s1">self.read(remainder)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">StreamError(</span><span class="s3">&quot;seeking backwards is not allowed&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.pos</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">size=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Return the next size number of bytes from the stream. 
           If size is not defined, return all bytes of the stream 
           up to EOF. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">t = []</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s1">buf = self._read(self.bufsize)</span>
                <span class="s2">if not </span><span class="s1">buf:</span>
                    <span class="s2">break</span>
                <span class="s1">t.append(buf)</span>
            <span class="s1">buf = </span><span class="s3">&quot;&quot;</span><span class="s1">.join(t)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">buf = self._read(size)</span>
        <span class="s1">self.pos += len(buf)</span>
        <span class="s2">return </span><span class="s1">buf</span>

    <span class="s2">def </span><span class="s1">_read(self</span><span class="s2">, </span><span class="s1">size):</span>
        <span class="s6">&quot;&quot;&quot;Return size bytes from the stream. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.comptype == </span><span class="s3">&quot;tar&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__read(size)</span>

        <span class="s1">c = len(self.dbuf)</span>
        <span class="s2">while </span><span class="s1">c &lt; size:</span>
            <span class="s1">buf = self.__read(self.bufsize)</span>
            <span class="s2">if not </span><span class="s1">buf:</span>
                <span class="s2">break</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">buf = self.cmp.decompress(buf)</span>
            <span class="s2">except </span><span class="s1">IOError:</span>
                <span class="s2">raise </span><span class="s1">ReadError(</span><span class="s3">&quot;invalid compressed data&quot;</span><span class="s1">)</span>
            <span class="s1">self.dbuf += buf</span>
            <span class="s1">c += len(buf)</span>
        <span class="s1">buf = self.dbuf[:size]</span>
        <span class="s1">self.dbuf = self.dbuf[size:]</span>
        <span class="s2">return </span><span class="s1">buf</span>

    <span class="s2">def </span><span class="s1">__read(self</span><span class="s2">, </span><span class="s1">size):</span>
        <span class="s6">&quot;&quot;&quot;Return size bytes from stream. If internal buffer is empty, 
           read another block from the stream. 
        &quot;&quot;&quot;</span>
        <span class="s1">c = len(self.buf)</span>
        <span class="s2">while </span><span class="s1">c &lt; size:</span>
            <span class="s1">buf = self.fileobj.read(self.bufsize)</span>
            <span class="s2">if not </span><span class="s1">buf:</span>
                <span class="s2">break</span>
            <span class="s1">self.buf += buf</span>
            <span class="s1">c += len(buf)</span>
        <span class="s1">buf = self.buf[:size]</span>
        <span class="s1">self.buf = self.buf[size:]</span>
        <span class="s2">return </span><span class="s1">buf</span>
<span class="s0"># class _Stream</span>

<span class="s2">class </span><span class="s1">_StreamProxy(object):</span>
    <span class="s6">&quot;&quot;&quot;Small proxy class that enables transparent compression 
       detection for the Stream interface (mode 'r|*'). 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fileobj):</span>
        <span class="s1">self.fileobj = fileobj</span>
        <span class="s1">self.buf = self.fileobj.read(BLOCKSIZE)</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">size):</span>
        <span class="s1">self.read = self.fileobj.read</span>
        <span class="s2">return </span><span class="s1">self.buf</span>

    <span class="s2">def </span><span class="s1">getcomptype(self):</span>
        <span class="s2">if </span><span class="s1">self.buf.startswith(</span><span class="s5">b&quot;</span><span class="s2">\037\213\010</span><span class="s5">&quot;</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s3">&quot;gz&quot;</span>
        <span class="s2">if </span><span class="s1">self.buf.startswith(</span><span class="s5">b&quot;BZh91&quot;</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s3">&quot;bz2&quot;</span>
        <span class="s2">return </span><span class="s3">&quot;tar&quot;</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s1">self.fileobj.close()</span>
<span class="s0"># class StreamProxy</span>

<span class="s2">class </span><span class="s1">_BZ2Proxy(object):</span>
    <span class="s6">&quot;&quot;&quot;Small proxy class that enables external file object 
       support for &quot;r:bz2&quot; and &quot;w:bz2&quot; modes. This is actually 
       a workaround for a limitation in bz2 module's BZ2File 
       class which (unlike gzip.GzipFile) has no support for 
       a file object argument. 
    &quot;&quot;&quot;</span>

    <span class="s1">blocksize = </span><span class="s4">16 </span><span class="s1">* </span><span class="s4">1024</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">mode):</span>
        <span class="s1">self.fileobj = fileobj</span>
        <span class="s1">self.mode = mode</span>
        <span class="s1">self.name = getattr(self.fileobj</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">self.init()</span>

    <span class="s2">def </span><span class="s1">init(self):</span>
        <span class="s2">import </span><span class="s1">bz2</span>
        <span class="s1">self.pos = </span><span class="s4">0</span>
        <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;r&quot;</span><span class="s1">:</span>
            <span class="s1">self.bz2obj = bz2.BZ2Decompressor()</span>
            <span class="s1">self.fileobj.seek(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">self.buf = </span><span class="s5">b&quot;&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.bz2obj = bz2.BZ2Compressor()</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">size):</span>
        <span class="s1">x = len(self.buf)</span>
        <span class="s2">while </span><span class="s1">x &lt; size:</span>
            <span class="s1">raw = self.fileobj.read(self.blocksize)</span>
            <span class="s2">if not </span><span class="s1">raw:</span>
                <span class="s2">break</span>
            <span class="s1">data = self.bz2obj.decompress(raw)</span>
            <span class="s1">self.buf += data</span>
            <span class="s1">x += len(data)</span>

        <span class="s1">buf = self.buf[:size]</span>
        <span class="s1">self.buf = self.buf[size:]</span>
        <span class="s1">self.pos += len(buf)</span>
        <span class="s2">return </span><span class="s1">buf</span>

    <span class="s2">def </span><span class="s1">seek(self</span><span class="s2">, </span><span class="s1">pos):</span>
        <span class="s2">if </span><span class="s1">pos &lt; self.pos:</span>
            <span class="s1">self.init()</span>
        <span class="s1">self.read(pos - self.pos)</span>

    <span class="s2">def </span><span class="s1">tell(self):</span>
        <span class="s2">return </span><span class="s1">self.pos</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">self.pos += len(data)</span>
        <span class="s1">raw = self.bz2obj.compress(data)</span>
        <span class="s1">self.fileobj.write(raw)</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;w&quot;</span><span class="s1">:</span>
            <span class="s1">raw = self.bz2obj.flush()</span>
            <span class="s1">self.fileobj.write(raw)</span>
<span class="s0"># class _BZ2Proxy</span>

<span class="s0">#------------------------</span>
<span class="s0"># Extraction file object</span>
<span class="s0">#------------------------</span>
<span class="s2">class </span><span class="s1">_FileInFile(object):</span>
    <span class="s6">&quot;&quot;&quot;A thin wrapper around an existing file object that 
       provides a part of its data as an individual file 
       object. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">blockinfo=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.fileobj = fileobj</span>
        <span class="s1">self.offset = offset</span>
        <span class="s1">self.size = size</span>
        <span class="s1">self.position = </span><span class="s4">0</span>

        <span class="s2">if </span><span class="s1">blockinfo </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">blockinfo = [(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">size)]</span>

        <span class="s0"># Construct a map with data and zero blocks.</span>
        <span class="s1">self.map_index = </span><span class="s4">0</span>
        <span class="s1">self.map = []</span>
        <span class="s1">lastpos = </span><span class="s4">0</span>
        <span class="s1">realpos = self.offset</span>
        <span class="s2">for </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">size </span><span class="s2">in </span><span class="s1">blockinfo:</span>
            <span class="s2">if </span><span class="s1">offset &gt; lastpos:</span>
                <span class="s1">self.map.append((</span><span class="s2">False, </span><span class="s1">lastpos</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, None</span><span class="s1">))</span>
            <span class="s1">self.map.append((</span><span class="s2">True, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">offset + size</span><span class="s2">, </span><span class="s1">realpos))</span>
            <span class="s1">realpos += size</span>
            <span class="s1">lastpos = offset + size</span>
        <span class="s2">if </span><span class="s1">lastpos &lt; self.size:</span>
            <span class="s1">self.map.append((</span><span class="s2">False, </span><span class="s1">lastpos</span><span class="s2">, </span><span class="s1">self.size</span><span class="s2">, None</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">seekable(self):</span>
        <span class="s2">if not </span><span class="s1">hasattr(self.fileobj</span><span class="s2">, </span><span class="s3">&quot;seekable&quot;</span><span class="s1">):</span>
            <span class="s0"># XXX gzip.GzipFile and bz2.BZ2File</span>
            <span class="s2">return True</span>
        <span class="s2">return </span><span class="s1">self.fileobj.seekable()</span>

    <span class="s2">def </span><span class="s1">tell(self):</span>
        <span class="s6">&quot;&quot;&quot;Return the current file position. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.position</span>

    <span class="s2">def </span><span class="s1">seek(self</span><span class="s2">, </span><span class="s1">position):</span>
        <span class="s6">&quot;&quot;&quot;Seek to a position in the file. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.position = position</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">size=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Read data from the file. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">size = self.size - self.position</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">size = min(size</span><span class="s2">, </span><span class="s1">self.size - self.position)</span>

        <span class="s1">buf = </span><span class="s5">b&quot;&quot;</span>
        <span class="s2">while </span><span class="s1">size &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s1">data</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">offset = self.map[self.map_index]</span>
                <span class="s2">if </span><span class="s1">start &lt;= self.position &lt; stop:</span>
                    <span class="s2">break</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.map_index += </span><span class="s4">1</span>
                    <span class="s2">if </span><span class="s1">self.map_index == len(self.map):</span>
                        <span class="s1">self.map_index = </span><span class="s4">0</span>
            <span class="s1">length = min(size</span><span class="s2">, </span><span class="s1">stop - self.position)</span>
            <span class="s2">if </span><span class="s1">data:</span>
                <span class="s1">self.fileobj.seek(offset + (self.position - start))</span>
                <span class="s1">buf += self.fileobj.read(length)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">buf += NUL * length</span>
            <span class="s1">size -= length</span>
            <span class="s1">self.position += length</span>
        <span class="s2">return </span><span class="s1">buf</span>
<span class="s0">#class _FileInFile</span>


<span class="s2">class </span><span class="s1">ExFileObject(object):</span>
    <span class="s6">&quot;&quot;&quot;File-like object for reading an archive member. 
       Is returned by TarFile.extractfile(). 
    &quot;&quot;&quot;</span>
    <span class="s1">blocksize = </span><span class="s4">1024</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">tarfile</span><span class="s2">, </span><span class="s1">tarinfo):</span>
        <span class="s1">self.fileobj = _FileInFile(tarfile.fileobj</span><span class="s2">,</span>
                                   <span class="s1">tarinfo.offset_data</span><span class="s2">,</span>
                                   <span class="s1">tarinfo.size</span><span class="s2">,</span>
                                   <span class="s1">tarinfo.sparse)</span>
        <span class="s1">self.name = tarinfo.name</span>
        <span class="s1">self.mode = </span><span class="s3">&quot;r&quot;</span>
        <span class="s1">self.closed = </span><span class="s2">False</span>
        <span class="s1">self.size = tarinfo.size</span>

        <span class="s1">self.position = </span><span class="s4">0</span>
        <span class="s1">self.buffer = </span><span class="s5">b&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">readable(self):</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">writable(self):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">seekable(self):</span>
        <span class="s2">return </span><span class="s1">self.fileobj.seekable()</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">size=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Read at most size bytes from the file. If size is not 
           present or None, read all data until EOF is reached. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.closed:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;I/O operation on closed file&quot;</span><span class="s1">)</span>

        <span class="s1">buf = </span><span class="s5">b&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.buffer:</span>
            <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">buf = self.buffer</span>
                <span class="s1">self.buffer = </span><span class="s5">b&quot;&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">buf = self.buffer[:size]</span>
                <span class="s1">self.buffer = self.buffer[size:]</span>

        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">buf += self.fileobj.read()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">buf += self.fileobj.read(size - len(buf))</span>

        <span class="s1">self.position += len(buf)</span>
        <span class="s2">return </span><span class="s1">buf</span>

    <span class="s0"># XXX TextIOWrapper uses the read1() method.</span>
    <span class="s1">read1 = read</span>

    <span class="s2">def </span><span class="s1">readline(self</span><span class="s2">, </span><span class="s1">size=-</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Read one entire line from the file. If size is present 
           and non-negative, return a string with at most that 
           size, which may be an incomplete line. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.closed:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;I/O operation on closed file&quot;</span><span class="s1">)</span>

        <span class="s1">pos = self.buffer.find(</span><span class="s5">b&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">) + </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">pos == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># no newline found.</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s1">buf = self.fileobj.read(self.blocksize)</span>
                <span class="s1">self.buffer += buf</span>
                <span class="s2">if not </span><span class="s1">buf </span><span class="s2">or </span><span class="s5">b&quot;</span><span class="s2">\n</span><span class="s5">&quot; </span><span class="s2">in </span><span class="s1">buf:</span>
                    <span class="s1">pos = self.buffer.find(</span><span class="s5">b&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">) + </span><span class="s4">1</span>
                    <span class="s2">if </span><span class="s1">pos == </span><span class="s4">0</span><span class="s1">:</span>
                        <span class="s0"># no newline found.</span>
                        <span class="s1">pos = len(self.buffer)</span>
                    <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">size != -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">pos = min(size</span><span class="s2">, </span><span class="s1">pos)</span>

        <span class="s1">buf = self.buffer[:pos]</span>
        <span class="s1">self.buffer = self.buffer[pos:]</span>
        <span class="s1">self.position += len(buf)</span>
        <span class="s2">return </span><span class="s1">buf</span>

    <span class="s2">def </span><span class="s1">readlines(self):</span>
        <span class="s6">&quot;&quot;&quot;Return a list with all remaining lines. 
        &quot;&quot;&quot;</span>
        <span class="s1">result = []</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">line = self.readline()</span>
            <span class="s2">if not </span><span class="s1">line: </span><span class="s2">break</span>
            <span class="s1">result.append(line)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">tell(self):</span>
        <span class="s6">&quot;&quot;&quot;Return the current file position. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.closed:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;I/O operation on closed file&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self.position</span>

    <span class="s2">def </span><span class="s1">seek(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">whence=os.SEEK_SET):</span>
        <span class="s6">&quot;&quot;&quot;Seek to a position in the file. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.closed:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;I/O operation on closed file&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">whence == os.SEEK_SET:</span>
            <span class="s1">self.position = min(max(pos</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">self.size)</span>
        <span class="s2">elif </span><span class="s1">whence == os.SEEK_CUR:</span>
            <span class="s2">if </span><span class="s1">pos &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self.position = max(self.position + pos</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.position = min(self.position + pos</span><span class="s2">, </span><span class="s1">self.size)</span>
        <span class="s2">elif </span><span class="s1">whence == os.SEEK_END:</span>
            <span class="s1">self.position = max(min(self.size + pos</span><span class="s2">, </span><span class="s1">self.size)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid argument&quot;</span><span class="s1">)</span>

        <span class="s1">self.buffer = </span><span class="s5">b&quot;&quot;</span>
        <span class="s1">self.fileobj.seek(self.position)</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s6">&quot;&quot;&quot;Close the file object. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.closed = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s6">&quot;&quot;&quot;Get an iterator over the file's lines. 
        &quot;&quot;&quot;</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">line = self.readline()</span>
            <span class="s2">if not </span><span class="s1">line:</span>
                <span class="s2">break</span>
            <span class="s2">yield </span><span class="s1">line</span>
<span class="s0">#class ExFileObject</span>

<span class="s0">#------------------</span>
<span class="s0"># Exported Classes</span>
<span class="s0">#------------------</span>
<span class="s2">class </span><span class="s1">TarInfo(object):</span>
    <span class="s6">&quot;&quot;&quot;Informational class which holds the details about an 
       archive member given by a tar header block. 
       TarInfo objects are returned by TarFile.getmember(), 
       TarFile.getmembers() and TarFile.gettarinfo() and are 
       usually created internally. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;mode&quot;</span><span class="s2">, </span><span class="s3">&quot;uid&quot;</span><span class="s2">, </span><span class="s3">&quot;gid&quot;</span><span class="s2">, </span><span class="s3">&quot;size&quot;</span><span class="s2">, </span><span class="s3">&quot;mtime&quot;</span><span class="s2">,</span>
                 <span class="s3">&quot;chksum&quot;</span><span class="s2">, </span><span class="s3">&quot;type&quot;</span><span class="s2">, </span><span class="s3">&quot;linkname&quot;</span><span class="s2">, </span><span class="s3">&quot;uname&quot;</span><span class="s2">, </span><span class="s3">&quot;gname&quot;</span><span class="s2">,</span>
                 <span class="s3">&quot;devmajor&quot;</span><span class="s2">, </span><span class="s3">&quot;devminor&quot;</span><span class="s2">,</span>
                 <span class="s3">&quot;offset&quot;</span><span class="s2">, </span><span class="s3">&quot;offset_data&quot;</span><span class="s2">, </span><span class="s3">&quot;pax_headers&quot;</span><span class="s2">, </span><span class="s3">&quot;sparse&quot;</span><span class="s2">,</span>
                 <span class="s3">&quot;tarfile&quot;</span><span class="s2">, </span><span class="s3">&quot;_sparse_structs&quot;</span><span class="s2">, </span><span class="s3">&quot;_link_target&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;&quot;</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Construct a TarInfo object. name is the optional name 
           of the member. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.name = name        </span><span class="s0"># member name</span>
        <span class="s1">self.mode = </span><span class="s4">0o644       </span><span class="s0"># file permissions</span>
        <span class="s1">self.uid = </span><span class="s4">0            </span><span class="s0"># user id</span>
        <span class="s1">self.gid = </span><span class="s4">0            </span><span class="s0"># group id</span>
        <span class="s1">self.size = </span><span class="s4">0           </span><span class="s0"># file size</span>
        <span class="s1">self.mtime = </span><span class="s4">0          </span><span class="s0"># modification time</span>
        <span class="s1">self.chksum = </span><span class="s4">0         </span><span class="s0"># header checksum</span>
        <span class="s1">self.type = REGTYPE     </span><span class="s0"># member type</span>
        <span class="s1">self.linkname = </span><span class="s3">&quot;&quot;      </span><span class="s0"># link name</span>
        <span class="s1">self.uname = </span><span class="s3">&quot;&quot;         </span><span class="s0"># user name</span>
        <span class="s1">self.gname = </span><span class="s3">&quot;&quot;         </span><span class="s0"># group name</span>
        <span class="s1">self.devmajor = </span><span class="s4">0       </span><span class="s0"># device major number</span>
        <span class="s1">self.devminor = </span><span class="s4">0       </span><span class="s0"># device minor number</span>

        <span class="s1">self.offset = </span><span class="s4">0         </span><span class="s0"># the tar header starts here</span>
        <span class="s1">self.offset_data = </span><span class="s4">0    </span><span class="s0"># the file's data starts here</span>

        <span class="s1">self.sparse = </span><span class="s2">None      </span><span class="s0"># sparse member information</span>
        <span class="s1">self.pax_headers = {}   </span><span class="s0"># pax header information</span>

    <span class="s0"># In pax headers the &quot;name&quot; and &quot;linkname&quot; field are called</span>
    <span class="s0"># &quot;path&quot; and &quot;linkpath&quot;.</span>
    <span class="s2">def </span><span class="s1">_getpath(self):</span>
        <span class="s2">return </span><span class="s1">self.name</span>
    <span class="s2">def </span><span class="s1">_setpath(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">self.name = name</span>
    <span class="s1">path = property(_getpath</span><span class="s2">, </span><span class="s1">_setpath)</span>

    <span class="s2">def </span><span class="s1">_getlinkpath(self):</span>
        <span class="s2">return </span><span class="s1">self.linkname</span>
    <span class="s2">def </span><span class="s1">_setlinkpath(self</span><span class="s2">, </span><span class="s1">linkname):</span>
        <span class="s1">self.linkname = linkname</span>
    <span class="s1">linkpath = property(_getlinkpath</span><span class="s2">, </span><span class="s1">_setlinkpath)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;%s %r at %#x&gt;&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s2">,</span><span class="s1">self.name</span><span class="s2">,</span><span class="s1">id(self))</span>

    <span class="s2">def </span><span class="s1">get_info(self):</span>
        <span class="s6">&quot;&quot;&quot;Return the TarInfo's attributes as a dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s1">info = {</span>
            <span class="s3">&quot;name&quot;</span><span class="s1">:     self.name</span><span class="s2">,</span>
            <span class="s3">&quot;mode&quot;</span><span class="s1">:     self.mode &amp; </span><span class="s4">0o7777</span><span class="s2">,</span>
            <span class="s3">&quot;uid&quot;</span><span class="s1">:      self.uid</span><span class="s2">,</span>
            <span class="s3">&quot;gid&quot;</span><span class="s1">:      self.gid</span><span class="s2">,</span>
            <span class="s3">&quot;size&quot;</span><span class="s1">:     self.size</span><span class="s2">,</span>
            <span class="s3">&quot;mtime&quot;</span><span class="s1">:    self.mtime</span><span class="s2">,</span>
            <span class="s3">&quot;chksum&quot;</span><span class="s1">:   self.chksum</span><span class="s2">,</span>
            <span class="s3">&quot;type&quot;</span><span class="s1">:     self.type</span><span class="s2">,</span>
            <span class="s3">&quot;linkname&quot;</span><span class="s1">: self.linkname</span><span class="s2">,</span>
            <span class="s3">&quot;uname&quot;</span><span class="s1">:    self.uname</span><span class="s2">,</span>
            <span class="s3">&quot;gname&quot;</span><span class="s1">:    self.gname</span><span class="s2">,</span>
            <span class="s3">&quot;devmajor&quot;</span><span class="s1">: self.devmajor</span><span class="s2">,</span>
            <span class="s3">&quot;devminor&quot;</span><span class="s1">: self.devminor</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">info[</span><span class="s3">&quot;type&quot;</span><span class="s1">] == DIRTYPE </span><span class="s2">and not </span><span class="s1">info[</span><span class="s3">&quot;name&quot;</span><span class="s1">].endswith(</span><span class="s3">&quot;/&quot;</span><span class="s1">):</span>
            <span class="s1">info[</span><span class="s3">&quot;name&quot;</span><span class="s1">] += </span><span class="s3">&quot;/&quot;</span>

        <span class="s2">return </span><span class="s1">info</span>

    <span class="s2">def </span><span class="s1">tobuf(self</span><span class="s2">, </span><span class="s1">format=DEFAULT_FORMAT</span><span class="s2">, </span><span class="s1">encoding=ENCODING</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;surrogateescape&quot;</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Return a tar header as a string of 512 byte blocks. 
        &quot;&quot;&quot;</span>
        <span class="s1">info = self.get_info()</span>

        <span class="s2">if </span><span class="s1">format == USTAR_FORMAT:</span>
            <span class="s2">return </span><span class="s1">self.create_ustar_header(info</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>
        <span class="s2">elif </span><span class="s1">format == GNU_FORMAT:</span>
            <span class="s2">return </span><span class="s1">self.create_gnu_header(info</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>
        <span class="s2">elif </span><span class="s1">format == PAX_FORMAT:</span>
            <span class="s2">return </span><span class="s1">self.create_pax_header(info</span><span class="s2">, </span><span class="s1">encoding)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;invalid format&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">create_ustar_header(self</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors):</span>
        <span class="s6">&quot;&quot;&quot;Return the object as a ustar header block. 
        &quot;&quot;&quot;</span>
        <span class="s1">info[</span><span class="s3">&quot;magic&quot;</span><span class="s1">] = POSIX_MAGIC</span>

        <span class="s2">if </span><span class="s1">len(info[</span><span class="s3">&quot;linkname&quot;</span><span class="s1">]) &gt; LENGTH_LINK:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;linkname is too long&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">len(info[</span><span class="s3">&quot;name&quot;</span><span class="s1">]) &gt; LENGTH_NAME:</span>
            <span class="s1">info[</span><span class="s3">&quot;prefix&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">info[</span><span class="s3">&quot;name&quot;</span><span class="s1">] = self._posix_split_name(info[</span><span class="s3">&quot;name&quot;</span><span class="s1">])</span>

        <span class="s2">return </span><span class="s1">self._create_header(info</span><span class="s2">, </span><span class="s1">USTAR_FORMAT</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>

    <span class="s2">def </span><span class="s1">create_gnu_header(self</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors):</span>
        <span class="s6">&quot;&quot;&quot;Return the object as a GNU header block sequence. 
        &quot;&quot;&quot;</span>
        <span class="s1">info[</span><span class="s3">&quot;magic&quot;</span><span class="s1">] = GNU_MAGIC</span>

        <span class="s1">buf = </span><span class="s5">b&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(info[</span><span class="s3">&quot;linkname&quot;</span><span class="s1">]) &gt; LENGTH_LINK:</span>
            <span class="s1">buf += self._create_gnu_long_header(info[</span><span class="s3">&quot;linkname&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">GNUTYPE_LONGLINK</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>

        <span class="s2">if </span><span class="s1">len(info[</span><span class="s3">&quot;name&quot;</span><span class="s1">]) &gt; LENGTH_NAME:</span>
            <span class="s1">buf += self._create_gnu_long_header(info[</span><span class="s3">&quot;name&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">GNUTYPE_LONGNAME</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>

        <span class="s2">return </span><span class="s1">buf + self._create_header(info</span><span class="s2">, </span><span class="s1">GNU_FORMAT</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>

    <span class="s2">def </span><span class="s1">create_pax_header(self</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">encoding):</span>
        <span class="s6">&quot;&quot;&quot;Return the object as a ustar header block. If it cannot be 
           represented this way, prepend a pax extended header sequence 
           with supplement information. 
        &quot;&quot;&quot;</span>
        <span class="s1">info[</span><span class="s3">&quot;magic&quot;</span><span class="s1">] = POSIX_MAGIC</span>
        <span class="s1">pax_headers = self.pax_headers.copy()</span>

        <span class="s0"># Test string fields for values that exceed the field length or cannot</span>
        <span class="s0"># be represented in ASCII encoding.</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">hname</span><span class="s2">, </span><span class="s1">length </span><span class="s2">in </span><span class="s1">(</span>
                <span class="s1">(</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;path&quot;</span><span class="s2">, </span><span class="s1">LENGTH_NAME)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;linkname&quot;</span><span class="s2">, </span><span class="s3">&quot;linkpath&quot;</span><span class="s2">, </span><span class="s1">LENGTH_LINK)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s3">&quot;uname&quot;</span><span class="s2">, </span><span class="s3">&quot;uname&quot;</span><span class="s2">, </span><span class="s4">32</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;gname&quot;</span><span class="s2">, </span><span class="s3">&quot;gname&quot;</span><span class="s2">, </span><span class="s4">32</span><span class="s1">)):</span>

            <span class="s2">if </span><span class="s1">hname </span><span class="s2">in </span><span class="s1">pax_headers:</span>
                <span class="s0"># The pax header has priority.</span>
                <span class="s2">continue</span>

            <span class="s0"># Try to encode the string as ASCII.</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">info[name].encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s2">, </span><span class="s3">&quot;strict&quot;</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">UnicodeEncodeError:</span>
                <span class="s1">pax_headers[hname] = info[name]</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">len(info[name]) &gt; length:</span>
                <span class="s1">pax_headers[hname] = info[name]</span>

        <span class="s0"># Test number fields for values that exceed the field limit or values</span>
        <span class="s0"># that like to be stored as float.</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">digits </span><span class="s2">in </span><span class="s1">((</span><span class="s3">&quot;uid&quot;</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;gid&quot;</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;size&quot;</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;mtime&quot;</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)):</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">pax_headers:</span>
                <span class="s0"># The pax header has priority. Avoid overflow.</span>
                <span class="s1">info[name] = </span><span class="s4">0</span>
                <span class="s2">continue</span>

            <span class="s1">val = info[name]</span>
            <span class="s2">if not </span><span class="s4">0 </span><span class="s1">&lt;= val &lt; </span><span class="s4">8 </span><span class="s1">** (digits - </span><span class="s4">1</span><span class="s1">) </span><span class="s2">or </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">float):</span>
                <span class="s1">pax_headers[name] = str(val)</span>
                <span class="s1">info[name] = </span><span class="s4">0</span>

        <span class="s0"># Create a pax extended header if necessary.</span>
        <span class="s2">if </span><span class="s1">pax_headers:</span>
            <span class="s1">buf = self._create_pax_generic_header(pax_headers</span><span class="s2">, </span><span class="s1">XHDTYPE</span><span class="s2">, </span><span class="s1">encoding)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">buf = </span><span class="s5">b&quot;&quot;</span>

        <span class="s2">return </span><span class="s1">buf + self._create_header(info</span><span class="s2">, </span><span class="s1">USTAR_FORMAT</span><span class="s2">, </span><span class="s3">&quot;ascii&quot;</span><span class="s2">, </span><span class="s3">&quot;replace&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">create_pax_global_header(cls</span><span class="s2">, </span><span class="s1">pax_headers):</span>
        <span class="s6">&quot;&quot;&quot;Return the object as a pax global header block sequence. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">cls._create_pax_generic_header(pax_headers</span><span class="s2">, </span><span class="s1">XGLTYPE</span><span class="s2">, </span><span class="s3">&quot;utf8&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_posix_split_name(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s6">&quot;&quot;&quot;Split a name longer than 100 chars into a prefix 
           and a name part. 
        &quot;&quot;&quot;</span>
        <span class="s1">prefix = name[:LENGTH_PREFIX + </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">while </span><span class="s1">prefix </span><span class="s2">and </span><span class="s1">prefix[-</span><span class="s4">1</span><span class="s1">] != </span><span class="s3">&quot;/&quot;</span><span class="s1">:</span>
            <span class="s1">prefix = prefix[:-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">name = name[len(prefix):]</span>
        <span class="s1">prefix = prefix[:-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s2">if not </span><span class="s1">prefix </span><span class="s2">or </span><span class="s1">len(name) &gt; LENGTH_NAME:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;name is too long&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">name</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_create_header(info</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors):</span>
        <span class="s6">&quot;&quot;&quot;Return a header block. info is a dictionary with file 
           information, format must be one of the *_FORMAT constants. 
        &quot;&quot;&quot;</span>
        <span class="s1">parts = [</span>
            <span class="s1">stn(info.get(</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span><span class="s2">,</span>
            <span class="s1">itn(info.get(</span><span class="s3">&quot;mode&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) &amp; </span><span class="s4">0o7777</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s1">format)</span><span class="s2">,</span>
            <span class="s1">itn(info.get(</span><span class="s3">&quot;uid&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s1">format)</span><span class="s2">,</span>
            <span class="s1">itn(info.get(</span><span class="s3">&quot;gid&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s1">format)</span><span class="s2">,</span>
            <span class="s1">itn(info.get(</span><span class="s3">&quot;size&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s1">format)</span><span class="s2">,</span>
            <span class="s1">itn(info.get(</span><span class="s3">&quot;mtime&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s1">format)</span><span class="s2">,</span>
            <span class="s5">b&quot;        &quot;</span><span class="s2">, </span><span class="s0"># checksum field</span>
            <span class="s1">info.get(</span><span class="s3">&quot;type&quot;</span><span class="s2">, </span><span class="s1">REGTYPE)</span><span class="s2">,</span>
            <span class="s1">stn(info.get(</span><span class="s3">&quot;linkname&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span><span class="s2">,</span>
            <span class="s1">info.get(</span><span class="s3">&quot;magic&quot;</span><span class="s2">, </span><span class="s1">POSIX_MAGIC)</span><span class="s2">,</span>
            <span class="s1">stn(info.get(</span><span class="s3">&quot;uname&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s4">32</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span><span class="s2">,</span>
            <span class="s1">stn(info.get(</span><span class="s3">&quot;gname&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s4">32</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span><span class="s2">,</span>
            <span class="s1">itn(info.get(</span><span class="s3">&quot;devmajor&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s1">format)</span><span class="s2">,</span>
            <span class="s1">itn(info.get(</span><span class="s3">&quot;devminor&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s1">format)</span><span class="s2">,</span>
            <span class="s1">stn(info.get(</span><span class="s3">&quot;prefix&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s4">155</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>
        <span class="s1">]</span>

        <span class="s1">buf = struct.pack(</span><span class="s3">&quot;%ds&quot; </span><span class="s1">% BLOCKSIZE</span><span class="s2">, </span><span class="s5">b&quot;&quot;</span><span class="s1">.join(parts))</span>
        <span class="s1">chksum = calc_chksums(buf[-BLOCKSIZE:])[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">buf = buf[:-</span><span class="s4">364</span><span class="s1">] + (</span><span class="s3">&quot;%06o</span><span class="s2">\0</span><span class="s3">&quot; </span><span class="s1">% chksum).encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">) + buf[-</span><span class="s4">357</span><span class="s1">:]</span>
        <span class="s2">return </span><span class="s1">buf</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_create_payload(payload):</span>
        <span class="s6">&quot;&quot;&quot;Return the string payload filled with zero bytes 
           up to the next 512 byte border. 
        &quot;&quot;&quot;</span>
        <span class="s1">blocks</span><span class="s2">, </span><span class="s1">remainder = divmod(len(payload)</span><span class="s2">, </span><span class="s1">BLOCKSIZE)</span>
        <span class="s2">if </span><span class="s1">remainder &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">payload += (BLOCKSIZE - remainder) * NUL</span>
        <span class="s2">return </span><span class="s1">payload</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_create_gnu_long_header(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors):</span>
        <span class="s6">&quot;&quot;&quot;Return a GNUTYPE_LONGNAME or GNUTYPE_LONGLINK sequence 
           for name. 
        &quot;&quot;&quot;</span>
        <span class="s1">name = name.encode(encoding</span><span class="s2">, </span><span class="s1">errors) + NUL</span>

        <span class="s1">info = {}</span>
        <span class="s1">info[</span><span class="s3">&quot;name&quot;</span><span class="s1">] = </span><span class="s3">&quot;././@LongLink&quot;</span>
        <span class="s1">info[</span><span class="s3">&quot;type&quot;</span><span class="s1">] = type</span>
        <span class="s1">info[</span><span class="s3">&quot;size&quot;</span><span class="s1">] = len(name)</span>
        <span class="s1">info[</span><span class="s3">&quot;magic&quot;</span><span class="s1">] = GNU_MAGIC</span>

        <span class="s0"># create extended header + name blocks.</span>
        <span class="s2">return </span><span class="s1">cls._create_header(info</span><span class="s2">, </span><span class="s1">USTAR_FORMAT</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors) + \</span>
                <span class="s1">cls._create_payload(name)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_create_pax_generic_header(cls</span><span class="s2">, </span><span class="s1">pax_headers</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">encoding):</span>
        <span class="s6">&quot;&quot;&quot;Return a POSIX.1-2008 extended or global header sequence 
           that contains a list of keyword, value pairs. The values 
           must be strings. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Check if one of the fields contains surrogate characters and thereby</span>
        <span class="s0"># forces hdrcharset=BINARY, see _proc_pax() for more information.</span>
        <span class="s1">binary = </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">keyword</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">pax_headers.items():</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">value.encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s2">, </span><span class="s3">&quot;strict&quot;</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">UnicodeEncodeError:</span>
                <span class="s1">binary = </span><span class="s2">True</span>
                <span class="s2">break</span>

        <span class="s1">records = </span><span class="s5">b&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">binary:</span>
            <span class="s0"># Put the hdrcharset field at the beginning of the header.</span>
            <span class="s1">records += </span><span class="s5">b&quot;21 hdrcharset=BINARY</span><span class="s2">\n</span><span class="s5">&quot;</span>

        <span class="s2">for </span><span class="s1">keyword</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">pax_headers.items():</span>
            <span class="s1">keyword = keyword.encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">binary:</span>
                <span class="s0"># Try to restore the original byte representation of `value'.</span>
                <span class="s0"># Needless to say, that the encoding must match the string.</span>
                <span class="s1">value = value.encode(encoding</span><span class="s2">, </span><span class="s3">&quot;surrogateescape&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">value = value.encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">)</span>

            <span class="s1">l = len(keyword) + len(value) + </span><span class="s4">3   </span><span class="s0"># ' ' + '=' + '\n'</span>
            <span class="s1">n = p = </span><span class="s4">0</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s1">n = l + len(str(p))</span>
                <span class="s2">if </span><span class="s1">n == p:</span>
                    <span class="s2">break</span>
                <span class="s1">p = n</span>
            <span class="s1">records += bytes(str(p)</span><span class="s2">, </span><span class="s3">&quot;ascii&quot;</span><span class="s1">) + </span><span class="s5">b&quot; &quot; </span><span class="s1">+ keyword + </span><span class="s5">b&quot;=&quot; </span><span class="s1">+ value + </span><span class="s5">b&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span>

        <span class="s0"># We use a hardcoded &quot;././@PaxHeader&quot; name like star does</span>
        <span class="s0"># instead of the one that POSIX recommends.</span>
        <span class="s1">info = {}</span>
        <span class="s1">info[</span><span class="s3">&quot;name&quot;</span><span class="s1">] = </span><span class="s3">&quot;././@PaxHeader&quot;</span>
        <span class="s1">info[</span><span class="s3">&quot;type&quot;</span><span class="s1">] = type</span>
        <span class="s1">info[</span><span class="s3">&quot;size&quot;</span><span class="s1">] = len(records)</span>
        <span class="s1">info[</span><span class="s3">&quot;magic&quot;</span><span class="s1">] = POSIX_MAGIC</span>

        <span class="s0"># Create pax header + record blocks.</span>
        <span class="s2">return </span><span class="s1">cls._create_header(info</span><span class="s2">, </span><span class="s1">USTAR_FORMAT</span><span class="s2">, </span><span class="s3">&quot;ascii&quot;</span><span class="s2">, </span><span class="s3">&quot;replace&quot;</span><span class="s1">) + \</span>
                <span class="s1">cls._create_payload(records)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">frombuf(cls</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors):</span>
        <span class="s6">&quot;&quot;&quot;Construct a TarInfo object from a 512 byte bytes object. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(buf) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">EmptyHeaderError(</span><span class="s3">&quot;empty header&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(buf) != BLOCKSIZE:</span>
            <span class="s2">raise </span><span class="s1">TruncatedHeaderError(</span><span class="s3">&quot;truncated header&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">buf.count(NUL) == BLOCKSIZE:</span>
            <span class="s2">raise </span><span class="s1">EOFHeaderError(</span><span class="s3">&quot;end of file header&quot;</span><span class="s1">)</span>

        <span class="s1">chksum = nti(buf[</span><span class="s4">148</span><span class="s1">:</span><span class="s4">156</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">chksum </span><span class="s2">not in </span><span class="s1">calc_chksums(buf):</span>
            <span class="s2">raise </span><span class="s1">InvalidHeaderError(</span><span class="s3">&quot;bad checksum&quot;</span><span class="s1">)</span>

        <span class="s1">obj = cls()</span>
        <span class="s1">obj.name = nts(buf[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">100</span><span class="s1">]</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>
        <span class="s1">obj.mode = nti(buf[</span><span class="s4">100</span><span class="s1">:</span><span class="s4">108</span><span class="s1">])</span>
        <span class="s1">obj.uid = nti(buf[</span><span class="s4">108</span><span class="s1">:</span><span class="s4">116</span><span class="s1">])</span>
        <span class="s1">obj.gid = nti(buf[</span><span class="s4">116</span><span class="s1">:</span><span class="s4">124</span><span class="s1">])</span>
        <span class="s1">obj.size = nti(buf[</span><span class="s4">124</span><span class="s1">:</span><span class="s4">136</span><span class="s1">])</span>
        <span class="s1">obj.mtime = nti(buf[</span><span class="s4">136</span><span class="s1">:</span><span class="s4">148</span><span class="s1">])</span>
        <span class="s1">obj.chksum = chksum</span>
        <span class="s1">obj.type = buf[</span><span class="s4">156</span><span class="s1">:</span><span class="s4">157</span><span class="s1">]</span>
        <span class="s1">obj.linkname = nts(buf[</span><span class="s4">157</span><span class="s1">:</span><span class="s4">257</span><span class="s1">]</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>
        <span class="s1">obj.uname = nts(buf[</span><span class="s4">265</span><span class="s1">:</span><span class="s4">297</span><span class="s1">]</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>
        <span class="s1">obj.gname = nts(buf[</span><span class="s4">297</span><span class="s1">:</span><span class="s4">329</span><span class="s1">]</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>
        <span class="s1">obj.devmajor = nti(buf[</span><span class="s4">329</span><span class="s1">:</span><span class="s4">337</span><span class="s1">])</span>
        <span class="s1">obj.devminor = nti(buf[</span><span class="s4">337</span><span class="s1">:</span><span class="s4">345</span><span class="s1">])</span>
        <span class="s1">prefix = nts(buf[</span><span class="s4">345</span><span class="s1">:</span><span class="s4">500</span><span class="s1">]</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>

        <span class="s0"># Old V7 tar format represents a directory as a regular</span>
        <span class="s0"># file with a trailing slash.</span>
        <span class="s2">if </span><span class="s1">obj.type == AREGTYPE </span><span class="s2">and </span><span class="s1">obj.name.endswith(</span><span class="s3">&quot;/&quot;</span><span class="s1">):</span>
            <span class="s1">obj.type = DIRTYPE</span>

        <span class="s0"># The old GNU sparse format occupies some of the unused</span>
        <span class="s0"># space in the buffer for up to 4 sparse structures.</span>
        <span class="s0"># Save the them for later processing in _proc_sparse().</span>
        <span class="s2">if </span><span class="s1">obj.type == GNUTYPE_SPARSE:</span>
            <span class="s1">pos = </span><span class="s4">386</span>
            <span class="s1">structs = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">offset = nti(buf[pos:pos + </span><span class="s4">12</span><span class="s1">])</span>
                    <span class="s1">numbytes = nti(buf[pos + </span><span class="s4">12</span><span class="s1">:pos + </span><span class="s4">24</span><span class="s1">])</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s2">break</span>
                <span class="s1">structs.append((offset</span><span class="s2">, </span><span class="s1">numbytes))</span>
                <span class="s1">pos += </span><span class="s4">24</span>
            <span class="s1">isextended = bool(buf[</span><span class="s4">482</span><span class="s1">])</span>
            <span class="s1">origsize = nti(buf[</span><span class="s4">483</span><span class="s1">:</span><span class="s4">495</span><span class="s1">])</span>
            <span class="s1">obj._sparse_structs = (structs</span><span class="s2">, </span><span class="s1">isextended</span><span class="s2">, </span><span class="s1">origsize)</span>

        <span class="s0"># Remove redundant slashes from directories.</span>
        <span class="s2">if </span><span class="s1">obj.isdir():</span>
            <span class="s1">obj.name = obj.name.rstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>

        <span class="s0"># Reconstruct a ustar longname.</span>
        <span class="s2">if </span><span class="s1">prefix </span><span class="s2">and </span><span class="s1">obj.type </span><span class="s2">not in </span><span class="s1">GNU_TYPES:</span>
            <span class="s1">obj.name = prefix + </span><span class="s3">&quot;/&quot; </span><span class="s1">+ obj.name</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">fromtarfile(cls</span><span class="s2">, </span><span class="s1">tarfile):</span>
        <span class="s6">&quot;&quot;&quot;Return the next TarInfo object from TarFile object 
           tarfile. 
        &quot;&quot;&quot;</span>
        <span class="s1">buf = tarfile.fileobj.read(BLOCKSIZE)</span>
        <span class="s1">obj = cls.frombuf(buf</span><span class="s2">, </span><span class="s1">tarfile.encoding</span><span class="s2">, </span><span class="s1">tarfile.errors)</span>
        <span class="s1">obj.offset = tarfile.fileobj.tell() - BLOCKSIZE</span>
        <span class="s2">return </span><span class="s1">obj._proc_member(tarfile)</span>

    <span class="s0">#--------------------------------------------------------------------------</span>
    <span class="s0"># The following are methods that are called depending on the type of a</span>
    <span class="s0"># member. The entry point is _proc_member() which can be overridden in a</span>
    <span class="s0"># subclass to add custom _proc_*() methods. A _proc_*() method MUST</span>
    <span class="s0"># implement the following</span>
    <span class="s0"># operations:</span>
    <span class="s0"># 1. Set self.offset_data to the position where the data blocks begin,</span>
    <span class="s0">#    if there is data that follows.</span>
    <span class="s0"># 2. Set tarfile.offset to the position where the next member's header will</span>
    <span class="s0">#    begin.</span>
    <span class="s0"># 3. Return self or another valid TarInfo object.</span>
    <span class="s2">def </span><span class="s1">_proc_member(self</span><span class="s2">, </span><span class="s1">tarfile):</span>
        <span class="s6">&quot;&quot;&quot;Choose the right processing method depending on 
           the type and call it. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.type </span><span class="s2">in </span><span class="s1">(GNUTYPE_LONGNAME</span><span class="s2">, </span><span class="s1">GNUTYPE_LONGLINK):</span>
            <span class="s2">return </span><span class="s1">self._proc_gnulong(tarfile)</span>
        <span class="s2">elif </span><span class="s1">self.type == GNUTYPE_SPARSE:</span>
            <span class="s2">return </span><span class="s1">self._proc_sparse(tarfile)</span>
        <span class="s2">elif </span><span class="s1">self.type </span><span class="s2">in </span><span class="s1">(XHDTYPE</span><span class="s2">, </span><span class="s1">XGLTYPE</span><span class="s2">, </span><span class="s1">SOLARIS_XHDTYPE):</span>
            <span class="s2">return </span><span class="s1">self._proc_pax(tarfile)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._proc_builtin(tarfile)</span>

    <span class="s2">def </span><span class="s1">_proc_builtin(self</span><span class="s2">, </span><span class="s1">tarfile):</span>
        <span class="s6">&quot;&quot;&quot;Process a builtin type or an unknown type which 
           will be treated as a regular file. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.offset_data = tarfile.fileobj.tell()</span>
        <span class="s1">offset = self.offset_data</span>
        <span class="s2">if </span><span class="s1">self.isreg() </span><span class="s2">or </span><span class="s1">self.type </span><span class="s2">not in </span><span class="s1">SUPPORTED_TYPES:</span>
            <span class="s0"># Skip the following data blocks.</span>
            <span class="s1">offset += self._block(self.size)</span>
        <span class="s1">tarfile.offset = offset</span>

        <span class="s0"># Patch the TarInfo object with saved global</span>
        <span class="s0"># header information.</span>
        <span class="s1">self._apply_pax_info(tarfile.pax_headers</span><span class="s2">, </span><span class="s1">tarfile.encoding</span><span class="s2">, </span><span class="s1">tarfile.errors)</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_proc_gnulong(self</span><span class="s2">, </span><span class="s1">tarfile):</span>
        <span class="s6">&quot;&quot;&quot;Process the blocks that hold a GNU longname 
           or longlink member. 
        &quot;&quot;&quot;</span>
        <span class="s1">buf = tarfile.fileobj.read(self._block(self.size))</span>

        <span class="s0"># Fetch the next header and process it.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">next = self.fromtarfile(tarfile)</span>
        <span class="s2">except </span><span class="s1">HeaderError:</span>
            <span class="s2">raise </span><span class="s1">SubsequentHeaderError(</span><span class="s3">&quot;missing or bad subsequent header&quot;</span><span class="s1">)</span>

        <span class="s0"># Patch the TarInfo object from the next header with</span>
        <span class="s0"># the longname information.</span>
        <span class="s1">next.offset = self.offset</span>
        <span class="s2">if </span><span class="s1">self.type == GNUTYPE_LONGNAME:</span>
            <span class="s1">next.name = nts(buf</span><span class="s2">, </span><span class="s1">tarfile.encoding</span><span class="s2">, </span><span class="s1">tarfile.errors)</span>
        <span class="s2">elif </span><span class="s1">self.type == GNUTYPE_LONGLINK:</span>
            <span class="s1">next.linkname = nts(buf</span><span class="s2">, </span><span class="s1">tarfile.encoding</span><span class="s2">, </span><span class="s1">tarfile.errors)</span>

        <span class="s2">return </span><span class="s1">next</span>

    <span class="s2">def </span><span class="s1">_proc_sparse(self</span><span class="s2">, </span><span class="s1">tarfile):</span>
        <span class="s6">&quot;&quot;&quot;Process a GNU sparse header plus extra headers. 
        &quot;&quot;&quot;</span>
        <span class="s0"># We already collected some sparse structures in frombuf().</span>
        <span class="s1">structs</span><span class="s2">, </span><span class="s1">isextended</span><span class="s2">, </span><span class="s1">origsize = self._sparse_structs</span>
        <span class="s2">del </span><span class="s1">self._sparse_structs</span>

        <span class="s0"># Collect sparse structures from extended header blocks.</span>
        <span class="s2">while </span><span class="s1">isextended:</span>
            <span class="s1">buf = tarfile.fileobj.read(BLOCKSIZE)</span>
            <span class="s1">pos = </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">21</span><span class="s1">):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">offset = nti(buf[pos:pos + </span><span class="s4">12</span><span class="s1">])</span>
                    <span class="s1">numbytes = nti(buf[pos + </span><span class="s4">12</span><span class="s1">:pos + </span><span class="s4">24</span><span class="s1">])</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s2">break</span>
                <span class="s2">if </span><span class="s1">offset </span><span class="s2">and </span><span class="s1">numbytes:</span>
                    <span class="s1">structs.append((offset</span><span class="s2">, </span><span class="s1">numbytes))</span>
                <span class="s1">pos += </span><span class="s4">24</span>
            <span class="s1">isextended = bool(buf[</span><span class="s4">504</span><span class="s1">])</span>
        <span class="s1">self.sparse = structs</span>

        <span class="s1">self.offset_data = tarfile.fileobj.tell()</span>
        <span class="s1">tarfile.offset = self.offset_data + self._block(self.size)</span>
        <span class="s1">self.size = origsize</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_proc_pax(self</span><span class="s2">, </span><span class="s1">tarfile):</span>
        <span class="s6">&quot;&quot;&quot;Process an extended or global header as described in 
           POSIX.1-2008. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Read the header information.</span>
        <span class="s1">buf = tarfile.fileobj.read(self._block(self.size))</span>

        <span class="s0"># A pax header stores supplemental information for either</span>
        <span class="s0"># the following file (extended) or all following files</span>
        <span class="s0"># (global).</span>
        <span class="s2">if </span><span class="s1">self.type == XGLTYPE:</span>
            <span class="s1">pax_headers = tarfile.pax_headers</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pax_headers = tarfile.pax_headers.copy()</span>

        <span class="s0"># Check if the pax header contains a hdrcharset field. This tells us</span>
        <span class="s0"># the encoding of the path, linkpath, uname and gname fields. Normally,</span>
        <span class="s0"># these fields are UTF-8 encoded but since POSIX.1-2008 tar</span>
        <span class="s0"># implementations are allowed to store them as raw binary strings if</span>
        <span class="s0"># the translation to UTF-8 fails.</span>
        <span class="s1">match = re.search(</span><span class="s5">br&quot;\d+ hdrcharset=([^\n]+)\n&quot;</span><span class="s2">, </span><span class="s1">buf)</span>
        <span class="s2">if </span><span class="s1">match </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">pax_headers[</span><span class="s3">&quot;hdrcharset&quot;</span><span class="s1">] = match.group(</span><span class="s4">1</span><span class="s1">).decode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">)</span>

        <span class="s0"># For the time being, we don't care about anything other than &quot;BINARY&quot;.</span>
        <span class="s0"># The only other value that is currently allowed by the standard is</span>
        <span class="s0"># &quot;ISO-IR 10646 2000 UTF-8&quot; in other words UTF-8.</span>
        <span class="s1">hdrcharset = pax_headers.get(</span><span class="s3">&quot;hdrcharset&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">hdrcharset == </span><span class="s3">&quot;BINARY&quot;</span><span class="s1">:</span>
            <span class="s1">encoding = tarfile.encoding</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">encoding = </span><span class="s3">&quot;utf8&quot;</span>

        <span class="s0"># Parse pax header information. A record looks like that:</span>
        <span class="s0"># &quot;%d %s=%s\n&quot; % (length, keyword, value). length is the size</span>
        <span class="s0"># of the complete record including the length field itself and</span>
        <span class="s0"># the newline. keyword and value are both UTF-8 encoded strings.</span>
        <span class="s1">regex = re.compile(</span><span class="s5">br&quot;(\d+) ([^=]+)=&quot;</span><span class="s1">)</span>
        <span class="s1">pos = </span><span class="s4">0</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">match = regex.match(buf</span><span class="s2">, </span><span class="s1">pos)</span>
            <span class="s2">if not </span><span class="s1">match:</span>
                <span class="s2">break</span>

            <span class="s1">length</span><span class="s2">, </span><span class="s1">keyword = match.groups()</span>
            <span class="s1">length = int(length)</span>
            <span class="s1">value = buf[match.end(</span><span class="s4">2</span><span class="s1">) + </span><span class="s4">1</span><span class="s1">:match.start(</span><span class="s4">1</span><span class="s1">) + length - </span><span class="s4">1</span><span class="s1">]</span>

            <span class="s0"># Normally, we could just use &quot;utf8&quot; as the encoding and &quot;strict&quot;</span>
            <span class="s0"># as the error handler, but we better not take the risk. For</span>
            <span class="s0"># example, GNU tar &lt;= 1.23 is known to store filenames it cannot</span>
            <span class="s0"># translate to UTF-8 as raw strings (unfortunately without a</span>
            <span class="s0"># hdrcharset=BINARY header).</span>
            <span class="s0"># We first try the strict standard encoding, and if that fails we</span>
            <span class="s0"># fall back on the user's encoding and error handler.</span>
            <span class="s1">keyword = self._decode_pax_field(keyword</span><span class="s2">, </span><span class="s3">&quot;utf8&quot;</span><span class="s2">, </span><span class="s3">&quot;utf8&quot;</span><span class="s2">,</span>
                    <span class="s1">tarfile.errors)</span>
            <span class="s2">if </span><span class="s1">keyword </span><span class="s2">in </span><span class="s1">PAX_NAME_FIELDS:</span>
                <span class="s1">value = self._decode_pax_field(value</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">tarfile.encoding</span><span class="s2">,</span>
                        <span class="s1">tarfile.errors)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">value = self._decode_pax_field(value</span><span class="s2">, </span><span class="s3">&quot;utf8&quot;</span><span class="s2">, </span><span class="s3">&quot;utf8&quot;</span><span class="s2">,</span>
                        <span class="s1">tarfile.errors)</span>

            <span class="s1">pax_headers[keyword] = value</span>
            <span class="s1">pos += length</span>

        <span class="s0"># Fetch the next header.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">next = self.fromtarfile(tarfile)</span>
        <span class="s2">except </span><span class="s1">HeaderError:</span>
            <span class="s2">raise </span><span class="s1">SubsequentHeaderError(</span><span class="s3">&quot;missing or bad subsequent header&quot;</span><span class="s1">)</span>

        <span class="s0"># Process GNU sparse information.</span>
        <span class="s2">if </span><span class="s3">&quot;GNU.sparse.map&quot; </span><span class="s2">in </span><span class="s1">pax_headers:</span>
            <span class="s0"># GNU extended sparse format version 0.1.</span>
            <span class="s1">self._proc_gnusparse_01(next</span><span class="s2">, </span><span class="s1">pax_headers)</span>

        <span class="s2">elif </span><span class="s3">&quot;GNU.sparse.size&quot; </span><span class="s2">in </span><span class="s1">pax_headers:</span>
            <span class="s0"># GNU extended sparse format version 0.0.</span>
            <span class="s1">self._proc_gnusparse_00(next</span><span class="s2">, </span><span class="s1">pax_headers</span><span class="s2">, </span><span class="s1">buf)</span>

        <span class="s2">elif </span><span class="s1">pax_headers.get(</span><span class="s3">&quot;GNU.sparse.major&quot;</span><span class="s1">) == </span><span class="s3">&quot;1&quot; </span><span class="s2">and </span><span class="s1">pax_headers.get(</span><span class="s3">&quot;GNU.sparse.minor&quot;</span><span class="s1">) == </span><span class="s3">&quot;0&quot;</span><span class="s1">:</span>
            <span class="s0"># GNU extended sparse format version 1.0.</span>
            <span class="s1">self._proc_gnusparse_10(next</span><span class="s2">, </span><span class="s1">pax_headers</span><span class="s2">, </span><span class="s1">tarfile)</span>

        <span class="s2">if </span><span class="s1">self.type </span><span class="s2">in </span><span class="s1">(XHDTYPE</span><span class="s2">, </span><span class="s1">SOLARIS_XHDTYPE):</span>
            <span class="s0"># Patch the TarInfo object with the extended header info.</span>
            <span class="s1">next._apply_pax_info(pax_headers</span><span class="s2">, </span><span class="s1">tarfile.encoding</span><span class="s2">, </span><span class="s1">tarfile.errors)</span>
            <span class="s1">next.offset = self.offset</span>

            <span class="s2">if </span><span class="s3">&quot;size&quot; </span><span class="s2">in </span><span class="s1">pax_headers:</span>
                <span class="s0"># If the extended header replaces the size field,</span>
                <span class="s0"># we need to recalculate the offset where the next</span>
                <span class="s0"># header starts.</span>
                <span class="s1">offset = next.offset_data</span>
                <span class="s2">if </span><span class="s1">next.isreg() </span><span class="s2">or </span><span class="s1">next.type </span><span class="s2">not in </span><span class="s1">SUPPORTED_TYPES:</span>
                    <span class="s1">offset += next._block(next.size)</span>
                <span class="s1">tarfile.offset = offset</span>

        <span class="s2">return </span><span class="s1">next</span>

    <span class="s2">def </span><span class="s1">_proc_gnusparse_00(self</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">pax_headers</span><span class="s2">, </span><span class="s1">buf):</span>
        <span class="s6">&quot;&quot;&quot;Process a GNU tar extended sparse header, version 0.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">offsets = []</span>
        <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">re.finditer(</span><span class="s5">br&quot;\d+ GNU.sparse.offset=(\d+)\n&quot;</span><span class="s2">, </span><span class="s1">buf):</span>
            <span class="s1">offsets.append(int(match.group(</span><span class="s4">1</span><span class="s1">)))</span>
        <span class="s1">numbytes = []</span>
        <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">re.finditer(</span><span class="s5">br&quot;\d+ GNU.sparse.numbytes=(\d+)\n&quot;</span><span class="s2">, </span><span class="s1">buf):</span>
            <span class="s1">numbytes.append(int(match.group(</span><span class="s4">1</span><span class="s1">)))</span>
        <span class="s1">next.sparse = list(zip(offsets</span><span class="s2">, </span><span class="s1">numbytes))</span>

    <span class="s2">def </span><span class="s1">_proc_gnusparse_01(self</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">pax_headers):</span>
        <span class="s6">&quot;&quot;&quot;Process a GNU tar extended sparse header, version 0.1. 
        &quot;&quot;&quot;</span>
        <span class="s1">sparse = [int(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">pax_headers[</span><span class="s3">&quot;GNU.sparse.map&quot;</span><span class="s1">].split(</span><span class="s3">&quot;,&quot;</span><span class="s1">)]</span>
        <span class="s1">next.sparse = list(zip(sparse[::</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sparse[</span><span class="s4">1</span><span class="s1">::</span><span class="s4">2</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">_proc_gnusparse_10(self</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">pax_headers</span><span class="s2">, </span><span class="s1">tarfile):</span>
        <span class="s6">&quot;&quot;&quot;Process a GNU tar extended sparse header, version 1.0. 
        &quot;&quot;&quot;</span>
        <span class="s1">fields = </span><span class="s2">None</span>
        <span class="s1">sparse = []</span>
        <span class="s1">buf = tarfile.fileobj.read(BLOCKSIZE)</span>
        <span class="s1">fields</span><span class="s2">, </span><span class="s1">buf = buf.split(</span><span class="s5">b&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">fields = int(fields)</span>
        <span class="s2">while </span><span class="s1">len(sparse) &lt; fields * </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s5">b&quot;</span><span class="s2">\n</span><span class="s5">&quot; </span><span class="s2">not in </span><span class="s1">buf:</span>
                <span class="s1">buf += tarfile.fileobj.read(BLOCKSIZE)</span>
            <span class="s1">number</span><span class="s2">, </span><span class="s1">buf = buf.split(</span><span class="s5">b&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">sparse.append(int(number))</span>
        <span class="s1">next.offset_data = tarfile.fileobj.tell()</span>
        <span class="s1">next.sparse = list(zip(sparse[::</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sparse[</span><span class="s4">1</span><span class="s1">::</span><span class="s4">2</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">_apply_pax_info(self</span><span class="s2">, </span><span class="s1">pax_headers</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors):</span>
        <span class="s6">&quot;&quot;&quot;Replace fields with supplemental information from a previous 
           pax extended or global header. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">keyword</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">pax_headers.items():</span>
            <span class="s2">if </span><span class="s1">keyword == </span><span class="s3">&quot;GNU.sparse.name&quot;</span><span class="s1">:</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s3">&quot;path&quot;</span><span class="s2">, </span><span class="s1">value)</span>
            <span class="s2">elif </span><span class="s1">keyword == </span><span class="s3">&quot;GNU.sparse.size&quot;</span><span class="s1">:</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s3">&quot;size&quot;</span><span class="s2">, </span><span class="s1">int(value))</span>
            <span class="s2">elif </span><span class="s1">keyword == </span><span class="s3">&quot;GNU.sparse.realsize&quot;</span><span class="s1">:</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s3">&quot;size&quot;</span><span class="s2">, </span><span class="s1">int(value))</span>
            <span class="s2">elif </span><span class="s1">keyword </span><span class="s2">in </span><span class="s1">PAX_FIELDS:</span>
                <span class="s2">if </span><span class="s1">keyword </span><span class="s2">in </span><span class="s1">PAX_NUMBER_FIELDS:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">value = PAX_NUMBER_FIELDS[keyword](value)</span>
                    <span class="s2">except </span><span class="s1">ValueError:</span>
                        <span class="s1">value = </span><span class="s4">0</span>
                <span class="s2">if </span><span class="s1">keyword == </span><span class="s3">&quot;path&quot;</span><span class="s1">:</span>
                    <span class="s1">value = value.rstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">keyword</span><span class="s2">, </span><span class="s1">value)</span>

        <span class="s1">self.pax_headers = pax_headers.copy()</span>

    <span class="s2">def </span><span class="s1">_decode_pax_field(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">fallback_encoding</span><span class="s2">, </span><span class="s1">fallback_errors):</span>
        <span class="s6">&quot;&quot;&quot;Decode a single field from a pax record. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">value.decode(encoding</span><span class="s2">, </span><span class="s3">&quot;strict&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">UnicodeDecodeError:</span>
            <span class="s2">return </span><span class="s1">value.decode(fallback_encoding</span><span class="s2">, </span><span class="s1">fallback_errors)</span>

    <span class="s2">def </span><span class="s1">_block(self</span><span class="s2">, </span><span class="s1">count):</span>
        <span class="s6">&quot;&quot;&quot;Round up a byte count by BLOCKSIZE and return it, 
           e.g. _block(834) =&gt; 1024. 
        &quot;&quot;&quot;</span>
        <span class="s1">blocks</span><span class="s2">, </span><span class="s1">remainder = divmod(count</span><span class="s2">, </span><span class="s1">BLOCKSIZE)</span>
        <span class="s2">if </span><span class="s1">remainder:</span>
            <span class="s1">blocks += </span><span class="s4">1</span>
        <span class="s2">return </span><span class="s1">blocks * BLOCKSIZE</span>

    <span class="s2">def </span><span class="s1">isreg(self):</span>
        <span class="s2">return </span><span class="s1">self.type </span><span class="s2">in </span><span class="s1">REGULAR_TYPES</span>
    <span class="s2">def </span><span class="s1">isfile(self):</span>
        <span class="s2">return </span><span class="s1">self.isreg()</span>
    <span class="s2">def </span><span class="s1">isdir(self):</span>
        <span class="s2">return </span><span class="s1">self.type == DIRTYPE</span>
    <span class="s2">def </span><span class="s1">issym(self):</span>
        <span class="s2">return </span><span class="s1">self.type == SYMTYPE</span>
    <span class="s2">def </span><span class="s1">islnk(self):</span>
        <span class="s2">return </span><span class="s1">self.type == LNKTYPE</span>
    <span class="s2">def </span><span class="s1">ischr(self):</span>
        <span class="s2">return </span><span class="s1">self.type == CHRTYPE</span>
    <span class="s2">def </span><span class="s1">isblk(self):</span>
        <span class="s2">return </span><span class="s1">self.type == BLKTYPE</span>
    <span class="s2">def </span><span class="s1">isfifo(self):</span>
        <span class="s2">return </span><span class="s1">self.type == FIFOTYPE</span>
    <span class="s2">def </span><span class="s1">issparse(self):</span>
        <span class="s2">return </span><span class="s1">self.sparse </span><span class="s2">is not None</span>
    <span class="s2">def </span><span class="s1">isdev(self):</span>
        <span class="s2">return </span><span class="s1">self.type </span><span class="s2">in </span><span class="s1">(CHRTYPE</span><span class="s2">, </span><span class="s1">BLKTYPE</span><span class="s2">, </span><span class="s1">FIFOTYPE)</span>
<span class="s0"># class TarInfo</span>

<span class="s2">class </span><span class="s1">TarFile(object):</span>
    <span class="s6">&quot;&quot;&quot;The TarFile Class provides an interface to tar archives. 
    &quot;&quot;&quot;</span>

    <span class="s1">debug = </span><span class="s4">0                   </span><span class="s0"># May be set from 0 (no msgs) to 3 (all msgs)</span>

    <span class="s1">dereference = </span><span class="s2">False         </span><span class="s0"># If true, add content of linked file to the</span>
                                <span class="s0"># tar file, else the link.</span>

    <span class="s1">ignore_zeros = </span><span class="s2">False        </span><span class="s0"># If true, skips empty or invalid blocks and</span>
                                <span class="s0"># continues processing.</span>

    <span class="s1">errorlevel = </span><span class="s4">1              </span><span class="s0"># If 0, fatal errors only appear in debug</span>
                                <span class="s0"># messages (if debug &gt;= 0). If &gt; 0, errors</span>
                                <span class="s0"># are passed to the caller as exceptions.</span>

    <span class="s1">format = DEFAULT_FORMAT     </span><span class="s0"># The format to use when creating an archive.</span>

    <span class="s1">encoding = ENCODING         </span><span class="s0"># Encoding for 8-bit character strings.</span>

    <span class="s1">errors = </span><span class="s2">None               </span><span class="s0"># Error handler for unicode conversion.</span>

    <span class="s1">tarinfo = TarInfo           </span><span class="s0"># The default TarInfo class to use.</span>

    <span class="s1">fileobject = ExFileObject   </span><span class="s0"># The default ExFileObject class to use.</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None, </span><span class="s1">mode=</span><span class="s3">&quot;r&quot;</span><span class="s2">, </span><span class="s1">fileobj=</span><span class="s2">None, </span><span class="s1">format=</span><span class="s2">None,</span>
            <span class="s1">tarinfo=</span><span class="s2">None, </span><span class="s1">dereference=</span><span class="s2">None, </span><span class="s1">ignore_zeros=</span><span class="s2">None, </span><span class="s1">encoding=</span><span class="s2">None,</span>
            <span class="s1">errors=</span><span class="s3">&quot;surrogateescape&quot;</span><span class="s2">, </span><span class="s1">pax_headers=</span><span class="s2">None, </span><span class="s1">debug=</span><span class="s2">None, </span><span class="s1">errorlevel=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Open an (uncompressed) tar archive `name'. `mode' is either 'r' to 
           read from an existing archive, 'a' to append data to an existing 
           file or 'w' to create a new file overwriting an existing one. `mode' 
           defaults to 'r'. 
           If `fileobj' is given, it is used for reading or writing data. If it 
           can be determined, `mode' is overridden by `fileobj's mode. 
           `fileobj' is not closed, when TarFile is closed. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(mode) &gt; </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">mode </span><span class="s2">not in </span><span class="s3">&quot;raw&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;mode must be 'r', 'a' or 'w'&quot;</span><span class="s1">)</span>
        <span class="s1">self.mode = mode</span>
        <span class="s1">self._mode = {</span><span class="s3">&quot;r&quot;</span><span class="s1">: </span><span class="s3">&quot;rb&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s1">: </span><span class="s3">&quot;r+b&quot;</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">: </span><span class="s3">&quot;wb&quot;</span><span class="s1">}[mode]</span>

        <span class="s2">if not </span><span class="s1">fileobj:</span>
            <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;a&quot; </span><span class="s2">and not </span><span class="s1">os.path.exists(name):</span>
                <span class="s0"># Create nonexistent files in append mode.</span>
                <span class="s1">self.mode = </span><span class="s3">&quot;w&quot;</span>
                <span class="s1">self._mode = </span><span class="s3">&quot;wb&quot;</span>
            <span class="s1">fileobj = bltn_open(name</span><span class="s2">, </span><span class="s1">self._mode)</span>
            <span class="s1">self._extfileobj = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">is None and </span><span class="s1">hasattr(fileobj</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s1">):</span>
                <span class="s1">name = fileobj.name</span>
            <span class="s2">if </span><span class="s1">hasattr(fileobj</span><span class="s2">, </span><span class="s3">&quot;mode&quot;</span><span class="s1">):</span>
                <span class="s1">self._mode = fileobj.mode</span>
            <span class="s1">self._extfileobj = </span><span class="s2">True</span>
        <span class="s1">self.name = os.path.abspath(name) </span><span class="s2">if </span><span class="s1">name </span><span class="s2">else None</span>
        <span class="s1">self.fileobj = fileobj</span>

        <span class="s0"># Init attributes.</span>
        <span class="s2">if </span><span class="s1">format </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.format = format</span>
        <span class="s2">if </span><span class="s1">tarinfo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.tarinfo = tarinfo</span>
        <span class="s2">if </span><span class="s1">dereference </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.dereference = dereference</span>
        <span class="s2">if </span><span class="s1">ignore_zeros </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.ignore_zeros = ignore_zeros</span>
        <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.encoding = encoding</span>
        <span class="s1">self.errors = errors</span>

        <span class="s2">if </span><span class="s1">pax_headers </span><span class="s2">is not None and </span><span class="s1">self.format == PAX_FORMAT:</span>
            <span class="s1">self.pax_headers = pax_headers</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.pax_headers = {}</span>

        <span class="s2">if </span><span class="s1">debug </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.debug = debug</span>
        <span class="s2">if </span><span class="s1">errorlevel </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.errorlevel = errorlevel</span>

        <span class="s0"># Init datastructures.</span>
        <span class="s1">self.closed = </span><span class="s2">False</span>
        <span class="s1">self.members = []       </span><span class="s0"># list of members as TarInfo objects</span>
        <span class="s1">self._loaded = </span><span class="s2">False    </span><span class="s0"># flag if all members have been read</span>
        <span class="s1">self.offset = self.fileobj.tell()</span>
                                <span class="s0"># current position in the archive file</span>
        <span class="s1">self.inodes = {}        </span><span class="s0"># dictionary caching the inodes of</span>
                                <span class="s0"># archive members already added</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;r&quot;</span><span class="s1">:</span>
                <span class="s1">self.firstmember = </span><span class="s2">None</span>
                <span class="s1">self.firstmember = self.next()</span>

            <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;a&quot;</span><span class="s1">:</span>
                <span class="s0"># Move to the end of the archive,</span>
                <span class="s0"># before the first empty block.</span>
                <span class="s2">while True</span><span class="s1">:</span>
                    <span class="s1">self.fileobj.seek(self.offset)</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">tarinfo = self.tarinfo.fromtarfile(self)</span>
                        <span class="s1">self.members.append(tarinfo)</span>
                    <span class="s2">except </span><span class="s1">EOFHeaderError:</span>
                        <span class="s1">self.fileobj.seek(self.offset)</span>
                        <span class="s2">break</span>
                    <span class="s2">except </span><span class="s1">HeaderError </span><span class="s2">as </span><span class="s1">e:</span>
                        <span class="s2">raise </span><span class="s1">ReadError(str(e))</span>

            <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s3">&quot;aw&quot;</span><span class="s1">:</span>
                <span class="s1">self._loaded = </span><span class="s2">True</span>

                <span class="s2">if </span><span class="s1">self.pax_headers:</span>
                    <span class="s1">buf = self.tarinfo.create_pax_global_header(self.pax_headers.copy())</span>
                    <span class="s1">self.fileobj.write(buf)</span>
                    <span class="s1">self.offset += len(buf)</span>
        <span class="s2">except</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">self._extfileobj:</span>
                <span class="s1">self.fileobj.close()</span>
            <span class="s1">self.closed = </span><span class="s2">True</span>
            <span class="s2">raise</span>

    <span class="s0">#--------------------------------------------------------------------------</span>
    <span class="s0"># Below are the classmethods which act as alternate constructors to the</span>
    <span class="s0"># TarFile class. The open() method is the only one that is needed for</span>
    <span class="s0"># public use; it is the &quot;super&quot;-constructor and is able to select an</span>
    <span class="s0"># adequate &quot;sub&quot;-constructor for a particular compression using the mapping</span>
    <span class="s0"># from OPEN_METH.</span>
    <span class="s0">#</span>
    <span class="s0"># This concept allows one to subclass TarFile without losing the comfort of</span>
    <span class="s0"># the super-constructor. A sub-constructor is registered and made available</span>
    <span class="s0"># by adding it to the mapping in OPEN_METH.</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">open(cls</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None, </span><span class="s1">mode=</span><span class="s3">&quot;r&quot;</span><span class="s2">, </span><span class="s1">fileobj=</span><span class="s2">None, </span><span class="s1">bufsize=RECORDSIZE</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s6">&quot;&quot;&quot;Open a tar archive for reading, writing or appending. Return 
           an appropriate TarFile class. 
 
           mode: 
           'r' or 'r:*' open for reading with transparent compression 
           'r:'         open for reading exclusively uncompressed 
           'r:gz'       open for reading with gzip compression 
           'r:bz2'      open for reading with bzip2 compression 
           'a' or 'a:'  open for appending, creating the file if necessary 
           'w' or 'w:'  open for writing without compression 
           'w:gz'       open for writing with gzip compression 
           'w:bz2'      open for writing with bzip2 compression 
 
           'r|*'        open a stream of tar blocks with transparent compression 
           'r|'         open an uncompressed stream of tar blocks for reading 
           'r|gz'       open a gzip compressed stream of tar blocks 
           'r|bz2'      open a bzip2 compressed stream of tar blocks 
           'w|'         open an uncompressed stream for writing 
           'w|gz'       open a gzip compressed stream for writing 
           'w|bz2'      open a bzip2 compressed stream for writing 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">name </span><span class="s2">and not </span><span class="s1">fileobj:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;nothing to open&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;r&quot;</span><span class="s2">, </span><span class="s3">&quot;r:*&quot;</span><span class="s1">):</span>
            <span class="s0"># Find out which *open() is appropriate for opening the file.</span>
            <span class="s2">for </span><span class="s1">comptype </span><span class="s2">in </span><span class="s1">cls.OPEN_METH:</span>
                <span class="s1">func = getattr(cls</span><span class="s2">, </span><span class="s1">cls.OPEN_METH[comptype])</span>
                <span class="s2">if </span><span class="s1">fileobj </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">saved_pos = fileobj.tell()</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">func(name</span><span class="s2">, </span><span class="s3">&quot;r&quot;</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">**kwargs)</span>
                <span class="s2">except </span><span class="s1">(ReadError</span><span class="s2">, </span><span class="s1">CompressionError) </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s2">if </span><span class="s1">fileobj </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">fileobj.seek(saved_pos)</span>
                    <span class="s2">continue</span>
            <span class="s2">raise </span><span class="s1">ReadError(</span><span class="s3">&quot;file could not be opened successfully&quot;</span><span class="s1">)</span>

        <span class="s2">elif </span><span class="s3">&quot;:&quot; </span><span class="s2">in </span><span class="s1">mode:</span>
            <span class="s1">filemode</span><span class="s2">, </span><span class="s1">comptype = mode.split(</span><span class="s3">&quot;:&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">filemode = filemode </span><span class="s2">or </span><span class="s3">&quot;r&quot;</span>
            <span class="s1">comptype = comptype </span><span class="s2">or </span><span class="s3">&quot;tar&quot;</span>

            <span class="s0"># Select the *open() function according to</span>
            <span class="s0"># given compression.</span>
            <span class="s2">if </span><span class="s1">comptype </span><span class="s2">in </span><span class="s1">cls.OPEN_METH:</span>
                <span class="s1">func = getattr(cls</span><span class="s2">, </span><span class="s1">cls.OPEN_METH[comptype])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">CompressionError(</span><span class="s3">&quot;unknown compression type %r&quot; </span><span class="s1">% comptype)</span>
            <span class="s2">return </span><span class="s1">func(name</span><span class="s2">, </span><span class="s1">filemode</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s2">elif </span><span class="s3">&quot;|&quot; </span><span class="s2">in </span><span class="s1">mode:</span>
            <span class="s1">filemode</span><span class="s2">, </span><span class="s1">comptype = mode.split(</span><span class="s3">&quot;|&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">filemode = filemode </span><span class="s2">or </span><span class="s3">&quot;r&quot;</span>
            <span class="s1">comptype = comptype </span><span class="s2">or </span><span class="s3">&quot;tar&quot;</span>

            <span class="s2">if </span><span class="s1">filemode </span><span class="s2">not in </span><span class="s3">&quot;rw&quot;</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;mode must be 'r' or 'w'&quot;</span><span class="s1">)</span>

            <span class="s1">stream = _Stream(name</span><span class="s2">, </span><span class="s1">filemode</span><span class="s2">, </span><span class="s1">comptype</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">bufsize)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">t = cls(name</span><span class="s2">, </span><span class="s1">filemode</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">except</span><span class="s1">:</span>
                <span class="s1">stream.close()</span>
                <span class="s2">raise</span>
            <span class="s1">t._extfileobj = </span><span class="s2">False</span>
            <span class="s2">return </span><span class="s1">t</span>

        <span class="s2">elif </span><span class="s1">mode </span><span class="s2">in </span><span class="s3">&quot;aw&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">cls.taropen(name</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;undiscernible mode&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">taropen(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;r&quot;</span><span class="s2">, </span><span class="s1">fileobj=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s6">&quot;&quot;&quot;Open uncompressed tar archive name for reading or writing. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(mode) &gt; </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">mode </span><span class="s2">not in </span><span class="s3">&quot;raw&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;mode must be 'r', 'a' or 'w'&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">cls(name</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">gzopen(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;r&quot;</span><span class="s2">, </span><span class="s1">fileobj=</span><span class="s2">None, </span><span class="s1">compresslevel=</span><span class="s4">9</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s6">&quot;&quot;&quot;Open gzip compressed tar archive name for reading or writing. 
           Appending is not allowed. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(mode) &gt; </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">mode </span><span class="s2">not in </span><span class="s3">&quot;rw&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;mode must be 'r' or 'w'&quot;</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">gzip</span>
            <span class="s1">gzip.GzipFile</span>
        <span class="s2">except </span><span class="s1">(ImportError</span><span class="s2">, </span><span class="s1">AttributeError):</span>
            <span class="s2">raise </span><span class="s1">CompressionError(</span><span class="s3">&quot;gzip module is not available&quot;</span><span class="s1">)</span>

        <span class="s1">extfileobj = fileobj </span><span class="s2">is not None</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">fileobj = gzip.GzipFile(name</span><span class="s2">, </span><span class="s1">mode + </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">compresslevel</span><span class="s2">, </span><span class="s1">fileobj)</span>
            <span class="s1">t = cls.taropen(name</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">except </span><span class="s1">IOError:</span>
            <span class="s2">if not </span><span class="s1">extfileobj </span><span class="s2">and </span><span class="s1">fileobj </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">fileobj.close()</span>
            <span class="s2">if </span><span class="s1">fileobj </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise</span>
            <span class="s2">raise </span><span class="s1">ReadError(</span><span class="s3">&quot;not a gzip file&quot;</span><span class="s1">)</span>
        <span class="s2">except</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">extfileobj </span><span class="s2">and </span><span class="s1">fileobj </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">fileobj.close()</span>
            <span class="s2">raise</span>
        <span class="s1">t._extfileobj = extfileobj</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">bz2open(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;r&quot;</span><span class="s2">, </span><span class="s1">fileobj=</span><span class="s2">None, </span><span class="s1">compresslevel=</span><span class="s4">9</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s6">&quot;&quot;&quot;Open bzip2 compressed tar archive name for reading or writing. 
           Appending is not allowed. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(mode) &gt; </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">mode </span><span class="s2">not in </span><span class="s3">&quot;rw&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;mode must be 'r' or 'w'.&quot;</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">bz2</span>
        <span class="s2">except </span><span class="s1">ImportError:</span>
            <span class="s2">raise </span><span class="s1">CompressionError(</span><span class="s3">&quot;bz2 module is not available&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">fileobj </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">fileobj = _BZ2Proxy(fileobj</span><span class="s2">, </span><span class="s1">mode)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fileobj = bz2.BZ2File(name</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">compresslevel=compresslevel)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">t = cls.taropen(name</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">except </span><span class="s1">(IOError</span><span class="s2">, </span><span class="s1">EOFError):</span>
            <span class="s1">fileobj.close()</span>
            <span class="s2">raise </span><span class="s1">ReadError(</span><span class="s3">&quot;not a bzip2 file&quot;</span><span class="s1">)</span>
        <span class="s1">t._extfileobj = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s0"># All *open() methods are registered here.</span>
    <span class="s1">OPEN_METH = {</span>
        <span class="s3">&quot;tar&quot;</span><span class="s1">: </span><span class="s3">&quot;taropen&quot;</span><span class="s2">,   </span><span class="s0"># uncompressed tar</span>
        <span class="s3">&quot;gz&quot;</span><span class="s1">:  </span><span class="s3">&quot;gzopen&quot;</span><span class="s2">,    </span><span class="s0"># gzip compressed tar</span>
        <span class="s3">&quot;bz2&quot;</span><span class="s1">: </span><span class="s3">&quot;bz2open&quot;    </span><span class="s0"># bzip2 compressed tar</span>
    <span class="s1">}</span>

    <span class="s0">#--------------------------------------------------------------------------</span>
    <span class="s0"># The public methods which TarFile provides:</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s6">&quot;&quot;&quot;Close the TarFile. In write-mode, two finishing zero blocks are 
           appended to the archive. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.closed:</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s3">&quot;aw&quot;</span><span class="s1">:</span>
            <span class="s1">self.fileobj.write(NUL * (BLOCKSIZE * </span><span class="s4">2</span><span class="s1">))</span>
            <span class="s1">self.offset += (BLOCKSIZE * </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s0"># fill up the end with zero-blocks</span>
            <span class="s0"># (like option -b20 for tar does)</span>
            <span class="s1">blocks</span><span class="s2">, </span><span class="s1">remainder = divmod(self.offset</span><span class="s2">, </span><span class="s1">RECORDSIZE)</span>
            <span class="s2">if </span><span class="s1">remainder &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self.fileobj.write(NUL * (RECORDSIZE - remainder))</span>

        <span class="s2">if not </span><span class="s1">self._extfileobj:</span>
            <span class="s1">self.fileobj.close()</span>
        <span class="s1">self.closed = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">getmember(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s6">&quot;&quot;&quot;Return a TarInfo object for member `name'. If `name' can not be 
           found in the archive, KeyError is raised. If a member occurs more 
           than once in the archive, its last occurrence is assumed to be the 
           most up-to-date version. 
        &quot;&quot;&quot;</span>
        <span class="s1">tarinfo = self._getmember(name)</span>
        <span class="s2">if </span><span class="s1">tarinfo </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">KeyError(</span><span class="s3">&quot;filename %r not found&quot; </span><span class="s1">% name)</span>
        <span class="s2">return </span><span class="s1">tarinfo</span>

    <span class="s2">def </span><span class="s1">getmembers(self):</span>
        <span class="s6">&quot;&quot;&quot;Return the members of the archive as a list of TarInfo objects. The 
           list has the same order as the members in the archive. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._check()</span>
        <span class="s2">if not </span><span class="s1">self._loaded:    </span><span class="s0"># if we want to obtain a list of</span>
            <span class="s1">self._load()        </span><span class="s0"># all members, we first have to</span>
                                <span class="s0"># scan the whole archive.</span>
        <span class="s2">return </span><span class="s1">self.members</span>

    <span class="s2">def </span><span class="s1">getnames(self):</span>
        <span class="s6">&quot;&quot;&quot;Return the members of the archive as a list of their names. It has 
           the same order as the list returned by getmembers(). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[tarinfo.name </span><span class="s2">for </span><span class="s1">tarinfo </span><span class="s2">in </span><span class="s1">self.getmembers()]</span>

    <span class="s2">def </span><span class="s1">gettarinfo(self</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None, </span><span class="s1">arcname=</span><span class="s2">None, </span><span class="s1">fileobj=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Create a TarInfo object for either the file `name' or the file 
           object `fileobj' (using os.fstat on its file descriptor). You can 
           modify some of the TarInfo's attributes before you add it using 
           addfile(). If given, `arcname' specifies an alternative name for the 
           file in the archive. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._check(</span><span class="s3">&quot;aw&quot;</span><span class="s1">)</span>

        <span class="s0"># When fileobj is given, replace name by</span>
        <span class="s0"># fileobj's real name.</span>
        <span class="s2">if </span><span class="s1">fileobj </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">name = fileobj.name</span>

        <span class="s0"># Building the name of the member in the archive.</span>
        <span class="s0"># Backward slashes are converted to forward slashes,</span>
        <span class="s0"># Absolute paths are turned to relative paths.</span>
        <span class="s2">if </span><span class="s1">arcname </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">arcname = name</span>
        <span class="s1">drv</span><span class="s2">, </span><span class="s1">arcname = os.path.splitdrive(arcname)</span>
        <span class="s1">arcname = arcname.replace(os.sep</span><span class="s2">, </span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s1">arcname = arcname.lstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>

        <span class="s0"># Now, fill the TarInfo object with</span>
        <span class="s0"># information specific for the file.</span>
        <span class="s1">tarinfo = self.tarinfo()</span>
        <span class="s1">tarinfo.tarfile = self</span>

        <span class="s0"># Use os.stat or os.lstat, depending on platform</span>
        <span class="s0"># and if symlinks shall be resolved.</span>
        <span class="s2">if </span><span class="s1">fileobj </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">&quot;lstat&quot;</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">self.dereference:</span>
                <span class="s1">statres = os.lstat(name)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">statres = os.stat(name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">statres = os.fstat(fileobj.fileno())</span>
        <span class="s1">linkname = </span><span class="s3">&quot;&quot;</span>

        <span class="s1">stmd = statres.st_mode</span>
        <span class="s2">if </span><span class="s1">stat.S_ISREG(stmd):</span>
            <span class="s1">inode = (statres.st_ino</span><span class="s2">, </span><span class="s1">statres.st_dev)</span>
            <span class="s2">if not </span><span class="s1">self.dereference </span><span class="s2">and </span><span class="s1">statres.st_nlink &gt; </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">\</span>
                    <span class="s1">inode </span><span class="s2">in </span><span class="s1">self.inodes </span><span class="s2">and </span><span class="s1">arcname != self.inodes[inode]:</span>
                <span class="s0"># Is it a hardlink to an already</span>
                <span class="s0"># archived file?</span>
                <span class="s1">type = LNKTYPE</span>
                <span class="s1">linkname = self.inodes[inode]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># The inode is added only if its valid.</span>
                <span class="s0"># For win32 it is always 0.</span>
                <span class="s1">type = REGTYPE</span>
                <span class="s2">if </span><span class="s1">inode[</span><span class="s4">0</span><span class="s1">]:</span>
                    <span class="s1">self.inodes[inode] = arcname</span>
        <span class="s2">elif </span><span class="s1">stat.S_ISDIR(stmd):</span>
            <span class="s1">type = DIRTYPE</span>
        <span class="s2">elif </span><span class="s1">stat.S_ISFIFO(stmd):</span>
            <span class="s1">type = FIFOTYPE</span>
        <span class="s2">elif </span><span class="s1">stat.S_ISLNK(stmd):</span>
            <span class="s1">type = SYMTYPE</span>
            <span class="s1">linkname = os.readlink(name)</span>
        <span class="s2">elif </span><span class="s1">stat.S_ISCHR(stmd):</span>
            <span class="s1">type = CHRTYPE</span>
        <span class="s2">elif </span><span class="s1">stat.S_ISBLK(stmd):</span>
            <span class="s1">type = BLKTYPE</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

        <span class="s0"># Fill the TarInfo object with all</span>
        <span class="s0"># information we can get.</span>
        <span class="s1">tarinfo.name = arcname</span>
        <span class="s1">tarinfo.mode = stmd</span>
        <span class="s1">tarinfo.uid = statres.st_uid</span>
        <span class="s1">tarinfo.gid = statres.st_gid</span>
        <span class="s2">if </span><span class="s1">type == REGTYPE:</span>
            <span class="s1">tarinfo.size = statres.st_size</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tarinfo.size = </span><span class="s4">0</span>
        <span class="s1">tarinfo.mtime = statres.st_mtime</span>
        <span class="s1">tarinfo.type = type</span>
        <span class="s1">tarinfo.linkname = linkname</span>
        <span class="s2">if </span><span class="s1">pwd:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">tarinfo.uname = pwd.getpwuid(tarinfo.uid)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s2">pass</span>
        <span class="s2">if </span><span class="s1">grp:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">tarinfo.gname = grp.getgrgid(tarinfo.gid)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s2">pass</span>

        <span class="s2">if </span><span class="s1">type </span><span class="s2">in </span><span class="s1">(CHRTYPE</span><span class="s2">, </span><span class="s1">BLKTYPE):</span>
            <span class="s2">if </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">&quot;major&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">&quot;minor&quot;</span><span class="s1">):</span>
                <span class="s1">tarinfo.devmajor = os.major(statres.st_rdev)</span>
                <span class="s1">tarinfo.devminor = os.minor(statres.st_rdev)</span>
        <span class="s2">return </span><span class="s1">tarinfo</span>

    <span class="s2">def </span><span class="s1">list(self</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Print a table of contents to sys.stdout. If `verbose' is False, only 
           the names of the members are printed. If it is True, an `ls -l'-like 
           output is produced. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._check()</span>

        <span class="s2">for </span><span class="s1">tarinfo </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">verbose:</span>
                <span class="s1">print(filemode(tarinfo.mode)</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">' '</span><span class="s1">)</span>
                <span class="s1">print(</span><span class="s3">&quot;%s/%s&quot; </span><span class="s1">% (tarinfo.uname </span><span class="s2">or </span><span class="s1">tarinfo.uid</span><span class="s2">,</span>
                                 <span class="s1">tarinfo.gname </span><span class="s2">or </span><span class="s1">tarinfo.gid)</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">' '</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">tarinfo.ischr() </span><span class="s2">or </span><span class="s1">tarinfo.isblk():</span>
                    <span class="s1">print(</span><span class="s3">&quot;%10s&quot; </span><span class="s1">% (</span><span class="s3">&quot;%d,%d&quot; </span><span class="s1">\</span>
                                    <span class="s1">% (tarinfo.devmajor</span><span class="s2">, </span><span class="s1">tarinfo.devminor))</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">' '</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">print(</span><span class="s3">&quot;%10d&quot; </span><span class="s1">% tarinfo.size</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">' '</span><span class="s1">)</span>
                <span class="s1">print(</span><span class="s3">&quot;%d-%02d-%02d %02d:%02d:%02d&quot; </span><span class="s1">\</span>
                      <span class="s1">% time.localtime(tarinfo.mtime)[:</span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">' '</span><span class="s1">)</span>

            <span class="s1">print(tarinfo.name + (</span><span class="s3">&quot;/&quot; </span><span class="s2">if </span><span class="s1">tarinfo.isdir() </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">' '</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">verbose:</span>
                <span class="s2">if </span><span class="s1">tarinfo.issym():</span>
                    <span class="s1">print(</span><span class="s3">&quot;-&gt;&quot;</span><span class="s2">, </span><span class="s1">tarinfo.linkname</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">' '</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">tarinfo.islnk():</span>
                    <span class="s1">print(</span><span class="s3">&quot;link to&quot;</span><span class="s2">, </span><span class="s1">tarinfo.linkname</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">' '</span><span class="s1">)</span>
            <span class="s1">print()</span>

    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">arcname=</span><span class="s2">None, </span><span class="s1">recursive=</span><span class="s2">True, </span><span class="s1">exclude=</span><span class="s2">None, </span><span class="s1">filter=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Add the file `name' to the archive. `name' may be any type of file 
           (directory, fifo, symbolic link, etc.). If given, `arcname' 
           specifies an alternative name for the file in the archive. 
           Directories are added recursively by default. This can be avoided by 
           setting `recursive' to False. `exclude' is a function that should 
           return True for each filename to be excluded. `filter' is a function 
           that expects a TarInfo object argument and returns the changed 
           TarInfo object, if it returns None the TarInfo object will be 
           excluded from the archive. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._check(</span><span class="s3">&quot;aw&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">arcname </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">arcname = name</span>

        <span class="s0"># Exclude pathnames.</span>
        <span class="s2">if </span><span class="s1">exclude </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">warnings</span>
            <span class="s1">warnings.warn(</span><span class="s3">&quot;use the filter argument instead&quot;</span><span class="s2">,</span>
                    <span class="s1">DeprecationWarning</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">exclude(name):</span>
                <span class="s1">self._dbg(</span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;tarfile: Excluded %r&quot; </span><span class="s1">% name)</span>
                <span class="s2">return</span>

        <span class="s0"># Skip if somebody tries to archive the archive...</span>
        <span class="s2">if </span><span class="s1">self.name </span><span class="s2">is not None and </span><span class="s1">os.path.abspath(name) == self.name:</span>
            <span class="s1">self._dbg(</span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;tarfile: Skipped %r&quot; </span><span class="s1">% name)</span>
            <span class="s2">return</span>

        <span class="s1">self._dbg(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">name)</span>

        <span class="s0"># Create a TarInfo object from the file.</span>
        <span class="s1">tarinfo = self.gettarinfo(name</span><span class="s2">, </span><span class="s1">arcname)</span>

        <span class="s2">if </span><span class="s1">tarinfo </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._dbg(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;tarfile: Unsupported type %r&quot; </span><span class="s1">% name)</span>
            <span class="s2">return</span>

        <span class="s0"># Change or exclude the TarInfo object.</span>
        <span class="s2">if </span><span class="s1">filter </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">tarinfo = filter(tarinfo)</span>
            <span class="s2">if </span><span class="s1">tarinfo </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self._dbg(</span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;tarfile: Excluded %r&quot; </span><span class="s1">% name)</span>
                <span class="s2">return</span>

        <span class="s0"># Append the tar header and data to the archive.</span>
        <span class="s2">if </span><span class="s1">tarinfo.isreg():</span>
            <span class="s1">f = bltn_open(name</span><span class="s2">, </span><span class="s3">&quot;rb&quot;</span><span class="s1">)</span>
            <span class="s1">self.addfile(tarinfo</span><span class="s2">, </span><span class="s1">f)</span>
            <span class="s1">f.close()</span>

        <span class="s2">elif </span><span class="s1">tarinfo.isdir():</span>
            <span class="s1">self.addfile(tarinfo)</span>
            <span class="s2">if </span><span class="s1">recursive:</span>
                <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">os.listdir(name):</span>
                    <span class="s1">self.add(os.path.join(name</span><span class="s2">, </span><span class="s1">f)</span><span class="s2">, </span><span class="s1">os.path.join(arcname</span><span class="s2">, </span><span class="s1">f)</span><span class="s2">,</span>
                            <span class="s1">recursive</span><span class="s2">, </span><span class="s1">exclude</span><span class="s2">, </span><span class="s1">filter=filter)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.addfile(tarinfo)</span>

    <span class="s2">def </span><span class="s1">addfile(self</span><span class="s2">, </span><span class="s1">tarinfo</span><span class="s2">, </span><span class="s1">fileobj=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Add the TarInfo object `tarinfo' to the archive. If `fileobj' is 
           given, tarinfo.size bytes are read from it and added to the archive. 
           You can create TarInfo objects using gettarinfo(). 
           On Windows platforms, `fileobj' should always be opened with mode 
           'rb' to avoid irritation about the file size. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._check(</span><span class="s3">&quot;aw&quot;</span><span class="s1">)</span>

        <span class="s1">tarinfo = copy.copy(tarinfo)</span>

        <span class="s1">buf = tarinfo.tobuf(self.format</span><span class="s2">, </span><span class="s1">self.encoding</span><span class="s2">, </span><span class="s1">self.errors)</span>
        <span class="s1">self.fileobj.write(buf)</span>
        <span class="s1">self.offset += len(buf)</span>

        <span class="s0"># If there's data to follow, append it.</span>
        <span class="s2">if </span><span class="s1">fileobj </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">copyfileobj(fileobj</span><span class="s2">, </span><span class="s1">self.fileobj</span><span class="s2">, </span><span class="s1">tarinfo.size)</span>
            <span class="s1">blocks</span><span class="s2">, </span><span class="s1">remainder = divmod(tarinfo.size</span><span class="s2">, </span><span class="s1">BLOCKSIZE)</span>
            <span class="s2">if </span><span class="s1">remainder &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self.fileobj.write(NUL * (BLOCKSIZE - remainder))</span>
                <span class="s1">blocks += </span><span class="s4">1</span>
            <span class="s1">self.offset += blocks * BLOCKSIZE</span>

        <span class="s1">self.members.append(tarinfo)</span>

    <span class="s2">def </span><span class="s1">extractall(self</span><span class="s2">, </span><span class="s1">path=</span><span class="s3">&quot;.&quot;</span><span class="s2">, </span><span class="s1">members=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Extract all members from the archive to the current working 
           directory and set owner, modification time and permissions on 
           directories afterwards. `path' specifies a different directory 
           to extract to. `members' is optional and must be a subset of the 
           list returned by getmembers(). 
        &quot;&quot;&quot;</span>
        <span class="s1">directories = []</span>

        <span class="s2">if </span><span class="s1">members </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">members = self</span>

        <span class="s2">for </span><span class="s1">tarinfo </span><span class="s2">in </span><span class="s1">members:</span>
            <span class="s2">if </span><span class="s1">tarinfo.isdir():</span>
                <span class="s0"># Extract directories with a safe mode.</span>
                <span class="s1">directories.append(tarinfo)</span>
                <span class="s1">tarinfo = copy.copy(tarinfo)</span>
                <span class="s1">tarinfo.mode = </span><span class="s4">0o700</span>
            <span class="s0"># Do not set_attrs directories, as we will do that further down</span>
            <span class="s1">self.extract(tarinfo</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">set_attrs=</span><span class="s2">not </span><span class="s1">tarinfo.isdir())</span>

        <span class="s0"># Reverse sort directories.</span>
        <span class="s1">directories.sort(key=</span><span class="s2">lambda </span><span class="s1">a: a.name)</span>
        <span class="s1">directories.reverse()</span>

        <span class="s0"># Set correct owner, mtime and filemode on directories.</span>
        <span class="s2">for </span><span class="s1">tarinfo </span><span class="s2">in </span><span class="s1">directories:</span>
            <span class="s1">dirpath = os.path.join(path</span><span class="s2">, </span><span class="s1">tarinfo.name)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.chown(tarinfo</span><span class="s2">, </span><span class="s1">dirpath)</span>
                <span class="s1">self.utime(tarinfo</span><span class="s2">, </span><span class="s1">dirpath)</span>
                <span class="s1">self.chmod(tarinfo</span><span class="s2">, </span><span class="s1">dirpath)</span>
            <span class="s2">except </span><span class="s1">ExtractError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">if </span><span class="s1">self.errorlevel &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s2">raise</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self._dbg(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;tarfile: %s&quot; </span><span class="s1">% e)</span>

    <span class="s2">def </span><span class="s1">extract(self</span><span class="s2">, </span><span class="s1">member</span><span class="s2">, </span><span class="s1">path=</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">set_attrs=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Extract a member from the archive to the current working directory, 
           using its full name. Its file information is extracted as accurately 
           as possible. `member' may be a filename or a TarInfo object. You can 
           specify a different directory using `path'. File attributes (owner, 
           mtime, mode) are set unless `set_attrs' is False. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._check(</span><span class="s3">&quot;r&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(member</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">tarinfo = self.getmember(member)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tarinfo = member</span>

        <span class="s0"># Prepare the link target for makelink().</span>
        <span class="s2">if </span><span class="s1">tarinfo.islnk():</span>
            <span class="s1">tarinfo._link_target = os.path.join(path</span><span class="s2">, </span><span class="s1">tarinfo.linkname)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._extract_member(tarinfo</span><span class="s2">, </span><span class="s1">os.path.join(path</span><span class="s2">, </span><span class="s1">tarinfo.name)</span><span class="s2">,</span>
                                 <span class="s1">set_attrs=set_attrs)</span>
        <span class="s2">except </span><span class="s1">EnvironmentError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">if </span><span class="s1">self.errorlevel &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">raise</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">e.filename </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">self._dbg(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;tarfile: %s&quot; </span><span class="s1">% e.strerror)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self._dbg(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;tarfile: %s %r&quot; </span><span class="s1">% (e.strerror</span><span class="s2">, </span><span class="s1">e.filename))</span>
        <span class="s2">except </span><span class="s1">ExtractError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">if </span><span class="s1">self.errorlevel &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">raise</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._dbg(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;tarfile: %s&quot; </span><span class="s1">% e)</span>

    <span class="s2">def </span><span class="s1">extractfile(self</span><span class="s2">, </span><span class="s1">member):</span>
        <span class="s6">&quot;&quot;&quot;Extract a member from the archive as a file object. `member' may be 
           a filename or a TarInfo object. If `member' is a regular file, a 
           file-like object is returned. If `member' is a link, a file-like 
           object is constructed from the link's target. If `member' is none of 
           the above, None is returned. 
           The file-like object is read-only and provides the following 
           methods: read(), readline(), readlines(), seek() and tell() 
        &quot;&quot;&quot;</span>
        <span class="s1">self._check(</span><span class="s3">&quot;r&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(member</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">tarinfo = self.getmember(member)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tarinfo = member</span>

        <span class="s2">if </span><span class="s1">tarinfo.isreg():</span>
            <span class="s2">return </span><span class="s1">self.fileobject(self</span><span class="s2">, </span><span class="s1">tarinfo)</span>

        <span class="s2">elif </span><span class="s1">tarinfo.type </span><span class="s2">not in </span><span class="s1">SUPPORTED_TYPES:</span>
            <span class="s0"># If a member's type is unknown, it is treated as a</span>
            <span class="s0"># regular file.</span>
            <span class="s2">return </span><span class="s1">self.fileobject(self</span><span class="s2">, </span><span class="s1">tarinfo)</span>

        <span class="s2">elif </span><span class="s1">tarinfo.islnk() </span><span class="s2">or </span><span class="s1">tarinfo.issym():</span>
            <span class="s2">if </span><span class="s1">isinstance(self.fileobj</span><span class="s2">, </span><span class="s1">_Stream):</span>
                <span class="s0"># A small but ugly workaround for the case that someone tries</span>
                <span class="s0"># to extract a (sym)link as a file-object from a non-seekable</span>
                <span class="s0"># stream of tar blocks.</span>
                <span class="s2">raise </span><span class="s1">StreamError(</span><span class="s3">&quot;cannot extract (sym)link as file object&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># A (sym)link's file object is its target's file object.</span>
                <span class="s2">return </span><span class="s1">self.extractfile(self._find_link_target(tarinfo))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># If there's no data associated with the member (directory, chrdev,</span>
            <span class="s0"># blkdev, etc.), return None instead of a file object.</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_extract_member(self</span><span class="s2">, </span><span class="s1">tarinfo</span><span class="s2">, </span><span class="s1">targetpath</span><span class="s2">, </span><span class="s1">set_attrs=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Extract the TarInfo object tarinfo to a physical 
           file called targetpath. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Fetch the TarInfo object for the given name</span>
        <span class="s0"># and build the destination pathname, replacing</span>
        <span class="s0"># forward slashes to platform specific separators.</span>
        <span class="s1">targetpath = targetpath.rstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s1">targetpath = targetpath.replace(</span><span class="s3">&quot;/&quot;</span><span class="s2">, </span><span class="s1">os.sep)</span>

        <span class="s0"># Create all upper directories.</span>
        <span class="s1">upperdirs = os.path.dirname(targetpath)</span>
        <span class="s2">if </span><span class="s1">upperdirs </span><span class="s2">and not </span><span class="s1">os.path.exists(upperdirs):</span>
            <span class="s0"># Create directories that are not part of the archive with</span>
            <span class="s0"># default permissions.</span>
            <span class="s1">os.makedirs(upperdirs)</span>

        <span class="s2">if </span><span class="s1">tarinfo.islnk() </span><span class="s2">or </span><span class="s1">tarinfo.issym():</span>
            <span class="s1">self._dbg(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;%s -&gt; %s&quot; </span><span class="s1">% (tarinfo.name</span><span class="s2">, </span><span class="s1">tarinfo.linkname))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._dbg(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">tarinfo.name)</span>

        <span class="s2">if </span><span class="s1">tarinfo.isreg():</span>
            <span class="s1">self.makefile(tarinfo</span><span class="s2">, </span><span class="s1">targetpath)</span>
        <span class="s2">elif </span><span class="s1">tarinfo.isdir():</span>
            <span class="s1">self.makedir(tarinfo</span><span class="s2">, </span><span class="s1">targetpath)</span>
        <span class="s2">elif </span><span class="s1">tarinfo.isfifo():</span>
            <span class="s1">self.makefifo(tarinfo</span><span class="s2">, </span><span class="s1">targetpath)</span>
        <span class="s2">elif </span><span class="s1">tarinfo.ischr() </span><span class="s2">or </span><span class="s1">tarinfo.isblk():</span>
            <span class="s1">self.makedev(tarinfo</span><span class="s2">, </span><span class="s1">targetpath)</span>
        <span class="s2">elif </span><span class="s1">tarinfo.islnk() </span><span class="s2">or </span><span class="s1">tarinfo.issym():</span>
            <span class="s1">self.makelink(tarinfo</span><span class="s2">, </span><span class="s1">targetpath)</span>
        <span class="s2">elif </span><span class="s1">tarinfo.type </span><span class="s2">not in </span><span class="s1">SUPPORTED_TYPES:</span>
            <span class="s1">self.makeunknown(tarinfo</span><span class="s2">, </span><span class="s1">targetpath)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.makefile(tarinfo</span><span class="s2">, </span><span class="s1">targetpath)</span>

        <span class="s2">if </span><span class="s1">set_attrs:</span>
            <span class="s1">self.chown(tarinfo</span><span class="s2">, </span><span class="s1">targetpath)</span>
            <span class="s2">if not </span><span class="s1">tarinfo.issym():</span>
                <span class="s1">self.chmod(tarinfo</span><span class="s2">, </span><span class="s1">targetpath)</span>
                <span class="s1">self.utime(tarinfo</span><span class="s2">, </span><span class="s1">targetpath)</span>

    <span class="s0">#--------------------------------------------------------------------------</span>
    <span class="s0"># Below are the different file methods. They are called via</span>
    <span class="s0"># _extract_member() when extract() is called. They can be replaced in a</span>
    <span class="s0"># subclass to implement other functionality.</span>

    <span class="s2">def </span><span class="s1">makedir(self</span><span class="s2">, </span><span class="s1">tarinfo</span><span class="s2">, </span><span class="s1">targetpath):</span>
        <span class="s6">&quot;&quot;&quot;Make a directory called targetpath. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s0"># Use a safe mode for the directory, the real mode is set</span>
            <span class="s0"># later in _extract_member().</span>
            <span class="s1">os.mkdir(targetpath</span><span class="s2">, </span><span class="s4">0o700</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">EnvironmentError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">if </span><span class="s1">e.errno != errno.EEXIST:</span>
                <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">makefile(self</span><span class="s2">, </span><span class="s1">tarinfo</span><span class="s2">, </span><span class="s1">targetpath):</span>
        <span class="s6">&quot;&quot;&quot;Make a file called targetpath. 
        &quot;&quot;&quot;</span>
        <span class="s1">source = self.fileobj</span>
        <span class="s1">source.seek(tarinfo.offset_data)</span>
        <span class="s1">target = bltn_open(targetpath</span><span class="s2">, </span><span class="s3">&quot;wb&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">tarinfo.sparse </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">size </span><span class="s2">in </span><span class="s1">tarinfo.sparse:</span>
                <span class="s1">target.seek(offset)</span>
                <span class="s1">copyfileobj(source</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">size)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">copyfileobj(source</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">tarinfo.size)</span>
        <span class="s1">target.seek(tarinfo.size)</span>
        <span class="s1">target.truncate()</span>
        <span class="s1">target.close()</span>

    <span class="s2">def </span><span class="s1">makeunknown(self</span><span class="s2">, </span><span class="s1">tarinfo</span><span class="s2">, </span><span class="s1">targetpath):</span>
        <span class="s6">&quot;&quot;&quot;Make a file from a TarInfo object with an unknown type 
           at targetpath. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.makefile(tarinfo</span><span class="s2">, </span><span class="s1">targetpath)</span>
        <span class="s1">self._dbg(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;tarfile: Unknown file type %r, &quot; </span><span class="s1">\</span>
                     <span class="s3">&quot;extracted as regular file.&quot; </span><span class="s1">% tarinfo.type)</span>

    <span class="s2">def </span><span class="s1">makefifo(self</span><span class="s2">, </span><span class="s1">tarinfo</span><span class="s2">, </span><span class="s1">targetpath):</span>
        <span class="s6">&quot;&quot;&quot;Make a fifo called targetpath. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">&quot;mkfifo&quot;</span><span class="s1">):</span>
            <span class="s1">os.mkfifo(targetpath)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ExtractError(</span><span class="s3">&quot;fifo not supported by system&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">makedev(self</span><span class="s2">, </span><span class="s1">tarinfo</span><span class="s2">, </span><span class="s1">targetpath):</span>
        <span class="s6">&quot;&quot;&quot;Make a character or block device called targetpath. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">&quot;mknod&quot;</span><span class="s1">) </span><span class="s2">or not </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">&quot;makedev&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ExtractError(</span><span class="s3">&quot;special devices not supported by system&quot;</span><span class="s1">)</span>

        <span class="s1">mode = tarinfo.mode</span>
        <span class="s2">if </span><span class="s1">tarinfo.isblk():</span>
            <span class="s1">mode |= stat.S_IFBLK</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">mode |= stat.S_IFCHR</span>

        <span class="s1">os.mknod(targetpath</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">,</span>
                 <span class="s1">os.makedev(tarinfo.devmajor</span><span class="s2">, </span><span class="s1">tarinfo.devminor))</span>

    <span class="s2">def </span><span class="s1">makelink(self</span><span class="s2">, </span><span class="s1">tarinfo</span><span class="s2">, </span><span class="s1">targetpath):</span>
        <span class="s6">&quot;&quot;&quot;Make a (symbolic) link called targetpath. If it cannot be created 
          (platform limitation), we try to make a copy of the referenced file 
          instead of a link. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s0"># For systems that support symbolic and hard links.</span>
            <span class="s2">if </span><span class="s1">tarinfo.issym():</span>
                <span class="s1">os.symlink(tarinfo.linkname</span><span class="s2">, </span><span class="s1">targetpath)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># See extract().</span>
                <span class="s2">if </span><span class="s1">os.path.exists(tarinfo._link_target):</span>
                    <span class="s1">os.link(tarinfo._link_target</span><span class="s2">, </span><span class="s1">targetpath)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self._extract_member(self._find_link_target(tarinfo)</span><span class="s2">,</span>
                                         <span class="s1">targetpath)</span>
        <span class="s2">except </span><span class="s1">symlink_exception:</span>
            <span class="s2">if </span><span class="s1">tarinfo.issym():</span>
                <span class="s1">linkpath = os.path.join(os.path.dirname(tarinfo.name)</span><span class="s2">,</span>
                                        <span class="s1">tarinfo.linkname)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">linkpath = tarinfo.linkname</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self._extract_member(self._find_link_target(tarinfo)</span><span class="s2">,</span>
                                     <span class="s1">targetpath)</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s2">raise </span><span class="s1">ExtractError(</span><span class="s3">&quot;unable to resolve link inside archive&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">chown(self</span><span class="s2">, </span><span class="s1">tarinfo</span><span class="s2">, </span><span class="s1">targetpath):</span>
        <span class="s6">&quot;&quot;&quot;Set owner of targetpath according to tarinfo. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">pwd </span><span class="s2">and </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">&quot;geteuid&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">os.geteuid() == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># We have to be root to do so.</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">g = grp.getgrnam(tarinfo.gname)[</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s1">g = tarinfo.gid</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">u = pwd.getpwnam(tarinfo.uname)[</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s1">u = tarinfo.uid</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">tarinfo.issym() </span><span class="s2">and </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">&quot;lchown&quot;</span><span class="s1">):</span>
                    <span class="s1">os.lchown(targetpath</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">g)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">sys.platform != </span><span class="s3">&quot;os2emx&quot;</span><span class="s1">:</span>
                        <span class="s1">os.chown(targetpath</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">g)</span>
            <span class="s2">except </span><span class="s1">EnvironmentError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">raise </span><span class="s1">ExtractError(</span><span class="s3">&quot;could not change owner&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">chmod(self</span><span class="s2">, </span><span class="s1">tarinfo</span><span class="s2">, </span><span class="s1">targetpath):</span>
        <span class="s6">&quot;&quot;&quot;Set file permissions of targetpath according to tarinfo. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">'chmod'</span><span class="s1">):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">os.chmod(targetpath</span><span class="s2">, </span><span class="s1">tarinfo.mode)</span>
            <span class="s2">except </span><span class="s1">EnvironmentError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">raise </span><span class="s1">ExtractError(</span><span class="s3">&quot;could not change mode&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">utime(self</span><span class="s2">, </span><span class="s1">tarinfo</span><span class="s2">, </span><span class="s1">targetpath):</span>
        <span class="s6">&quot;&quot;&quot;Set modification time of targetpath according to tarinfo. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">'utime'</span><span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">os.utime(targetpath</span><span class="s2">, </span><span class="s1">(tarinfo.mtime</span><span class="s2">, </span><span class="s1">tarinfo.mtime))</span>
        <span class="s2">except </span><span class="s1">EnvironmentError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">ExtractError(</span><span class="s3">&quot;could not change modification time&quot;</span><span class="s1">)</span>

    <span class="s0">#--------------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">next(self):</span>
        <span class="s6">&quot;&quot;&quot;Return the next member of the archive as a TarInfo object, when 
           TarFile is opened for reading. Return None if there is no more 
           available. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._check(</span><span class="s3">&quot;ra&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.firstmember </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">m = self.firstmember</span>
            <span class="s1">self.firstmember = </span><span class="s2">None</span>
            <span class="s2">return </span><span class="s1">m</span>

        <span class="s0"># Read the next block.</span>
        <span class="s1">self.fileobj.seek(self.offset)</span>
        <span class="s1">tarinfo = </span><span class="s2">None</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">tarinfo = self.tarinfo.fromtarfile(self)</span>
            <span class="s2">except </span><span class="s1">EOFHeaderError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">if </span><span class="s1">self.ignore_zeros:</span>
                    <span class="s1">self._dbg(</span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;0x%X: %s&quot; </span><span class="s1">% (self.offset</span><span class="s2">, </span><span class="s1">e))</span>
                    <span class="s1">self.offset += BLOCKSIZE</span>
                    <span class="s2">continue</span>
            <span class="s2">except </span><span class="s1">InvalidHeaderError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">if </span><span class="s1">self.ignore_zeros:</span>
                    <span class="s1">self._dbg(</span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;0x%X: %s&quot; </span><span class="s1">% (self.offset</span><span class="s2">, </span><span class="s1">e))</span>
                    <span class="s1">self.offset += BLOCKSIZE</span>
                    <span class="s2">continue</span>
                <span class="s2">elif </span><span class="s1">self.offset == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ReadError(str(e))</span>
            <span class="s2">except </span><span class="s1">EmptyHeaderError:</span>
                <span class="s2">if </span><span class="s1">self.offset == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ReadError(</span><span class="s3">&quot;empty file&quot;</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">TruncatedHeaderError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">if </span><span class="s1">self.offset == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ReadError(str(e))</span>
            <span class="s2">except </span><span class="s1">SubsequentHeaderError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">raise </span><span class="s1">ReadError(str(e))</span>
            <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">tarinfo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.members.append(tarinfo)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._loaded = </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">tarinfo</span>

    <span class="s0">#--------------------------------------------------------------------------</span>
    <span class="s0"># Little helper methods:</span>

    <span class="s2">def </span><span class="s1">_getmember(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">tarinfo=</span><span class="s2">None, </span><span class="s1">normalize=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Find an archive member by name from bottom to top. 
           If tarinfo is given, it is used as the starting point. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Ensure that all members have been loaded.</span>
        <span class="s1">members = self.getmembers()</span>

        <span class="s0"># Limit the member search list up to tarinfo.</span>
        <span class="s2">if </span><span class="s1">tarinfo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">members = members[:members.index(tarinfo)]</span>

        <span class="s2">if </span><span class="s1">normalize:</span>
            <span class="s1">name = os.path.normpath(name)</span>

        <span class="s2">for </span><span class="s1">member </span><span class="s2">in </span><span class="s1">reversed(members):</span>
            <span class="s2">if </span><span class="s1">normalize:</span>
                <span class="s1">member_name = os.path.normpath(member.name)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">member_name = member.name</span>

            <span class="s2">if </span><span class="s1">name == member_name:</span>
                <span class="s2">return </span><span class="s1">member</span>

    <span class="s2">def </span><span class="s1">_load(self):</span>
        <span class="s6">&quot;&quot;&quot;Read through the entire archive file and look for readable 
           members. 
        &quot;&quot;&quot;</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">tarinfo = self.next()</span>
            <span class="s2">if </span><span class="s1">tarinfo </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">break</span>
        <span class="s1">self._loaded = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_check(self</span><span class="s2">, </span><span class="s1">mode=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Check if TarFile is still open, and if the operation's mode 
           corresponds to TarFile's mode. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.closed:</span>
            <span class="s2">raise </span><span class="s1">IOError(</span><span class="s3">&quot;%s is closed&quot; </span><span class="s1">% self.__class__.__name__)</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s2">is not None and </span><span class="s1">self.mode </span><span class="s2">not in </span><span class="s1">mode:</span>
            <span class="s2">raise </span><span class="s1">IOError(</span><span class="s3">&quot;bad operation for mode %r&quot; </span><span class="s1">% self.mode)</span>

    <span class="s2">def </span><span class="s1">_find_link_target(self</span><span class="s2">, </span><span class="s1">tarinfo):</span>
        <span class="s6">&quot;&quot;&quot;Find the target member of a symlink or hardlink member in the 
           archive. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">tarinfo.issym():</span>
            <span class="s0"># Always search the entire archive.</span>
            <span class="s1">linkname = os.path.dirname(tarinfo.name) + </span><span class="s3">&quot;/&quot; </span><span class="s1">+ tarinfo.linkname</span>
            <span class="s1">limit = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Search the archive before the link, because a hard link is</span>
            <span class="s0"># just a reference to an already archived file.</span>
            <span class="s1">linkname = tarinfo.linkname</span>
            <span class="s1">limit = tarinfo</span>

        <span class="s1">member = self._getmember(linkname</span><span class="s2">, </span><span class="s1">tarinfo=limit</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">member </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">KeyError(</span><span class="s3">&quot;linkname %r not found&quot; </span><span class="s1">% linkname)</span>
        <span class="s2">return </span><span class="s1">member</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s6">&quot;&quot;&quot;Provide an iterator object. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._loaded:</span>
            <span class="s2">return </span><span class="s1">iter(self.members)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">TarIter(self)</span>

    <span class="s2">def </span><span class="s1">_dbg(self</span><span class="s2">, </span><span class="s1">level</span><span class="s2">, </span><span class="s1">msg):</span>
        <span class="s6">&quot;&quot;&quot;Write debugging output to sys.stderr. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">level &lt;= self.debug:</span>
            <span class="s1">print(msg</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s1">self._check()</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">traceback):</span>
        <span class="s2">if </span><span class="s1">type </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.close()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># An exception occurred. We must not call close() because</span>
            <span class="s0"># it would try to write end-of-archive blocks and padding.</span>
            <span class="s2">if not </span><span class="s1">self._extfileobj:</span>
                <span class="s1">self.fileobj.close()</span>
            <span class="s1">self.closed = </span><span class="s2">True</span>
<span class="s0"># class TarFile</span>

<span class="s2">class </span><span class="s1">TarIter(object):</span>
    <span class="s6">&quot;&quot;&quot;Iterator Class. 
 
       for tarinfo in TarFile(...): 
           suite... 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">tarfile):</span>
        <span class="s6">&quot;&quot;&quot;Construct a TarIter object. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.tarfile = tarfile</span>
        <span class="s1">self.index = </span><span class="s4">0</span>
    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s6">&quot;&quot;&quot;Return iterator object. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__next__(self):</span>
        <span class="s6">&quot;&quot;&quot;Return the next item using TarFile's next() method. 
           When all members have been read, set TarFile as _loaded. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Fix for SF #1100429: Under rare circumstances it can</span>
        <span class="s0"># happen that getmembers() is called during iteration,</span>
        <span class="s0"># which will cause TarIter to stop prematurely.</span>
        <span class="s2">if not </span><span class="s1">self.tarfile._loaded:</span>
            <span class="s1">tarinfo = self.tarfile.next()</span>
            <span class="s2">if not </span><span class="s1">tarinfo:</span>
                <span class="s1">self.tarfile._loaded = </span><span class="s2">True</span>
                <span class="s2">raise </span><span class="s1">StopIteration</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">tarinfo = self.tarfile.members[self.index]</span>
            <span class="s2">except </span><span class="s1">IndexError:</span>
                <span class="s2">raise </span><span class="s1">StopIteration</span>
        <span class="s1">self.index += </span><span class="s4">1</span>
        <span class="s2">return </span><span class="s1">tarinfo</span>

    <span class="s1">next = __next__ </span><span class="s0"># for Python 2.x</span>

<span class="s0">#--------------------</span>
<span class="s0"># exported functions</span>
<span class="s0">#--------------------</span>
<span class="s2">def </span><span class="s1">is_tarfile(name):</span>
    <span class="s6">&quot;&quot;&quot;Return True if name points to a tar archive that we 
       are able to handle, else return False. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">t = open(name)</span>
        <span class="s1">t.close()</span>
        <span class="s2">return True</span>
    <span class="s2">except </span><span class="s1">TarError:</span>
        <span class="s2">return False</span>

<span class="s1">bltn_open = open</span>
<span class="s1">open = TarFile.open</span>
</pre>
</body>
</html>