<html>
<head>
<title>PngImagePlugin.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #a5c261;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
.s6 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
PngImagePlugin.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># The Python Imaging Library.</span>
<span class="s0"># $Id$</span>
<span class="s0">#</span>
<span class="s0"># PNG support code</span>
<span class="s0">#</span>
<span class="s0"># See &quot;PNG (Portable Network Graphics) Specification, version 1.0;</span>
<span class="s0"># W3C Recommendation&quot;, 1996-10-01, Thomas Boutell (ed.).</span>
<span class="s0">#</span>
<span class="s0"># history:</span>
<span class="s0"># 1996-05-06 fl   Created (couldn't resist it)</span>
<span class="s0"># 1996-12-14 fl   Upgraded, added read and verify support (0.2)</span>
<span class="s0"># 1996-12-15 fl   Separate PNG stream parser</span>
<span class="s0"># 1996-12-29 fl   Added write support, added getchunks</span>
<span class="s0"># 1996-12-30 fl   Eliminated circular references in decoder (0.3)</span>
<span class="s0"># 1998-07-12 fl   Read/write 16-bit images as mode I (0.4)</span>
<span class="s0"># 2001-02-08 fl   Added transparency support (from Zircon) (0.5)</span>
<span class="s0"># 2001-04-16 fl   Don't close data source in &quot;open&quot; method (0.6)</span>
<span class="s0"># 2004-02-24 fl   Don't even pretend to support interlaced files (0.7)</span>
<span class="s0"># 2004-08-31 fl   Do basic sanity check on chunk identifiers (0.8)</span>
<span class="s0"># 2004-09-20 fl   Added PngInfo chunk container</span>
<span class="s0"># 2004-12-18 fl   Added DPI read support (based on code by Niki Spahiev)</span>
<span class="s0"># 2008-08-13 fl   Added tRNS support for RGB images</span>
<span class="s0"># 2009-03-06 fl   Support for preserving ICC profiles (by Florian Hoech)</span>
<span class="s0"># 2009-03-08 fl   Added zTXT support (from Lowell Alleman)</span>
<span class="s0"># 2009-03-29 fl   Read interlaced PNG files (from Conrado Porto Lopes Gouvua)</span>
<span class="s0">#</span>
<span class="s0"># Copyright (c) 1997-2009 by Secret Labs AB</span>
<span class="s0"># Copyright (c) 1996 by Fredrik Lundh</span>
<span class="s0">#</span>
<span class="s0"># See the README file for information on usage and redistribution.</span>
<span class="s0">#</span>

<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">zlib</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">IntEnum</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">Image</span><span class="s2">, </span><span class="s1">ImageChops</span><span class="s2">, </span><span class="s1">ImageFile</span><span class="s2">, </span><span class="s1">ImagePalette</span><span class="s2">, </span><span class="s1">ImageSequence</span>
<span class="s2">from </span><span class="s1">._binary </span><span class="s2">import </span><span class="s1">i16be </span><span class="s2">as </span><span class="s1">i16</span>
<span class="s2">from </span><span class="s1">._binary </span><span class="s2">import </span><span class="s1">i32be </span><span class="s2">as </span><span class="s1">i32</span>
<span class="s2">from </span><span class="s1">._binary </span><span class="s2">import </span><span class="s1">o8</span>
<span class="s2">from </span><span class="s1">._binary </span><span class="s2">import </span><span class="s1">o16be </span><span class="s2">as </span><span class="s1">o16</span>
<span class="s2">from </span><span class="s1">._binary </span><span class="s2">import </span><span class="s1">o32be </span><span class="s2">as </span><span class="s1">o32</span>
<span class="s2">from </span><span class="s1">._deprecate </span><span class="s2">import </span><span class="s1">deprecate</span>

<span class="s1">logger = logging.getLogger(__name__)</span>

<span class="s1">is_cid = re.compile(</span><span class="s3">rb&quot;\w\w\w\w&quot;</span><span class="s1">).match</span>


<span class="s1">_MAGIC = </span><span class="s3">b&quot;</span><span class="s2">\211</span><span class="s3">PNG</span><span class="s2">\r\n\032\n</span><span class="s3">&quot;</span>


<span class="s1">_MODES = {</span>
    <span class="s0"># supported bits/color combinations, and corresponding modes/rawmodes</span>
    <span class="s0"># Greyscale</span>
    <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">): (</span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;1&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">): (</span><span class="s5">&quot;L&quot;</span><span class="s2">, </span><span class="s5">&quot;L;2&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s1">): (</span><span class="s5">&quot;L&quot;</span><span class="s2">, </span><span class="s5">&quot;L;4&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s4">8</span><span class="s2">, </span><span class="s4">0</span><span class="s1">): (</span><span class="s5">&quot;L&quot;</span><span class="s2">, </span><span class="s5">&quot;L&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s4">16</span><span class="s2">, </span><span class="s4">0</span><span class="s1">): (</span><span class="s5">&quot;I&quot;</span><span class="s2">, </span><span class="s5">&quot;I;16B&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s0"># Truecolour</span>
    <span class="s1">(</span><span class="s4">8</span><span class="s2">, </span><span class="s4">2</span><span class="s1">): (</span><span class="s5">&quot;RGB&quot;</span><span class="s2">, </span><span class="s5">&quot;RGB&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s4">16</span><span class="s2">, </span><span class="s4">2</span><span class="s1">): (</span><span class="s5">&quot;RGB&quot;</span><span class="s2">, </span><span class="s5">&quot;RGB;16B&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s0"># Indexed-colour</span>
    <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">): (</span><span class="s5">&quot;P&quot;</span><span class="s2">, </span><span class="s5">&quot;P;1&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">): (</span><span class="s5">&quot;P&quot;</span><span class="s2">, </span><span class="s5">&quot;P;2&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s1">): (</span><span class="s5">&quot;P&quot;</span><span class="s2">, </span><span class="s5">&quot;P;4&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s4">8</span><span class="s2">, </span><span class="s4">3</span><span class="s1">): (</span><span class="s5">&quot;P&quot;</span><span class="s2">, </span><span class="s5">&quot;P&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s0"># Greyscale with alpha</span>
    <span class="s1">(</span><span class="s4">8</span><span class="s2">, </span><span class="s4">4</span><span class="s1">): (</span><span class="s5">&quot;LA&quot;</span><span class="s2">, </span><span class="s5">&quot;LA&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s4">16</span><span class="s2">, </span><span class="s4">4</span><span class="s1">): (</span><span class="s5">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s5">&quot;LA;16B&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># LA;16B-&gt;LA not yet available</span>
    <span class="s0"># Truecolour with alpha</span>
    <span class="s1">(</span><span class="s4">8</span><span class="s2">, </span><span class="s4">6</span><span class="s1">): (</span><span class="s5">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s5">&quot;RGBA&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s4">16</span><span class="s2">, </span><span class="s4">6</span><span class="s1">): (</span><span class="s5">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s5">&quot;RGBA;16B&quot;</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s1">_simple_palette = re.compile(</span><span class="s3">b&quot;^</span><span class="s2">\xff</span><span class="s3">*</span><span class="s2">\x00\xff</span><span class="s3">*$&quot;</span><span class="s1">)</span>

<span class="s1">MAX_TEXT_CHUNK = ImageFile.SAFEBLOCK</span>
<span class="s5">&quot;&quot;&quot; 
Maximum decompressed size for a iTXt or zTXt chunk. 
Eliminates decompression bombs where compressed chunks can expand 1000x. 
See :ref:`Text in PNG File Format&lt;png-text&gt;`. 
&quot;&quot;&quot;</span>
<span class="s1">MAX_TEXT_MEMORY = </span><span class="s4">64 </span><span class="s1">* MAX_TEXT_CHUNK</span>
<span class="s5">&quot;&quot;&quot; 
Set the maximum total text chunk size. 
See :ref:`Text in PNG File Format&lt;png-text&gt;`. 
&quot;&quot;&quot;</span>


<span class="s0"># APNG frame disposal modes</span>
<span class="s2">class </span><span class="s1">Disposal(IntEnum):</span>
    <span class="s1">OP_NONE = </span><span class="s4">0</span>
    <span class="s5">&quot;&quot;&quot; 
    No disposal is done on this frame before rendering the next frame. 
    See :ref:`Saving APNG sequences&lt;apng-saving&gt;`. 
    &quot;&quot;&quot;</span>
    <span class="s1">OP_BACKGROUND = </span><span class="s4">1</span>
    <span class="s5">&quot;&quot;&quot; 
    This frame’s modified region is cleared to fully transparent black before rendering 
    the next frame. 
    See :ref:`Saving APNG sequences&lt;apng-saving&gt;`. 
    &quot;&quot;&quot;</span>
    <span class="s1">OP_PREVIOUS = </span><span class="s4">2</span>
    <span class="s5">&quot;&quot;&quot; 
    This frame’s modified region is reverted to the previous frame’s contents before 
    rendering the next frame. 
    See :ref:`Saving APNG sequences&lt;apng-saving&gt;`. 
    &quot;&quot;&quot;</span>


<span class="s0"># APNG frame blend modes</span>
<span class="s2">class </span><span class="s1">Blend(IntEnum):</span>
    <span class="s1">OP_SOURCE = </span><span class="s4">0</span>
    <span class="s5">&quot;&quot;&quot; 
    All color components of this frame, including alpha, overwrite the previous output 
    image contents. 
    See :ref:`Saving APNG sequences&lt;apng-saving&gt;`. 
    &quot;&quot;&quot;</span>
    <span class="s1">OP_OVER = </span><span class="s4">1</span>
    <span class="s5">&quot;&quot;&quot; 
    This frame should be alpha composited with the previous output image contents. 
    See :ref:`Saving APNG sequences&lt;apng-saving&gt;`. 
    &quot;&quot;&quot;</span>


<span class="s2">def </span><span class="s1">__getattr__(name):</span>
    <span class="s2">for </span><span class="s1">enum</span><span class="s2">, </span><span class="s1">prefix </span><span class="s2">in </span><span class="s1">{Disposal: </span><span class="s5">&quot;APNG_DISPOSE_&quot;</span><span class="s2">, </span><span class="s1">Blend: </span><span class="s5">&quot;APNG_BLEND_&quot;</span><span class="s1">}.items():</span>
        <span class="s2">if </span><span class="s1">name.startswith(prefix):</span>
            <span class="s1">name = name[len(prefix) :]</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enum.__members__:</span>
                <span class="s1">deprecate(</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">prefix</span><span class="s2">}{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">enum.__name__</span><span class="s2">}</span><span class="s5">.</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">enum[name]</span>
    <span class="s1">msg = </span><span class="s5">f&quot;module '</span><span class="s2">{</span><span class="s1">__name__</span><span class="s2">}</span><span class="s5">' has no attribute '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">'&quot;</span>
    <span class="s2">raise </span><span class="s1">AttributeError(msg)</span>


<span class="s2">def </span><span class="s1">_safe_zlib_decompress(s):</span>
    <span class="s1">dobj = zlib.decompressobj()</span>
    <span class="s1">plaintext = dobj.decompress(s</span><span class="s2">, </span><span class="s1">MAX_TEXT_CHUNK)</span>
    <span class="s2">if </span><span class="s1">dobj.unconsumed_tail:</span>
        <span class="s1">msg = </span><span class="s5">&quot;Decompressed Data Too Large&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
    <span class="s2">return </span><span class="s1">plaintext</span>


<span class="s2">def </span><span class="s1">_crc32(data</span><span class="s2">, </span><span class="s1">seed=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">zlib.crc32(data</span><span class="s2">, </span><span class="s1">seed) &amp; </span><span class="s4">0xFFFFFFFF</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Support classes.  Suitable for PNG and related formats like MNG etc.</span>


<span class="s2">class </span><span class="s1">ChunkStream:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fp):</span>

        <span class="s1">self.fp = fp</span>
        <span class="s1">self.queue = []</span>

    <span class="s2">def </span><span class="s1">read(self):</span>
        <span class="s6">&quot;&quot;&quot;Fetch a new chunk. Returns header information.&quot;&quot;&quot;</span>
        <span class="s1">cid = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self.queue:</span>
            <span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length = self.queue.pop()</span>
            <span class="s1">self.fp.seek(pos)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">s = self.fp.read(</span><span class="s4">8</span><span class="s1">)</span>
            <span class="s1">cid = s[</span><span class="s4">4</span><span class="s1">:]</span>
            <span class="s1">pos = self.fp.tell()</span>
            <span class="s1">length = i32(s)</span>

        <span class="s2">if not </span><span class="s1">is_cid(cid):</span>
            <span class="s2">if not </span><span class="s1">ImageFile.LOAD_TRUNCATED_IMAGES:</span>
                <span class="s1">msg = </span><span class="s5">f&quot;broken PNG file (chunk </span><span class="s2">{</span><span class="s1">repr(cid)</span><span class="s2">}</span><span class="s5">)&quot;</span>
                <span class="s2">raise </span><span class="s1">SyntaxError(msg)</span>

        <span class="s2">return </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">self.close()</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s1">self.queue = self.fp = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">push(self</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>

        <span class="s1">self.queue.append((cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length))</span>

    <span class="s2">def </span><span class="s1">call(self</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s6">&quot;&quot;&quot;Call the appropriate chunk handler&quot;&quot;&quot;</span>

        <span class="s1">logger.debug(</span><span class="s5">&quot;STREAM %r %s %s&quot;</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s2">return </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s5">&quot;chunk_&quot; </span><span class="s1">+ cid.decode(</span><span class="s5">&quot;ascii&quot;</span><span class="s1">))(pos</span><span class="s2">, </span><span class="s1">length)</span>

    <span class="s2">def </span><span class="s1">crc(self</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s6">&quot;&quot;&quot;Read and verify checksum&quot;&quot;&quot;</span>

        <span class="s0"># Skip CRC checks for ancillary chunks if allowed to load truncated</span>
        <span class="s0"># images</span>
        <span class="s0"># 5th byte of first char is 1 [specs, section 5.4]</span>
        <span class="s2">if </span><span class="s1">ImageFile.LOAD_TRUNCATED_IMAGES </span><span class="s2">and </span><span class="s1">(cid[</span><span class="s4">0</span><span class="s1">] &gt;&gt; </span><span class="s4">5 </span><span class="s1">&amp; </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">self.crc_skip(cid</span><span class="s2">, </span><span class="s1">data)</span>
            <span class="s2">return</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">crc1 = _crc32(data</span><span class="s2">, </span><span class="s1">_crc32(cid))</span>
            <span class="s1">crc2 = i32(self.fp.read(</span><span class="s4">4</span><span class="s1">))</span>
            <span class="s2">if </span><span class="s1">crc1 != crc2:</span>
                <span class="s1">msg = </span><span class="s5">f&quot;broken PNG file (bad header checksum in </span><span class="s2">{</span><span class="s1">repr(cid)</span><span class="s2">}</span><span class="s5">)&quot;</span>
                <span class="s2">raise </span><span class="s1">SyntaxError(msg)</span>
        <span class="s2">except </span><span class="s1">struct.error </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">msg = </span><span class="s5">f&quot;broken PNG file (incomplete checksum in </span><span class="s2">{</span><span class="s1">repr(cid)</span><span class="s2">}</span><span class="s5">)&quot;</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(msg) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">def </span><span class="s1">crc_skip(self</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s6">&quot;&quot;&quot;Read checksum&quot;&quot;&quot;</span>

        <span class="s1">self.fp.read(</span><span class="s4">4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">verify(self</span><span class="s2">, </span><span class="s1">endchunk=</span><span class="s3">b&quot;IEND&quot;</span><span class="s1">):</span>

        <span class="s0"># Simple approach; just calculate checksum for all remaining</span>
        <span class="s0"># blocks.  Must be called directly after open.</span>

        <span class="s1">cids = []</span>

        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length = self.read()</span>
            <span class="s2">except </span><span class="s1">struct.error </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">msg = </span><span class="s5">&quot;truncated PNG file&quot;</span>
                <span class="s2">raise </span><span class="s1">OSError(msg) </span><span class="s2">from </span><span class="s1">e</span>

            <span class="s2">if </span><span class="s1">cid == endchunk:</span>
                <span class="s2">break</span>
            <span class="s1">self.crc(cid</span><span class="s2">, </span><span class="s1">ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length))</span>
            <span class="s1">cids.append(cid)</span>

        <span class="s2">return </span><span class="s1">cids</span>


<span class="s2">class </span><span class="s1">iTXt(str):</span>
    <span class="s6">&quot;&quot;&quot; 
    Subclass of string to allow iTXt chunks to look like strings while 
    keeping their extra information 
 
    &quot;&quot;&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">__new__(cls</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">lang=</span><span class="s2">None, </span><span class="s1">tkey=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot; 
        :param cls: the class to use when creating the instance 
        :param text: value for this key 
        :param lang: language code 
        :param tkey: UTF-8 version of the key name 
        &quot;&quot;&quot;</span>

        <span class="s1">self = str.__new__(cls</span><span class="s2">, </span><span class="s1">text)</span>
        <span class="s1">self.lang = lang</span>
        <span class="s1">self.tkey = tkey</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s2">class </span><span class="s1">PngInfo:</span>
    <span class="s6">&quot;&quot;&quot; 
    PNG chunk container (for use with save(pnginfo=)) 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.chunks = []</span>

    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">after_idat=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Appends an arbitrary chunk. Use with caution. 
 
        :param cid: a byte string, 4 bytes long. 
        :param data: a byte string of the encoded data 
        :param after_idat: for use with private chunks. Whether the chunk 
                           should be written after IDAT 
 
        &quot;&quot;&quot;</span>

        <span class="s1">chunk = [cid</span><span class="s2">, </span><span class="s1">data]</span>
        <span class="s2">if </span><span class="s1">after_idat:</span>
            <span class="s1">chunk.append(</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">self.chunks.append(tuple(chunk))</span>

    <span class="s2">def </span><span class="s1">add_itxt(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">lang=</span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s1">tkey=</span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s1">zip=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Appends an iTXt chunk. 
 
        :param key: latin-1 encodable text key name 
        :param value: value for this key 
        :param lang: language code 
        :param tkey: UTF-8 version of the key name 
        :param zip: compression flag 
 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s1">key = key.encode(</span><span class="s5">&quot;latin-1&quot;</span><span class="s2">, </span><span class="s5">&quot;strict&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s1">value = value.encode(</span><span class="s5">&quot;utf-8&quot;</span><span class="s2">, </span><span class="s5">&quot;strict&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(lang</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s1">lang = lang.encode(</span><span class="s5">&quot;utf-8&quot;</span><span class="s2">, </span><span class="s5">&quot;strict&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(tkey</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s1">tkey = tkey.encode(</span><span class="s5">&quot;utf-8&quot;</span><span class="s2">, </span><span class="s5">&quot;strict&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">zip:</span>
            <span class="s1">self.add(</span>
                <span class="s3">b&quot;iTXt&quot;</span><span class="s2">,</span>
                <span class="s1">key + </span><span class="s3">b&quot;</span><span class="s2">\0\x01\0</span><span class="s3">&quot; </span><span class="s1">+ lang + </span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot; </span><span class="s1">+ tkey + </span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot; </span><span class="s1">+ zlib.compress(value)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.add(</span><span class="s3">b&quot;iTXt&quot;</span><span class="s2">, </span><span class="s1">key + </span><span class="s3">b&quot;</span><span class="s2">\0\0\0</span><span class="s3">&quot; </span><span class="s1">+ lang + </span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot; </span><span class="s1">+ tkey + </span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot; </span><span class="s1">+ value)</span>

    <span class="s2">def </span><span class="s1">add_text(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">zip=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Appends a text chunk. 
 
        :param key: latin-1 encodable text key name 
        :param value: value for this key, text or an 
           :py:class:`PIL.PngImagePlugin.iTXt` instance 
        :param zip: compression flag 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">iTXt):</span>
            <span class="s2">return </span><span class="s1">self.add_itxt(key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">value.lang</span><span class="s2">, </span><span class="s1">value.tkey</span><span class="s2">, </span><span class="s1">zip=zip)</span>

        <span class="s0"># The tEXt chunk stores latin-1 text</span>
        <span class="s2">if not </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">value = value.encode(</span><span class="s5">&quot;latin-1&quot;</span><span class="s2">, </span><span class="s5">&quot;strict&quot;</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">UnicodeError:</span>
                <span class="s2">return </span><span class="s1">self.add_itxt(key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">zip=zip)</span>

        <span class="s2">if not </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s1">key = key.encode(</span><span class="s5">&quot;latin-1&quot;</span><span class="s2">, </span><span class="s5">&quot;strict&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">zip:</span>
            <span class="s1">self.add(</span><span class="s3">b&quot;zTXt&quot;</span><span class="s2">, </span><span class="s1">key + </span><span class="s3">b&quot;</span><span class="s2">\0\0</span><span class="s3">&quot; </span><span class="s1">+ zlib.compress(value))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.add(</span><span class="s3">b&quot;tEXt&quot;</span><span class="s2">, </span><span class="s1">key + </span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot; </span><span class="s1">+ value)</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># PNG image stream (IHDR/IEND)</span>


<span class="s2">class </span><span class="s1">PngStream(ChunkStream):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fp):</span>
        <span class="s1">super().__init__(fp)</span>

        <span class="s0"># local copies of Image attributes</span>
        <span class="s1">self.im_info = {}</span>
        <span class="s1">self.im_text = {}</span>
        <span class="s1">self.im_size = (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.im_mode = </span><span class="s2">None</span>
        <span class="s1">self.im_tile = </span><span class="s2">None</span>
        <span class="s1">self.im_palette = </span><span class="s2">None</span>
        <span class="s1">self.im_custom_mimetype = </span><span class="s2">None</span>
        <span class="s1">self.im_n_frames = </span><span class="s2">None</span>
        <span class="s1">self._seq_num = </span><span class="s2">None</span>
        <span class="s1">self.rewind_state = </span><span class="s2">None</span>

        <span class="s1">self.text_memory = </span><span class="s4">0</span>

    <span class="s2">def </span><span class="s1">check_text_memory(self</span><span class="s2">, </span><span class="s1">chunklen):</span>
        <span class="s1">self.text_memory += chunklen</span>
        <span class="s2">if </span><span class="s1">self.text_memory &gt; MAX_TEXT_MEMORY:</span>
            <span class="s1">msg = (</span>
                <span class="s5">&quot;Too much memory used in text chunks: &quot;</span>
                <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">self.text_memory</span><span class="s2">}</span><span class="s5">&gt;MAX_TEXT_MEMORY&quot;</span>
            <span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s2">def </span><span class="s1">save_rewind(self):</span>
        <span class="s1">self.rewind_state = {</span>
            <span class="s5">&quot;info&quot;</span><span class="s1">: self.im_info.copy()</span><span class="s2">,</span>
            <span class="s5">&quot;tile&quot;</span><span class="s1">: self.im_tile</span><span class="s2">,</span>
            <span class="s5">&quot;seq_num&quot;</span><span class="s1">: self._seq_num</span><span class="s2">,</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">rewind(self):</span>
        <span class="s1">self.im_info = self.rewind_state[</span><span class="s5">&quot;info&quot;</span><span class="s1">]</span>
        <span class="s1">self.im_tile = self.rewind_state[</span><span class="s5">&quot;tile&quot;</span><span class="s1">]</span>
        <span class="s1">self._seq_num = self.rewind_state[</span><span class="s5">&quot;seq_num&quot;</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">chunk_iCCP(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>

        <span class="s0"># ICC profile</span>
        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s0"># according to PNG spec, the iCCP chunk contains:</span>
        <span class="s0"># Profile name  1-79 bytes (character string)</span>
        <span class="s0"># Null separator        1 byte (null character)</span>
        <span class="s0"># Compression method    1 byte (0)</span>
        <span class="s0"># Compressed profile    n bytes (zlib with deflate compression)</span>
        <span class="s1">i = s.find(</span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">logger.debug(</span><span class="s5">&quot;iCCP profile name %r&quot;</span><span class="s2">, </span><span class="s1">s[:i])</span>
        <span class="s1">logger.debug(</span><span class="s5">&quot;Compression method %s&quot;</span><span class="s2">, </span><span class="s1">s[i])</span>
        <span class="s1">comp_method = s[i]</span>
        <span class="s2">if </span><span class="s1">comp_method != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s5">f&quot;Unknown compression method </span><span class="s2">{</span><span class="s1">comp_method</span><span class="s2">} </span><span class="s5">in iCCP chunk&quot;</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(msg)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">icc_profile = _safe_zlib_decompress(s[i + </span><span class="s4">2 </span><span class="s1">:])</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">if </span><span class="s1">ImageFile.LOAD_TRUNCATED_IMAGES:</span>
                <span class="s1">icc_profile = </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise</span>
        <span class="s2">except </span><span class="s1">zlib.error:</span>
            <span class="s1">icc_profile = </span><span class="s2">None  </span><span class="s0"># FIXME</span>
        <span class="s1">self.im_info[</span><span class="s5">&quot;icc_profile&quot;</span><span class="s1">] = icc_profile</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_IHDR(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>

        <span class="s0"># image header</span>
        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s2">if </span><span class="s1">length &lt; </span><span class="s4">13</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">ImageFile.LOAD_TRUNCATED_IMAGES:</span>
                <span class="s2">return </span><span class="s1">s</span>
            <span class="s1">msg = </span><span class="s5">&quot;Truncated IHDR chunk&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s1">self.im_size = i32(s</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">i32(s</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.im_mode</span><span class="s2">, </span><span class="s1">self.im_rawmode = _MODES[(s[</span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">s[</span><span class="s4">9</span><span class="s1">])]</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">pass</span>
        <span class="s2">if </span><span class="s1">s[</span><span class="s4">12</span><span class="s1">]:</span>
            <span class="s1">self.im_info[</span><span class="s5">&quot;interlace&quot;</span><span class="s1">] = </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">s[</span><span class="s4">11</span><span class="s1">]:</span>
            <span class="s1">msg = </span><span class="s5">&quot;unknown filter category&quot;</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(msg)</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_IDAT(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>

        <span class="s0"># image data</span>
        <span class="s2">if </span><span class="s5">&quot;bbox&quot; </span><span class="s2">in </span><span class="s1">self.im_info:</span>
            <span class="s1">tile = [(</span><span class="s5">&quot;zip&quot;</span><span class="s2">, </span><span class="s1">self.im_info[</span><span class="s5">&quot;bbox&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">self.im_rawmode)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.im_n_frames </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.im_info[</span><span class="s5">&quot;default_image&quot;</span><span class="s1">] = </span><span class="s2">True</span>
            <span class="s1">tile = [(</span><span class="s5">&quot;zip&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + self.im_size</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">self.im_rawmode)]</span>
        <span class="s1">self.im_tile = tile</span>
        <span class="s1">self.im_idat = length</span>
        <span class="s2">raise </span><span class="s1">EOFError</span>

    <span class="s2">def </span><span class="s1">chunk_IEND(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>

        <span class="s0"># end of PNG image</span>
        <span class="s2">raise </span><span class="s1">EOFError</span>

    <span class="s2">def </span><span class="s1">chunk_PLTE(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>

        <span class="s0"># palette</span>
        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s2">if </span><span class="s1">self.im_mode == </span><span class="s5">&quot;P&quot;</span><span class="s1">:</span>
            <span class="s1">self.im_palette = </span><span class="s5">&quot;RGB&quot;</span><span class="s2">, </span><span class="s1">s</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_tRNS(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>

        <span class="s0"># transparency</span>
        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s2">if </span><span class="s1">self.im_mode == </span><span class="s5">&quot;P&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">_simple_palette.match(s):</span>
                <span class="s0"># tRNS contains only one full-transparent entry,</span>
                <span class="s0"># other entries are full opaque</span>
                <span class="s1">i = s.find(</span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">self.im_info[</span><span class="s5">&quot;transparency&quot;</span><span class="s1">] = i</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># otherwise, we have a byte string with one alpha value</span>
                <span class="s0"># for each palette entry</span>
                <span class="s1">self.im_info[</span><span class="s5">&quot;transparency&quot;</span><span class="s1">] = s</span>
        <span class="s2">elif </span><span class="s1">self.im_mode </span><span class="s2">in </span><span class="s1">(</span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;L&quot;</span><span class="s2">, </span><span class="s5">&quot;I&quot;</span><span class="s1">):</span>
            <span class="s1">self.im_info[</span><span class="s5">&quot;transparency&quot;</span><span class="s1">] = i16(s)</span>
        <span class="s2">elif </span><span class="s1">self.im_mode == </span><span class="s5">&quot;RGB&quot;</span><span class="s1">:</span>
            <span class="s1">self.im_info[</span><span class="s5">&quot;transparency&quot;</span><span class="s1">] = i16(s)</span><span class="s2">, </span><span class="s1">i16(s</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">i16(s</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_gAMA(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s0"># gamma setting</span>
        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s1">self.im_info[</span><span class="s5">&quot;gamma&quot;</span><span class="s1">] = i32(s) / </span><span class="s4">100000.0</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_cHRM(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s0"># chromaticity, 8 unsigned ints, actual value is scaled by 100,000</span>
        <span class="s0"># WP x,y, Red x,y, Green x,y Blue x,y</span>

        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s1">raw_vals = struct.unpack(</span><span class="s5">&quot;&gt;%dI&quot; </span><span class="s1">% (len(s) // </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">s)</span>
        <span class="s1">self.im_info[</span><span class="s5">&quot;chromaticity&quot;</span><span class="s1">] = tuple(elt / </span><span class="s4">100000.0 </span><span class="s2">for </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">raw_vals)</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_sRGB(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s0"># srgb rendering intent, 1 byte</span>
        <span class="s0"># 0 perceptual</span>
        <span class="s0"># 1 relative colorimetric</span>
        <span class="s0"># 2 saturation</span>
        <span class="s0"># 3 absolute colorimetric</span>

        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s2">if </span><span class="s1">length &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">ImageFile.LOAD_TRUNCATED_IMAGES:</span>
                <span class="s2">return </span><span class="s1">s</span>
            <span class="s1">msg = </span><span class="s5">&quot;Truncated sRGB chunk&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s1">self.im_info[</span><span class="s5">&quot;srgb&quot;</span><span class="s1">] = s[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_pHYs(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>

        <span class="s0"># pixels per unit</span>
        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s2">if </span><span class="s1">length &lt; </span><span class="s4">9</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">ImageFile.LOAD_TRUNCATED_IMAGES:</span>
                <span class="s2">return </span><span class="s1">s</span>
            <span class="s1">msg = </span><span class="s5">&quot;Truncated pHYs chunk&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s1">px</span><span class="s2">, </span><span class="s1">py = i32(s</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">i32(s</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">unit = s[</span><span class="s4">8</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">unit == </span><span class="s4">1</span><span class="s1">:  </span><span class="s0"># meter</span>
            <span class="s1">dpi = px * </span><span class="s4">0.0254</span><span class="s2">, </span><span class="s1">py * </span><span class="s4">0.0254</span>
            <span class="s1">self.im_info[</span><span class="s5">&quot;dpi&quot;</span><span class="s1">] = dpi</span>
        <span class="s2">elif </span><span class="s1">unit == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.im_info[</span><span class="s5">&quot;aspect&quot;</span><span class="s1">] = px</span><span class="s2">, </span><span class="s1">py</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_tEXt(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>

        <span class="s0"># text</span>
        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">k</span><span class="s2">, </span><span class="s1">v = s.split(</span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s0"># fallback for broken tEXt tags</span>
            <span class="s1">k = s</span>
            <span class="s1">v = </span><span class="s3">b&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">k:</span>
            <span class="s1">k = k.decode(</span><span class="s5">&quot;latin-1&quot;</span><span class="s2">, </span><span class="s5">&quot;strict&quot;</span><span class="s1">)</span>
            <span class="s1">v_str = v.decode(</span><span class="s5">&quot;latin-1&quot;</span><span class="s2">, </span><span class="s5">&quot;replace&quot;</span><span class="s1">)</span>

            <span class="s1">self.im_info[k] = v </span><span class="s2">if </span><span class="s1">k == </span><span class="s5">&quot;exif&quot; </span><span class="s2">else </span><span class="s1">v_str</span>
            <span class="s1">self.im_text[k] = v_str</span>
            <span class="s1">self.check_text_memory(len(v_str))</span>

        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_zTXt(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>

        <span class="s0"># compressed text</span>
        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">k</span><span class="s2">, </span><span class="s1">v = s.split(</span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s1">k = s</span>
            <span class="s1">v = </span><span class="s3">b&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">v:</span>
            <span class="s1">comp_method = v[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">comp_method = </span><span class="s4">0</span>
        <span class="s2">if </span><span class="s1">comp_method != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s5">f&quot;Unknown compression method </span><span class="s2">{</span><span class="s1">comp_method</span><span class="s2">} </span><span class="s5">in zTXt chunk&quot;</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(msg)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">v = _safe_zlib_decompress(v[</span><span class="s4">1</span><span class="s1">:])</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">if </span><span class="s1">ImageFile.LOAD_TRUNCATED_IMAGES:</span>
                <span class="s1">v = </span><span class="s3">b&quot;&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise</span>
        <span class="s2">except </span><span class="s1">zlib.error:</span>
            <span class="s1">v = </span><span class="s3">b&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">k:</span>
            <span class="s1">k = k.decode(</span><span class="s5">&quot;latin-1&quot;</span><span class="s2">, </span><span class="s5">&quot;strict&quot;</span><span class="s1">)</span>
            <span class="s1">v = v.decode(</span><span class="s5">&quot;latin-1&quot;</span><span class="s2">, </span><span class="s5">&quot;replace&quot;</span><span class="s1">)</span>

            <span class="s1">self.im_info[k] = self.im_text[k] = v</span>
            <span class="s1">self.check_text_memory(len(v))</span>

        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_iTXt(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>

        <span class="s0"># international text</span>
        <span class="s1">r = s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">k</span><span class="s2">, </span><span class="s1">r = r.split(</span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s2">if </span><span class="s1">len(r) &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s1">cf</span><span class="s2">, </span><span class="s1">cm</span><span class="s2">, </span><span class="s1">r = r[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">r[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">r[</span><span class="s4">2</span><span class="s1">:]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">lang</span><span class="s2">, </span><span class="s1">tk</span><span class="s2">, </span><span class="s1">v = r.split(</span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s2">if </span><span class="s1">cf != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">cm == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">v = _safe_zlib_decompress(v)</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s2">if </span><span class="s1">ImageFile.LOAD_TRUNCATED_IMAGES:</span>
                        <span class="s2">return </span><span class="s1">s</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">raise</span>
                <span class="s2">except </span><span class="s1">zlib.error:</span>
                    <span class="s2">return </span><span class="s1">s</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">s</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">k = k.decode(</span><span class="s5">&quot;latin-1&quot;</span><span class="s2">, </span><span class="s5">&quot;strict&quot;</span><span class="s1">)</span>
            <span class="s1">lang = lang.decode(</span><span class="s5">&quot;utf-8&quot;</span><span class="s2">, </span><span class="s5">&quot;strict&quot;</span><span class="s1">)</span>
            <span class="s1">tk = tk.decode(</span><span class="s5">&quot;utf-8&quot;</span><span class="s2">, </span><span class="s5">&quot;strict&quot;</span><span class="s1">)</span>
            <span class="s1">v = v.decode(</span><span class="s5">&quot;utf-8&quot;</span><span class="s2">, </span><span class="s5">&quot;strict&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">UnicodeError:</span>
            <span class="s2">return </span><span class="s1">s</span>

        <span class="s1">self.im_info[k] = self.im_text[k] = iTXt(v</span><span class="s2">, </span><span class="s1">lang</span><span class="s2">, </span><span class="s1">tk)</span>
        <span class="s1">self.check_text_memory(len(v))</span>

        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_eXIf(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s1">self.im_info[</span><span class="s5">&quot;exif&quot;</span><span class="s1">] = </span><span class="s3">b&quot;Exif</span><span class="s2">\x00\x00</span><span class="s3">&quot; </span><span class="s1">+ s</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s0"># APNG chunks</span>
    <span class="s2">def </span><span class="s1">chunk_acTL(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s2">if </span><span class="s1">length &lt; </span><span class="s4">8</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">ImageFile.LOAD_TRUNCATED_IMAGES:</span>
                <span class="s2">return </span><span class="s1">s</span>
            <span class="s1">msg = </span><span class="s5">&quot;APNG contains truncated acTL chunk&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s2">if </span><span class="s1">self.im_n_frames </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.im_n_frames = </span><span class="s2">None</span>
            <span class="s1">warnings.warn(</span><span class="s5">&quot;Invalid APNG, will use default PNG image if possible&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s1">n_frames = i32(s)</span>
        <span class="s2">if </span><span class="s1">n_frames == </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">n_frames &gt; </span><span class="s4">0x80000000</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s5">&quot;Invalid APNG, will use default PNG image if possible&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s1">self.im_n_frames = n_frames</span>
        <span class="s1">self.im_info[</span><span class="s5">&quot;loop&quot;</span><span class="s1">] = i32(s</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">self.im_custom_mimetype = </span><span class="s5">&quot;image/apng&quot;</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_fcTL(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s2">if </span><span class="s1">length &lt; </span><span class="s4">26</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">ImageFile.LOAD_TRUNCATED_IMAGES:</span>
                <span class="s2">return </span><span class="s1">s</span>
            <span class="s1">msg = </span><span class="s5">&quot;APNG contains truncated fcTL chunk&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s1">seq = i32(s)</span>
        <span class="s2">if </span><span class="s1">(self._seq_num </span><span class="s2">is None and </span><span class="s1">seq != </span><span class="s4">0</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(</span>
            <span class="s1">self._seq_num </span><span class="s2">is not None and </span><span class="s1">self._seq_num != seq - </span><span class="s4">1</span>
        <span class="s1">):</span>
            <span class="s1">msg = </span><span class="s5">&quot;APNG contains frame sequence errors&quot;</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(msg)</span>
        <span class="s1">self._seq_num = seq</span>
        <span class="s1">width</span><span class="s2">, </span><span class="s1">height = i32(s</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">i32(s</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">px</span><span class="s2">, </span><span class="s1">py = i32(s</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)</span><span class="s2">, </span><span class="s1">i32(s</span><span class="s2">, </span><span class="s4">16</span><span class="s1">)</span>
        <span class="s1">im_w</span><span class="s2">, </span><span class="s1">im_h = self.im_size</span>
        <span class="s2">if </span><span class="s1">px + width &gt; im_w </span><span class="s2">or </span><span class="s1">py + height &gt; im_h:</span>
            <span class="s1">msg = </span><span class="s5">&quot;APNG contains invalid frames&quot;</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(msg)</span>
        <span class="s1">self.im_info[</span><span class="s5">&quot;bbox&quot;</span><span class="s1">] = (px</span><span class="s2">, </span><span class="s1">py</span><span class="s2">, </span><span class="s1">px + width</span><span class="s2">, </span><span class="s1">py + height)</span>
        <span class="s1">delay_num</span><span class="s2">, </span><span class="s1">delay_den = i16(s</span><span class="s2">, </span><span class="s4">20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">i16(s</span><span class="s2">, </span><span class="s4">22</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">delay_den == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">delay_den = </span><span class="s4">100</span>
        <span class="s1">self.im_info[</span><span class="s5">&quot;duration&quot;</span><span class="s1">] = float(delay_num) / float(delay_den) * </span><span class="s4">1000</span>
        <span class="s1">self.im_info[</span><span class="s5">&quot;disposal&quot;</span><span class="s1">] = s[</span><span class="s4">24</span><span class="s1">]</span>
        <span class="s1">self.im_info[</span><span class="s5">&quot;blend&quot;</span><span class="s1">] = s[</span><span class="s4">25</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">chunk_fdAT(self</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s2">if </span><span class="s1">length &lt; </span><span class="s4">4</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">ImageFile.LOAD_TRUNCATED_IMAGES:</span>
                <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
                <span class="s2">return </span><span class="s1">s</span>
            <span class="s1">msg = </span><span class="s5">&quot;APNG contains truncated fDAT chunk&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">seq = i32(s)</span>
        <span class="s2">if </span><span class="s1">self._seq_num != seq - </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s5">&quot;APNG contains frame sequence errors&quot;</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(msg)</span>
        <span class="s1">self._seq_num = seq</span>
        <span class="s2">return </span><span class="s1">self.chunk_IDAT(pos + </span><span class="s4">4</span><span class="s2">, </span><span class="s1">length - </span><span class="s4">4</span><span class="s1">)</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># PNG reader</span>


<span class="s2">def </span><span class="s1">_accept(prefix):</span>
    <span class="s2">return </span><span class="s1">prefix[:</span><span class="s4">8</span><span class="s1">] == _MAGIC</span>


<span class="s0">##</span>
<span class="s0"># Image plugin for PNG images.</span>


<span class="s2">class </span><span class="s1">PngImageFile(ImageFile.ImageFile):</span>

    <span class="s1">format = </span><span class="s5">&quot;PNG&quot;</span>
    <span class="s1">format_description = </span><span class="s5">&quot;Portable network graphics&quot;</span>

    <span class="s2">def </span><span class="s1">_open(self):</span>

        <span class="s2">if not </span><span class="s1">_accept(self.fp.read(</span><span class="s4">8</span><span class="s1">)):</span>
            <span class="s1">msg = </span><span class="s5">&quot;not a PNG file&quot;</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(msg)</span>
        <span class="s1">self._fp = self.fp</span>
        <span class="s1">self.__frame = </span><span class="s4">0</span>

        <span class="s0">#</span>
        <span class="s0"># Parse headers up to the first IDAT or fDAT chunk</span>

        <span class="s1">self.private_chunks = []</span>
        <span class="s1">self.png = PngStream(self.fp)</span>

        <span class="s2">while True</span><span class="s1">:</span>

            <span class="s0">#</span>
            <span class="s0"># get next chunk</span>

            <span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length = self.png.read()</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">s = self.png.call(cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length)</span>
            <span class="s2">except </span><span class="s1">EOFError:</span>
                <span class="s2">break</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s1">logger.debug(</span><span class="s5">&quot;%r %s %s (unknown)&quot;</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length)</span>
                <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
                <span class="s2">if </span><span class="s1">cid[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">2</span><span class="s1">].islower():</span>
                    <span class="s1">self.private_chunks.append((cid</span><span class="s2">, </span><span class="s1">s))</span>

            <span class="s1">self.png.crc(cid</span><span class="s2">, </span><span class="s1">s)</span>

        <span class="s0">#</span>
        <span class="s0"># Copy relevant attributes from the PngStream.  An alternative</span>
        <span class="s0"># would be to let the PngStream class modify these attributes</span>
        <span class="s0"># directly, but that introduces circular references which are</span>
        <span class="s0"># difficult to break if things go wrong in the decoder...</span>
        <span class="s0"># (believe me, I've tried ;-)</span>

        <span class="s1">self.mode = self.png.im_mode</span>
        <span class="s1">self._size = self.png.im_size</span>
        <span class="s1">self.info = self.png.im_info</span>
        <span class="s1">self._text = </span><span class="s2">None</span>
        <span class="s1">self.tile = self.png.im_tile</span>
        <span class="s1">self.custom_mimetype = self.png.im_custom_mimetype</span>
        <span class="s1">self.n_frames = self.png.im_n_frames </span><span class="s2">or </span><span class="s4">1</span>
        <span class="s1">self.default_image = self.info.get(</span><span class="s5">&quot;default_image&quot;</span><span class="s2">, False</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.png.im_palette:</span>
            <span class="s1">rawmode</span><span class="s2">, </span><span class="s1">data = self.png.im_palette</span>
            <span class="s1">self.palette = ImagePalette.raw(rawmode</span><span class="s2">, </span><span class="s1">data)</span>

        <span class="s2">if </span><span class="s1">cid == </span><span class="s3">b&quot;fdAT&quot;</span><span class="s1">:</span>
            <span class="s1">self.__prepare_idat = length - </span><span class="s4">4</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.__prepare_idat = length  </span><span class="s0"># used by load_prepare()</span>

        <span class="s2">if </span><span class="s1">self.png.im_n_frames </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._close_exclusive_fp_after_loading = </span><span class="s2">False</span>
            <span class="s1">self.png.save_rewind()</span>
            <span class="s1">self.__rewind_idat = self.__prepare_idat</span>
            <span class="s1">self.__rewind = self._fp.tell()</span>
            <span class="s2">if </span><span class="s1">self.default_image:</span>
                <span class="s0"># IDAT chunk contains default image and not first animation frame</span>
                <span class="s1">self.n_frames += </span><span class="s4">1</span>
            <span class="s1">self._seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.is_animated = self.n_frames &gt; </span><span class="s4">1</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">text(self):</span>
        <span class="s0"># experimental</span>
        <span class="s2">if </span><span class="s1">self._text </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># iTxt, tEXt and zTXt chunks may appear at the end of the file</span>
            <span class="s0"># So load the file to ensure that they are read</span>
            <span class="s2">if </span><span class="s1">self.is_animated:</span>
                <span class="s1">frame = self.__frame</span>
                <span class="s0"># for APNG, seek to the final frame before loading</span>
                <span class="s1">self.seek(self.n_frames - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">self.load()</span>
            <span class="s2">if </span><span class="s1">self.is_animated:</span>
                <span class="s1">self.seek(frame)</span>
        <span class="s2">return </span><span class="s1">self._text</span>

    <span class="s2">def </span><span class="s1">verify(self):</span>
        <span class="s6">&quot;&quot;&quot;Verify PNG file&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.fp </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s5">&quot;verify must be called directly after open&quot;</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(msg)</span>

        <span class="s0"># back up to beginning of IDAT block</span>
        <span class="s1">self.fp.seek(self.tile[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">2</span><span class="s1">] - </span><span class="s4">8</span><span class="s1">)</span>

        <span class="s1">self.png.verify()</span>
        <span class="s1">self.png.close()</span>

        <span class="s2">if </span><span class="s1">self._exclusive_fp:</span>
            <span class="s1">self.fp.close()</span>
        <span class="s1">self.fp = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">seek(self</span><span class="s2">, </span><span class="s1">frame):</span>
        <span class="s2">if not </span><span class="s1">self._seek_check(frame):</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">frame &lt; self.__frame:</span>
            <span class="s1">self._seek(</span><span class="s4">0</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">last_frame = self.__frame</span>
        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">range(self.__frame + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">frame + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self._seek(f)</span>
            <span class="s2">except </span><span class="s1">EOFError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">self.seek(last_frame)</span>
                <span class="s1">msg = </span><span class="s5">&quot;no more images in APNG file&quot;</span>
                <span class="s2">raise </span><span class="s1">EOFError(msg) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">def </span><span class="s1">_seek(self</span><span class="s2">, </span><span class="s1">frame</span><span class="s2">, </span><span class="s1">rewind=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">frame == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">rewind:</span>
                <span class="s1">self._fp.seek(self.__rewind)</span>
                <span class="s1">self.png.rewind()</span>
                <span class="s1">self.__prepare_idat = self.__rewind_idat</span>
                <span class="s1">self.im = </span><span class="s2">None</span>
                <span class="s2">if </span><span class="s1">self.pyaccess:</span>
                    <span class="s1">self.pyaccess = </span><span class="s2">None</span>
                <span class="s1">self.info = self.png.im_info</span>
                <span class="s1">self.tile = self.png.im_tile</span>
                <span class="s1">self.fp = self._fp</span>
            <span class="s1">self._prev_im = </span><span class="s2">None</span>
            <span class="s1">self.dispose = </span><span class="s2">None</span>
            <span class="s1">self.default_image = self.info.get(</span><span class="s5">&quot;default_image&quot;</span><span class="s2">, False</span><span class="s1">)</span>
            <span class="s1">self.dispose_op = self.info.get(</span><span class="s5">&quot;disposal&quot;</span><span class="s1">)</span>
            <span class="s1">self.blend_op = self.info.get(</span><span class="s5">&quot;blend&quot;</span><span class="s1">)</span>
            <span class="s1">self.dispose_extent = self.info.get(</span><span class="s5">&quot;bbox&quot;</span><span class="s1">)</span>
            <span class="s1">self.__frame = </span><span class="s4">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">frame != self.__frame + </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s5">f&quot;cannot seek to frame </span><span class="s2">{</span><span class="s1">frame</span><span class="s2">}</span><span class="s5">&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

            <span class="s0"># ensure previous frame was loaded</span>
            <span class="s1">self.load()</span>

            <span class="s2">if </span><span class="s1">self.dispose:</span>
                <span class="s1">self.im.paste(self.dispose</span><span class="s2">, </span><span class="s1">self.dispose_extent)</span>
            <span class="s1">self._prev_im = self.im.copy()</span>

            <span class="s1">self.fp = self._fp</span>

            <span class="s0"># advance to the next frame</span>
            <span class="s2">if </span><span class="s1">self.__prepare_idat:</span>
                <span class="s1">ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">self.__prepare_idat)</span>
                <span class="s1">self.__prepare_idat = </span><span class="s4">0</span>
            <span class="s1">frame_start = </span><span class="s2">False</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s1">self.fp.read(</span><span class="s4">4</span><span class="s1">)  </span><span class="s0"># CRC</span>

                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length = self.png.read()</span>
                <span class="s2">except </span><span class="s1">(struct.error</span><span class="s2">, </span><span class="s1">SyntaxError):</span>
                    <span class="s2">break</span>

                <span class="s2">if </span><span class="s1">cid == </span><span class="s3">b&quot;IEND&quot;</span><span class="s1">:</span>
                    <span class="s1">msg = </span><span class="s5">&quot;No more images in APNG file&quot;</span>
                    <span class="s2">raise </span><span class="s1">EOFError(msg)</span>
                <span class="s2">if </span><span class="s1">cid == </span><span class="s3">b&quot;fcTL&quot;</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">frame_start:</span>
                        <span class="s0"># there must be at least one fdAT chunk between fcTL chunks</span>
                        <span class="s1">msg = </span><span class="s5">&quot;APNG missing frame data&quot;</span>
                        <span class="s2">raise </span><span class="s1">SyntaxError(msg)</span>
                    <span class="s1">frame_start = </span><span class="s2">True</span>

                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">self.png.call(cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length)</span>
                <span class="s2">except </span><span class="s1">UnicodeDecodeError:</span>
                    <span class="s2">break</span>
                <span class="s2">except </span><span class="s1">EOFError:</span>
                    <span class="s2">if </span><span class="s1">cid == </span><span class="s3">b&quot;fdAT&quot;</span><span class="s1">:</span>
                        <span class="s1">length -= </span><span class="s4">4</span>
                        <span class="s2">if </span><span class="s1">frame_start:</span>
                            <span class="s1">self.__prepare_idat = length</span>
                            <span class="s2">break</span>
                    <span class="s1">ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
                <span class="s2">except </span><span class="s1">AttributeError:</span>
                    <span class="s1">logger.debug(</span><span class="s5">&quot;%r %s %s (unknown)&quot;</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length)</span>
                    <span class="s1">ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>

            <span class="s1">self.__frame = frame</span>
            <span class="s1">self.tile = self.png.im_tile</span>
            <span class="s1">self.dispose_op = self.info.get(</span><span class="s5">&quot;disposal&quot;</span><span class="s1">)</span>
            <span class="s1">self.blend_op = self.info.get(</span><span class="s5">&quot;blend&quot;</span><span class="s1">)</span>
            <span class="s1">self.dispose_extent = self.info.get(</span><span class="s5">&quot;bbox&quot;</span><span class="s1">)</span>

            <span class="s2">if not </span><span class="s1">self.tile:</span>
                <span class="s2">raise </span><span class="s1">EOFError</span>

        <span class="s0"># setup frame disposal (actual disposal done when needed in the next _seek())</span>
        <span class="s2">if </span><span class="s1">self._prev_im </span><span class="s2">is None and </span><span class="s1">self.dispose_op == Disposal.OP_PREVIOUS:</span>
            <span class="s1">self.dispose_op = Disposal.OP_BACKGROUND</span>

        <span class="s2">if </span><span class="s1">self.dispose_op == Disposal.OP_PREVIOUS:</span>
            <span class="s1">self.dispose = self._prev_im.copy()</span>
            <span class="s1">self.dispose = self._crop(self.dispose</span><span class="s2">, </span><span class="s1">self.dispose_extent)</span>
        <span class="s2">elif </span><span class="s1">self.dispose_op == Disposal.OP_BACKGROUND:</span>
            <span class="s1">self.dispose = Image.core.fill(self.mode</span><span class="s2">, </span><span class="s1">self.size)</span>
            <span class="s1">self.dispose = self._crop(self.dispose</span><span class="s2">, </span><span class="s1">self.dispose_extent)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.dispose = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">tell(self):</span>
        <span class="s2">return </span><span class="s1">self.__frame</span>

    <span class="s2">def </span><span class="s1">load_prepare(self):</span>
        <span class="s6">&quot;&quot;&quot;internal: prepare to read PNG file&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.info.get(</span><span class="s5">&quot;interlace&quot;</span><span class="s1">):</span>
            <span class="s1">self.decoderconfig = self.decoderconfig + (</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span>

        <span class="s1">self.__idat = self.__prepare_idat  </span><span class="s0"># used by load_read()</span>
        <span class="s1">ImageFile.ImageFile.load_prepare(self)</span>

    <span class="s2">def </span><span class="s1">load_read(self</span><span class="s2">, </span><span class="s1">read_bytes):</span>
        <span class="s6">&quot;&quot;&quot;internal: read more image data&quot;&quot;&quot;</span>

        <span class="s2">while </span><span class="s1">self.__idat == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># end of chunk, skip forward to next one</span>

            <span class="s1">self.fp.read(</span><span class="s4">4</span><span class="s1">)  </span><span class="s0"># CRC</span>

            <span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length = self.png.read()</span>

            <span class="s2">if </span><span class="s1">cid </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">b&quot;IDAT&quot;</span><span class="s2">, </span><span class="s3">b&quot;DDAT&quot;</span><span class="s2">, </span><span class="s3">b&quot;fdAT&quot;</span><span class="s1">]:</span>
                <span class="s1">self.png.push(cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length)</span>
                <span class="s2">return </span><span class="s3">b&quot;&quot;</span>

            <span class="s2">if </span><span class="s1">cid == </span><span class="s3">b&quot;fdAT&quot;</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">self.png.call(cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length)</span>
                <span class="s2">except </span><span class="s1">EOFError:</span>
                    <span class="s2">pass</span>
                <span class="s1">self.__idat = length - </span><span class="s4">4  </span><span class="s0"># sequence_num has already been read</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.__idat = length  </span><span class="s0"># empty chunks are allowed</span>

        <span class="s0"># read more data from this chunk</span>
        <span class="s2">if </span><span class="s1">read_bytes &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">read_bytes = self.__idat</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">read_bytes = min(read_bytes</span><span class="s2">, </span><span class="s1">self.__idat)</span>

        <span class="s1">self.__idat = self.__idat - read_bytes</span>

        <span class="s2">return </span><span class="s1">self.fp.read(read_bytes)</span>

    <span class="s2">def </span><span class="s1">load_end(self):</span>
        <span class="s6">&quot;&quot;&quot;internal: finished reading image data&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.__idat != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.fp.read(self.__idat)</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">self.fp.read(</span><span class="s4">4</span><span class="s1">)  </span><span class="s0"># CRC</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length = self.png.read()</span>
            <span class="s2">except </span><span class="s1">(struct.error</span><span class="s2">, </span><span class="s1">SyntaxError):</span>
                <span class="s2">break</span>

            <span class="s2">if </span><span class="s1">cid == </span><span class="s3">b&quot;IEND&quot;</span><span class="s1">:</span>
                <span class="s2">break</span>
            <span class="s2">elif </span><span class="s1">cid == </span><span class="s3">b&quot;fcTL&quot; </span><span class="s2">and </span><span class="s1">self.is_animated:</span>
                <span class="s0"># start of the next frame, stop reading</span>
                <span class="s1">self.__prepare_idat = </span><span class="s4">0</span>
                <span class="s1">self.png.push(cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length)</span>
                <span class="s2">break</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.png.call(cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length)</span>
            <span class="s2">except </span><span class="s1">UnicodeDecodeError:</span>
                <span class="s2">break</span>
            <span class="s2">except </span><span class="s1">EOFError:</span>
                <span class="s2">if </span><span class="s1">cid == </span><span class="s3">b&quot;fdAT&quot;</span><span class="s1">:</span>
                    <span class="s1">length -= </span><span class="s4">4</span>
                <span class="s1">ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s1">logger.debug(</span><span class="s5">&quot;%r %s %s (unknown)&quot;</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">length)</span>
                <span class="s1">s = ImageFile._safe_read(self.fp</span><span class="s2">, </span><span class="s1">length)</span>
                <span class="s2">if </span><span class="s1">cid[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">2</span><span class="s1">].islower():</span>
                    <span class="s1">self.private_chunks.append((cid</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, True</span><span class="s1">))</span>
        <span class="s1">self._text = self.png.im_text</span>
        <span class="s2">if not </span><span class="s1">self.is_animated:</span>
            <span class="s1">self.png.close()</span>
            <span class="s1">self.png = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self._prev_im </span><span class="s2">and </span><span class="s1">self.blend_op == Blend.OP_OVER:</span>
                <span class="s1">updated = self._crop(self.im</span><span class="s2">, </span><span class="s1">self.dispose_extent)</span>
                <span class="s1">self._prev_im.paste(</span>
                    <span class="s1">updated</span><span class="s2">, </span><span class="s1">self.dispose_extent</span><span class="s2">, </span><span class="s1">updated.convert(</span><span class="s5">&quot;RGBA&quot;</span><span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">self.im = self._prev_im</span>
                <span class="s2">if </span><span class="s1">self.pyaccess:</span>
                    <span class="s1">self.pyaccess = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_getexif(self):</span>
        <span class="s2">if </span><span class="s5">&quot;exif&quot; </span><span class="s2">not in </span><span class="s1">self.info:</span>
            <span class="s1">self.load()</span>
        <span class="s2">if </span><span class="s5">&quot;exif&quot; </span><span class="s2">not in </span><span class="s1">self.info </span><span class="s2">and </span><span class="s5">&quot;Raw profile type exif&quot; </span><span class="s2">not in </span><span class="s1">self.info:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">self.getexif()._get_merged_dict()</span>

    <span class="s2">def </span><span class="s1">getexif(self):</span>
        <span class="s2">if </span><span class="s5">&quot;exif&quot; </span><span class="s2">not in </span><span class="s1">self.info:</span>
            <span class="s1">self.load()</span>

        <span class="s2">return </span><span class="s1">super().getexif()</span>

    <span class="s2">def </span><span class="s1">getxmp(self):</span>
        <span class="s6">&quot;&quot;&quot; 
        Returns a dictionary containing the XMP tags. 
        Requires defusedxml to be installed. 
 
        :returns: XMP tags in a dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self._getxmp(self.info[</span><span class="s5">&quot;XML:com.adobe.xmp&quot;</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s5">&quot;XML:com.adobe.xmp&quot; </span><span class="s2">in </span><span class="s1">self.info</span>
            <span class="s2">else </span><span class="s1">{}</span>
        <span class="s1">)</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># PNG writer</span>

<span class="s1">_OUTMODES = {</span>
    <span class="s0"># supported PIL modes, and corresponding rawmodes/bits/color combinations</span>
    <span class="s5">&quot;1&quot;</span><span class="s1">: (</span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x01\x00</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;L;1&quot;</span><span class="s1">: (</span><span class="s5">&quot;L;1&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x01\x00</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;L;2&quot;</span><span class="s1">: (</span><span class="s5">&quot;L;2&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x02\x00</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;L;4&quot;</span><span class="s1">: (</span><span class="s5">&quot;L;4&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x04\x00</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;L&quot;</span><span class="s1">: (</span><span class="s5">&quot;L&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x08\x00</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;LA&quot;</span><span class="s1">: (</span><span class="s5">&quot;LA&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x08\x04</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;I&quot;</span><span class="s1">: (</span><span class="s5">&quot;I;16B&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x10\x00</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;I;16&quot;</span><span class="s1">: (</span><span class="s5">&quot;I;16B&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x10\x00</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;P;1&quot;</span><span class="s1">: (</span><span class="s5">&quot;P;1&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x01\x03</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;P;2&quot;</span><span class="s1">: (</span><span class="s5">&quot;P;2&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x02\x03</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;P;4&quot;</span><span class="s1">: (</span><span class="s5">&quot;P;4&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x04\x03</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;P&quot;</span><span class="s1">: (</span><span class="s5">&quot;P&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x08\x03</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;RGB&quot;</span><span class="s1">: (</span><span class="s5">&quot;RGB&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x08\x02</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s5">&quot;RGBA&quot;</span><span class="s1">: (</span><span class="s5">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s3">b&quot;</span><span class="s2">\x08\x06</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">putchunk(fp</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">*data):</span>
    <span class="s6">&quot;&quot;&quot;Write a PNG chunk (including CRC field)&quot;&quot;&quot;</span>

    <span class="s1">data = </span><span class="s3">b&quot;&quot;</span><span class="s1">.join(data)</span>

    <span class="s1">fp.write(o32(len(data)) + cid)</span>
    <span class="s1">fp.write(data)</span>
    <span class="s1">crc = _crc32(data</span><span class="s2">, </span><span class="s1">_crc32(cid))</span>
    <span class="s1">fp.write(o32(crc))</span>


<span class="s2">class </span><span class="s1">_idat:</span>
    <span class="s0"># wrap output from the encoder in IDAT chunks</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">chunk):</span>
        <span class="s1">self.fp = fp</span>
        <span class="s1">self.chunk = chunk</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">self.chunk(self.fp</span><span class="s2">, </span><span class="s3">b&quot;IDAT&quot;</span><span class="s2">, </span><span class="s1">data)</span>


<span class="s2">class </span><span class="s1">_fdat:</span>
    <span class="s0"># wrap encoder output in fdAT chunks</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">chunk</span><span class="s2">, </span><span class="s1">seq_num):</span>
        <span class="s1">self.fp = fp</span>
        <span class="s1">self.chunk = chunk</span>
        <span class="s1">self.seq_num = seq_num</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">self.chunk(self.fp</span><span class="s2">, </span><span class="s3">b&quot;fdAT&quot;</span><span class="s2">, </span><span class="s1">o32(self.seq_num)</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s1">self.seq_num += </span><span class="s4">1</span>


<span class="s2">def </span><span class="s1">_write_multiple_frames(im</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">chunk</span><span class="s2">, </span><span class="s1">rawmode</span><span class="s2">, </span><span class="s1">default_image</span><span class="s2">, </span><span class="s1">append_images):</span>
    <span class="s1">duration = im.encoderinfo.get(</span><span class="s5">&quot;duration&quot;</span><span class="s2">, </span><span class="s1">im.info.get(</span><span class="s5">&quot;duration&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">loop = im.encoderinfo.get(</span><span class="s5">&quot;loop&quot;</span><span class="s2">, </span><span class="s1">im.info.get(</span><span class="s5">&quot;loop&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">disposal = im.encoderinfo.get(</span><span class="s5">&quot;disposal&quot;</span><span class="s2">, </span><span class="s1">im.info.get(</span><span class="s5">&quot;disposal&quot;</span><span class="s2">, </span><span class="s1">Disposal.OP_NONE))</span>
    <span class="s1">blend = im.encoderinfo.get(</span><span class="s5">&quot;blend&quot;</span><span class="s2">, </span><span class="s1">im.info.get(</span><span class="s5">&quot;blend&quot;</span><span class="s2">, </span><span class="s1">Blend.OP_SOURCE))</span>

    <span class="s2">if </span><span class="s1">default_image:</span>
        <span class="s1">chain = itertools.chain(append_images)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">chain = itertools.chain([im]</span><span class="s2">, </span><span class="s1">append_images)</span>

    <span class="s1">im_frames = []</span>
    <span class="s1">frame_count = </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s1">im_seq </span><span class="s2">in </span><span class="s1">chain:</span>
        <span class="s2">for </span><span class="s1">im_frame </span><span class="s2">in </span><span class="s1">ImageSequence.Iterator(im_seq):</span>
            <span class="s2">if </span><span class="s1">im_frame.mode == rawmode:</span>
                <span class="s1">im_frame = im_frame.copy()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">rawmode == </span><span class="s5">&quot;P&quot;</span><span class="s1">:</span>
                    <span class="s1">im_frame = im_frame.convert(rawmode</span><span class="s2">, </span><span class="s1">palette=im.palette)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">im_frame = im_frame.convert(rawmode)</span>
            <span class="s1">encoderinfo = im.encoderinfo.copy()</span>
            <span class="s2">if </span><span class="s1">isinstance(duration</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
                <span class="s1">encoderinfo[</span><span class="s5">&quot;duration&quot;</span><span class="s1">] = duration[frame_count]</span>
            <span class="s2">if </span><span class="s1">isinstance(disposal</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
                <span class="s1">encoderinfo[</span><span class="s5">&quot;disposal&quot;</span><span class="s1">] = disposal[frame_count]</span>
            <span class="s2">if </span><span class="s1">isinstance(blend</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
                <span class="s1">encoderinfo[</span><span class="s5">&quot;blend&quot;</span><span class="s1">] = blend[frame_count]</span>
            <span class="s1">frame_count += </span><span class="s4">1</span>

            <span class="s2">if </span><span class="s1">im_frames:</span>
                <span class="s1">previous = im_frames[-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">prev_disposal = previous[</span><span class="s5">&quot;encoderinfo&quot;</span><span class="s1">].get(</span><span class="s5">&quot;disposal&quot;</span><span class="s1">)</span>
                <span class="s1">prev_blend = previous[</span><span class="s5">&quot;encoderinfo&quot;</span><span class="s1">].get(</span><span class="s5">&quot;blend&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">prev_disposal == Disposal.OP_PREVIOUS </span><span class="s2">and </span><span class="s1">len(im_frames) &lt; </span><span class="s4">2</span><span class="s1">:</span>
                    <span class="s1">prev_disposal = Disposal.OP_BACKGROUND</span>

                <span class="s2">if </span><span class="s1">prev_disposal == Disposal.OP_BACKGROUND:</span>
                    <span class="s1">base_im = previous[</span><span class="s5">&quot;im&quot;</span><span class="s1">].copy()</span>
                    <span class="s1">dispose = Image.core.fill(</span><span class="s5">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s1">im.size</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
                    <span class="s1">bbox = previous[</span><span class="s5">&quot;bbox&quot;</span><span class="s1">]</span>
                    <span class="s2">if </span><span class="s1">bbox:</span>
                        <span class="s1">dispose = dispose.crop(bbox)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">bbox = (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + im.size</span>
                    <span class="s1">base_im.paste(dispose</span><span class="s2">, </span><span class="s1">bbox)</span>
                <span class="s2">elif </span><span class="s1">prev_disposal == Disposal.OP_PREVIOUS:</span>
                    <span class="s1">base_im = im_frames[-</span><span class="s4">2</span><span class="s1">][</span><span class="s5">&quot;im&quot;</span><span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">base_im = previous[</span><span class="s5">&quot;im&quot;</span><span class="s1">]</span>
                <span class="s1">delta = ImageChops.subtract_modulo(</span>
                    <span class="s1">im_frame.convert(</span><span class="s5">&quot;RGB&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">base_im.convert(</span><span class="s5">&quot;RGB&quot;</span><span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">bbox = delta.getbbox()</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s2">not </span><span class="s1">bbox</span>
                    <span class="s2">and </span><span class="s1">prev_disposal == encoderinfo.get(</span><span class="s5">&quot;disposal&quot;</span><span class="s1">)</span>
                    <span class="s2">and </span><span class="s1">prev_blend == encoderinfo.get(</span><span class="s5">&quot;blend&quot;</span><span class="s1">)</span>
                <span class="s1">):</span>
                    <span class="s2">if </span><span class="s1">isinstance(duration</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
                        <span class="s1">previous[</span><span class="s5">&quot;encoderinfo&quot;</span><span class="s1">][</span><span class="s5">&quot;duration&quot;</span><span class="s1">] += encoderinfo[</span><span class="s5">&quot;duration&quot;</span><span class="s1">]</span>
                    <span class="s2">continue</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">bbox = </span><span class="s2">None</span>
            <span class="s1">im_frames.append({</span><span class="s5">&quot;im&quot;</span><span class="s1">: im_frame</span><span class="s2">, </span><span class="s5">&quot;bbox&quot;</span><span class="s1">: bbox</span><span class="s2">, </span><span class="s5">&quot;encoderinfo&quot;</span><span class="s1">: encoderinfo})</span>

    <span class="s0"># animation control</span>
    <span class="s1">chunk(</span>
        <span class="s1">fp</span><span class="s2">,</span>
        <span class="s3">b&quot;acTL&quot;</span><span class="s2">,</span>
        <span class="s1">o32(len(im_frames))</span><span class="s2">,  </span><span class="s0"># 0: num_frames</span>
        <span class="s1">o32(loop)</span><span class="s2">,  </span><span class="s0"># 4: num_plays</span>
    <span class="s1">)</span>

    <span class="s0"># default image IDAT (if it exists)</span>
    <span class="s2">if </span><span class="s1">default_image:</span>
        <span class="s1">ImageFile._save(im</span><span class="s2">, </span><span class="s1">_idat(fp</span><span class="s2">, </span><span class="s1">chunk)</span><span class="s2">, </span><span class="s1">[(</span><span class="s5">&quot;zip&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + im.size</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">rawmode)])</span>

    <span class="s1">seq_num = </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s1">frame</span><span class="s2">, </span><span class="s1">frame_data </span><span class="s2">in </span><span class="s1">enumerate(im_frames):</span>
        <span class="s1">im_frame = frame_data[</span><span class="s5">&quot;im&quot;</span><span class="s1">]</span>
        <span class="s2">if not </span><span class="s1">frame_data[</span><span class="s5">&quot;bbox&quot;</span><span class="s1">]:</span>
            <span class="s1">bbox = (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + im_frame.size</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">bbox = frame_data[</span><span class="s5">&quot;bbox&quot;</span><span class="s1">]</span>
            <span class="s1">im_frame = im_frame.crop(bbox)</span>
        <span class="s1">size = im_frame.size</span>
        <span class="s1">encoderinfo = frame_data[</span><span class="s5">&quot;encoderinfo&quot;</span><span class="s1">]</span>
        <span class="s1">frame_duration = int(round(encoderinfo.get(</span><span class="s5">&quot;duration&quot;</span><span class="s2">, </span><span class="s1">duration)))</span>
        <span class="s1">frame_disposal = encoderinfo.get(</span><span class="s5">&quot;disposal&quot;</span><span class="s2">, </span><span class="s1">disposal)</span>
        <span class="s1">frame_blend = encoderinfo.get(</span><span class="s5">&quot;blend&quot;</span><span class="s2">, </span><span class="s1">blend)</span>
        <span class="s0"># frame control</span>
        <span class="s1">chunk(</span>
            <span class="s1">fp</span><span class="s2">,</span>
            <span class="s3">b&quot;fcTL&quot;</span><span class="s2">,</span>
            <span class="s1">o32(seq_num)</span><span class="s2">,  </span><span class="s0"># sequence_number</span>
            <span class="s1">o32(size[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,  </span><span class="s0"># width</span>
            <span class="s1">o32(size[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,  </span><span class="s0"># height</span>
            <span class="s1">o32(bbox[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,  </span><span class="s0"># x_offset</span>
            <span class="s1">o32(bbox[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,  </span><span class="s0"># y_offset</span>
            <span class="s1">o16(frame_duration)</span><span class="s2">,  </span><span class="s0"># delay_numerator</span>
            <span class="s1">o16(</span><span class="s4">1000</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># delay_denominator</span>
            <span class="s1">o8(frame_disposal)</span><span class="s2">,  </span><span class="s0"># dispose_op</span>
            <span class="s1">o8(frame_blend)</span><span class="s2">,  </span><span class="s0"># blend_op</span>
        <span class="s1">)</span>
        <span class="s1">seq_num += </span><span class="s4">1</span>
        <span class="s0"># frame data</span>
        <span class="s2">if </span><span class="s1">frame == </span><span class="s4">0 </span><span class="s2">and not </span><span class="s1">default_image:</span>
            <span class="s0"># first frame must be in IDAT chunks for backwards compatibility</span>
            <span class="s1">ImageFile._save(</span>
                <span class="s1">im_frame</span><span class="s2">,</span>
                <span class="s1">_idat(fp</span><span class="s2">, </span><span class="s1">chunk)</span><span class="s2">,</span>
                <span class="s1">[(</span><span class="s5">&quot;zip&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + im_frame.size</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">rawmode)]</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fdat_chunks = _fdat(fp</span><span class="s2">, </span><span class="s1">chunk</span><span class="s2">, </span><span class="s1">seq_num)</span>
            <span class="s1">ImageFile._save(</span>
                <span class="s1">im_frame</span><span class="s2">,</span>
                <span class="s1">fdat_chunks</span><span class="s2">,</span>
                <span class="s1">[(</span><span class="s5">&quot;zip&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + im_frame.size</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">rawmode)]</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">seq_num = fdat_chunks.seq_num</span>


<span class="s2">def </span><span class="s1">_save_all(im</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">filename):</span>
    <span class="s1">_save(im</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">save_all=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_save(im</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">chunk=putchunk</span><span class="s2">, </span><span class="s1">save_all=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0"># save an image to disk (called by the save method)</span>

    <span class="s2">if </span><span class="s1">save_all:</span>
        <span class="s1">default_image = im.encoderinfo.get(</span>
            <span class="s5">&quot;default_image&quot;</span><span class="s2">, </span><span class="s1">im.info.get(</span><span class="s5">&quot;default_image&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">modes = set()</span>
        <span class="s1">append_images = im.encoderinfo.get(</span><span class="s5">&quot;append_images&quot;</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">if </span><span class="s1">default_image:</span>
            <span class="s1">chain = itertools.chain(append_images)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">chain = itertools.chain([im]</span><span class="s2">, </span><span class="s1">append_images)</span>
        <span class="s2">for </span><span class="s1">im_seq </span><span class="s2">in </span><span class="s1">chain:</span>
            <span class="s2">for </span><span class="s1">im_frame </span><span class="s2">in </span><span class="s1">ImageSequence.Iterator(im_seq):</span>
                <span class="s1">modes.add(im_frame.mode)</span>
        <span class="s2">for </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">(</span><span class="s5">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s5">&quot;RGB&quot;</span><span class="s2">, </span><span class="s5">&quot;P&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">modes:</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">mode = modes.pop()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">mode = im.mode</span>

    <span class="s2">if </span><span class="s1">mode == </span><span class="s5">&quot;P&quot;</span><span class="s1">:</span>

        <span class="s0">#</span>
        <span class="s0"># attempt to minimize storage requirements for palette images</span>
        <span class="s2">if </span><span class="s5">&quot;bits&quot; </span><span class="s2">in </span><span class="s1">im.encoderinfo:</span>
            <span class="s0"># number of bits specified by user</span>
            <span class="s1">colors = min(</span><span class="s4">1 </span><span class="s1">&lt;&lt; im.encoderinfo[</span><span class="s5">&quot;bits&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s4">256</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># check palette contents</span>
            <span class="s2">if </span><span class="s1">im.palette:</span>
                <span class="s1">colors = max(min(len(im.palette.getdata()[</span><span class="s4">1</span><span class="s1">]) // </span><span class="s4">3</span><span class="s2">, </span><span class="s4">256</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">colors = </span><span class="s4">256</span>

        <span class="s2">if </span><span class="s1">colors &lt;= </span><span class="s4">16</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">colors &lt;= </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">bits = </span><span class="s4">1</span>
            <span class="s2">elif </span><span class="s1">colors &lt;= </span><span class="s4">4</span><span class="s1">:</span>
                <span class="s1">bits = </span><span class="s4">2</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">bits = </span><span class="s4">4</span>
            <span class="s1">mode = </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">mode</span><span class="s2">}</span><span class="s5">;</span><span class="s2">{</span><span class="s1">bits</span><span class="s2">}</span><span class="s5">&quot;</span>

    <span class="s0"># encoder options</span>
    <span class="s1">im.encoderconfig = (</span>
        <span class="s1">im.encoderinfo.get(</span><span class="s5">&quot;optimize&quot;</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">im.encoderinfo.get(</span><span class="s5">&quot;compress_level&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">im.encoderinfo.get(</span><span class="s5">&quot;compress_type&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">im.encoderinfo.get(</span><span class="s5">&quot;dictionary&quot;</span><span class="s2">, </span><span class="s3">b&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s0"># get the corresponding PNG mode</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">rawmode</span><span class="s2">, </span><span class="s1">mode = _OUTMODES[mode]</span>
    <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s1">msg = </span><span class="s5">f&quot;cannot write mode </span><span class="s2">{</span><span class="s1">mode</span><span class="s2">} </span><span class="s5">as PNG&quot;</span>
        <span class="s2">raise </span><span class="s1">OSError(msg) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s0">#</span>
    <span class="s0"># write minimal PNG file</span>

    <span class="s1">fp.write(_MAGIC)</span>

    <span class="s1">chunk(</span>
        <span class="s1">fp</span><span class="s2">,</span>
        <span class="s3">b&quot;IHDR&quot;</span><span class="s2">,</span>
        <span class="s1">o32(im.size[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,  </span><span class="s0"># 0: size</span>
        <span class="s1">o32(im.size[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">mode</span><span class="s2">,  </span><span class="s0"># 8: depth/type</span>
        <span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot;</span><span class="s2">,  </span><span class="s0"># 10: compression</span>
        <span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot;</span><span class="s2">,  </span><span class="s0"># 11: filter category</span>
        <span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot;</span><span class="s2">,  </span><span class="s0"># 12: interlace flag</span>
    <span class="s1">)</span>

    <span class="s1">chunks = [</span><span class="s3">b&quot;cHRM&quot;</span><span class="s2">, </span><span class="s3">b&quot;gAMA&quot;</span><span class="s2">, </span><span class="s3">b&quot;sBIT&quot;</span><span class="s2">, </span><span class="s3">b&quot;sRGB&quot;</span><span class="s2">, </span><span class="s3">b&quot;tIME&quot;</span><span class="s1">]</span>

    <span class="s1">icc = im.encoderinfo.get(</span><span class="s5">&quot;icc_profile&quot;</span><span class="s2">, </span><span class="s1">im.info.get(</span><span class="s5">&quot;icc_profile&quot;</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">icc:</span>
        <span class="s0"># ICC profile</span>
        <span class="s0"># according to PNG spec, the iCCP chunk contains:</span>
        <span class="s0"># Profile name  1-79 bytes (character string)</span>
        <span class="s0"># Null separator        1 byte (null character)</span>
        <span class="s0"># Compression method    1 byte (0)</span>
        <span class="s0"># Compressed profile    n bytes (zlib with deflate compression)</span>
        <span class="s1">name = </span><span class="s3">b&quot;ICC Profile&quot;</span>
        <span class="s1">data = name + </span><span class="s3">b&quot;</span><span class="s2">\0\0</span><span class="s3">&quot; </span><span class="s1">+ zlib.compress(icc)</span>
        <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s3">b&quot;iCCP&quot;</span><span class="s2">, </span><span class="s1">data)</span>

        <span class="s0"># You must either have sRGB or iCCP.</span>
        <span class="s0"># Disallow sRGB chunks when an iCCP-chunk has been emitted.</span>
        <span class="s1">chunks.remove(</span><span class="s3">b&quot;sRGB&quot;</span><span class="s1">)</span>

    <span class="s1">info = im.encoderinfo.get(</span><span class="s5">&quot;pnginfo&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">info:</span>
        <span class="s1">chunks_multiple_allowed = [</span><span class="s3">b&quot;sPLT&quot;</span><span class="s2">, </span><span class="s3">b&quot;iTXt&quot;</span><span class="s2">, </span><span class="s3">b&quot;tEXt&quot;</span><span class="s2">, </span><span class="s3">b&quot;zTXt&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">info_chunk </span><span class="s2">in </span><span class="s1">info.chunks:</span>
            <span class="s1">cid</span><span class="s2">, </span><span class="s1">data = info_chunk[:</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">cid </span><span class="s2">in </span><span class="s1">chunks:</span>
                <span class="s1">chunks.remove(cid)</span>
                <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">data)</span>
            <span class="s2">elif </span><span class="s1">cid </span><span class="s2">in </span><span class="s1">chunks_multiple_allowed:</span>
                <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">data)</span>
            <span class="s2">elif </span><span class="s1">cid[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">2</span><span class="s1">].islower():</span>
                <span class="s0"># Private chunk</span>
                <span class="s1">after_idat = info_chunk[</span><span class="s4">2</span><span class="s1">:</span><span class="s4">3</span><span class="s1">]</span>
                <span class="s2">if not </span><span class="s1">after_idat:</span>
                    <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">data)</span>

    <span class="s2">if </span><span class="s1">im.mode == </span><span class="s5">&quot;P&quot;</span><span class="s1">:</span>
        <span class="s1">palette_byte_number = colors * </span><span class="s4">3</span>
        <span class="s1">palette_bytes = im.im.getpalette(</span><span class="s5">&quot;RGB&quot;</span><span class="s1">)[:palette_byte_number]</span>
        <span class="s2">while </span><span class="s1">len(palette_bytes) &lt; palette_byte_number:</span>
            <span class="s1">palette_bytes += </span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot;</span>
        <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s3">b&quot;PLTE&quot;</span><span class="s2">, </span><span class="s1">palette_bytes)</span>

    <span class="s1">transparency = im.encoderinfo.get(</span><span class="s5">&quot;transparency&quot;</span><span class="s2">, </span><span class="s1">im.info.get(</span><span class="s5">&quot;transparency&quot;</span><span class="s2">, None</span><span class="s1">))</span>

    <span class="s2">if </span><span class="s1">transparency </span><span class="s2">or </span><span class="s1">transparency == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">im.mode == </span><span class="s5">&quot;P&quot;</span><span class="s1">:</span>
            <span class="s0"># limit to actual palette size</span>
            <span class="s1">alpha_bytes = colors</span>
            <span class="s2">if </span><span class="s1">isinstance(transparency</span><span class="s2">, </span><span class="s1">bytes):</span>
                <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s3">b&quot;tRNS&quot;</span><span class="s2">, </span><span class="s1">transparency[:alpha_bytes])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">transparency = max(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">min(</span><span class="s4">255</span><span class="s2">, </span><span class="s1">transparency))</span>
                <span class="s1">alpha = </span><span class="s3">b&quot;</span><span class="s2">\xFF</span><span class="s3">&quot; </span><span class="s1">* transparency + </span><span class="s3">b&quot;</span><span class="s2">\0</span><span class="s3">&quot;</span>
                <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s3">b&quot;tRNS&quot;</span><span class="s2">, </span><span class="s1">alpha[:alpha_bytes])</span>
        <span class="s2">elif </span><span class="s1">im.mode </span><span class="s2">in </span><span class="s1">(</span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;L&quot;</span><span class="s2">, </span><span class="s5">&quot;I&quot;</span><span class="s1">):</span>
            <span class="s1">transparency = max(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">min(</span><span class="s4">65535</span><span class="s2">, </span><span class="s1">transparency))</span>
            <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s3">b&quot;tRNS&quot;</span><span class="s2">, </span><span class="s1">o16(transparency))</span>
        <span class="s2">elif </span><span class="s1">im.mode == </span><span class="s5">&quot;RGB&quot;</span><span class="s1">:</span>
            <span class="s1">red</span><span class="s2">, </span><span class="s1">green</span><span class="s2">, </span><span class="s1">blue = transparency</span>
            <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s3">b&quot;tRNS&quot;</span><span class="s2">, </span><span class="s1">o16(red) + o16(green) + o16(blue))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s5">&quot;transparency&quot; </span><span class="s2">in </span><span class="s1">im.encoderinfo:</span>
                <span class="s0"># don't bother with transparency if it's an RGBA</span>
                <span class="s0"># and it's in the info dict. It's probably just stale.</span>
                <span class="s1">msg = </span><span class="s5">&quot;cannot use transparency for this mode&quot;</span>
                <span class="s2">raise </span><span class="s1">OSError(msg)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">im.mode == </span><span class="s5">&quot;P&quot; </span><span class="s2">and </span><span class="s1">im.im.getpalettemode() == </span><span class="s5">&quot;RGBA&quot;</span><span class="s1">:</span>
            <span class="s1">alpha = im.im.getpalette(</span><span class="s5">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s5">&quot;A&quot;</span><span class="s1">)</span>
            <span class="s1">alpha_bytes = colors</span>
            <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s3">b&quot;tRNS&quot;</span><span class="s2">, </span><span class="s1">alpha[:alpha_bytes])</span>

    <span class="s1">dpi = im.encoderinfo.get(</span><span class="s5">&quot;dpi&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">dpi:</span>
        <span class="s1">chunk(</span>
            <span class="s1">fp</span><span class="s2">,</span>
            <span class="s3">b&quot;pHYs&quot;</span><span class="s2">,</span>
            <span class="s1">o32(int(dpi[</span><span class="s4">0</span><span class="s1">] / </span><span class="s4">0.0254 </span><span class="s1">+ </span><span class="s4">0.5</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">o32(int(dpi[</span><span class="s4">1</span><span class="s1">] / </span><span class="s4">0.0254 </span><span class="s1">+ </span><span class="s4">0.5</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s3">b&quot;</span><span class="s2">\x01</span><span class="s3">&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">info:</span>
        <span class="s1">chunks = [</span><span class="s3">b&quot;bKGD&quot;</span><span class="s2">, </span><span class="s3">b&quot;hIST&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">info_chunk </span><span class="s2">in </span><span class="s1">info.chunks:</span>
            <span class="s1">cid</span><span class="s2">, </span><span class="s1">data = info_chunk[:</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">cid </span><span class="s2">in </span><span class="s1">chunks:</span>
                <span class="s1">chunks.remove(cid)</span>
                <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">data)</span>

    <span class="s1">exif = im.encoderinfo.get(</span><span class="s5">&quot;exif&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">exif:</span>
        <span class="s2">if </span><span class="s1">isinstance(exif</span><span class="s2">, </span><span class="s1">Image.Exif):</span>
            <span class="s1">exif = exif.tobytes(</span><span class="s4">8</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">exif.startswith(</span><span class="s3">b&quot;Exif</span><span class="s2">\x00\x00</span><span class="s3">&quot;</span><span class="s1">):</span>
            <span class="s1">exif = exif[</span><span class="s4">6</span><span class="s1">:]</span>
        <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s3">b&quot;eXIf&quot;</span><span class="s2">, </span><span class="s1">exif)</span>

    <span class="s2">if </span><span class="s1">save_all:</span>
        <span class="s1">_write_multiple_frames(im</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">chunk</span><span class="s2">, </span><span class="s1">rawmode</span><span class="s2">, </span><span class="s1">default_image</span><span class="s2">, </span><span class="s1">append_images)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">ImageFile._save(im</span><span class="s2">, </span><span class="s1">_idat(fp</span><span class="s2">, </span><span class="s1">chunk)</span><span class="s2">, </span><span class="s1">[(</span><span class="s5">&quot;zip&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + im.size</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">rawmode)])</span>

    <span class="s2">if </span><span class="s1">info:</span>
        <span class="s2">for </span><span class="s1">info_chunk </span><span class="s2">in </span><span class="s1">info.chunks:</span>
            <span class="s1">cid</span><span class="s2">, </span><span class="s1">data = info_chunk[:</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">cid[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">2</span><span class="s1">].islower():</span>
                <span class="s0"># Private chunk</span>
                <span class="s1">after_idat = info_chunk[</span><span class="s4">2</span><span class="s1">:</span><span class="s4">3</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">after_idat:</span>
                    <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">data)</span>

    <span class="s1">chunk(fp</span><span class="s2">, </span><span class="s3">b&quot;IEND&quot;</span><span class="s2">, </span><span class="s3">b&quot;&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">hasattr(fp</span><span class="s2">, </span><span class="s5">&quot;flush&quot;</span><span class="s1">):</span>
        <span class="s1">fp.flush()</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># PNG chunk converter</span>


<span class="s2">def </span><span class="s1">getchunks(im</span><span class="s2">, </span><span class="s1">**params):</span>
    <span class="s6">&quot;&quot;&quot;Return a list of PNG chunks representing this image.&quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">collector:</span>
        <span class="s1">data = []</span>

        <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">data):</span>
            <span class="s2">pass</span>

        <span class="s2">def </span><span class="s1">append(self</span><span class="s2">, </span><span class="s1">chunk):</span>
            <span class="s1">self.data.append(chunk)</span>

    <span class="s2">def </span><span class="s1">append(fp</span><span class="s2">, </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">*data):</span>
        <span class="s1">data = </span><span class="s3">b&quot;&quot;</span><span class="s1">.join(data)</span>
        <span class="s1">crc = o32(_crc32(data</span><span class="s2">, </span><span class="s1">_crc32(cid)))</span>
        <span class="s1">fp.append((cid</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">crc))</span>

    <span class="s1">fp = collector()</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">im.encoderinfo = params</span>
        <span class="s1">_save(im</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, None, </span><span class="s1">append)</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s2">del </span><span class="s1">im.encoderinfo</span>

    <span class="s2">return </span><span class="s1">fp.data</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Registry</span>

<span class="s1">Image.register_open(PngImageFile.format</span><span class="s2">, </span><span class="s1">PngImageFile</span><span class="s2">, </span><span class="s1">_accept)</span>
<span class="s1">Image.register_save(PngImageFile.format</span><span class="s2">, </span><span class="s1">_save)</span>
<span class="s1">Image.register_save_all(PngImageFile.format</span><span class="s2">, </span><span class="s1">_save_all)</span>

<span class="s1">Image.register_extensions(PngImageFile.format</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;.png&quot;</span><span class="s2">, </span><span class="s5">&quot;.apng&quot;</span><span class="s1">])</span>

<span class="s1">Image.register_mime(PngImageFile.format</span><span class="s2">, </span><span class="s5">&quot;image/png&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>