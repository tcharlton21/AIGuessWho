<html>
<head>
<title>pyparsing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pyparsing.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s0"># module pyparsing.py</span>
<span class="s0">#</span>
<span class="s0"># Copyright (c) 2003-2019  Paul T. McGuire</span>
<span class="s0">#</span>
<span class="s0"># Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="s0"># a copy of this software and associated documentation files (the</span>
<span class="s0"># &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s0"># without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s0"># distribute, sublicense, and/or sell copies of the Software, and to</span>
<span class="s0"># permit persons to whom the Software is furnished to do so, subject to</span>
<span class="s0"># the following conditions:</span>
<span class="s0">#</span>
<span class="s0"># The above copyright notice and this permission notice shall be</span>
<span class="s0"># included in all copies or substantial portions of the Software.</span>
<span class="s0">#</span>
<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="s0"># EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s0"># MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.</span>
<span class="s0"># IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY</span>
<span class="s0"># CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,</span>
<span class="s0"># TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE</span>
<span class="s0"># SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="s0">#</span>

<span class="s1">__doc__ = \</span>
<span class="s2">&quot;&quot;&quot; 
pyparsing module - Classes and methods to define and execute parsing grammars 
============================================================================= 
 
The pyparsing module is an alternative approach to creating and 
executing simple grammars, vs. the traditional lex/yacc approach, or the 
use of regular expressions.  With pyparsing, you don't need to learn 
a new syntax for defining grammars or matching expressions - the parsing 
module provides a library of classes that you use to construct the 
grammar directly in Python. 
 
Here is a program to parse &quot;Hello, World!&quot; (or any greeting of the form 
``&quot;&lt;salutation&gt;, &lt;addressee&gt;!&quot;``), built up using :class:`Word`, 
:class:`Literal`, and :class:`And` elements 
(the :class:`'+'&lt;ParserElement.__add__&gt;` operators create :class:`And` expressions, 
and the strings are auto-converted to :class:`Literal` expressions):: 
 
    from pip._vendor.pyparsing import Word, alphas 
 
    # define grammar of a greeting 
    greet = Word(alphas) + &quot;,&quot; + Word(alphas) + &quot;!&quot; 
 
    hello = &quot;Hello, World!&quot; 
    print (hello, &quot;-&gt;&quot;, greet.parseString(hello)) 
 
The program outputs the following:: 
 
    Hello, World! -&gt; ['Hello', ',', 'World', '!'] 
 
The Python representation of the grammar is quite readable, owing to the 
self-explanatory class names, and the use of '+', '|' and '^' operators. 
 
The :class:`ParseResults` object returned from 
:class:`ParserElement.parseString` can be 
accessed as a nested list, a dictionary, or an object with named 
attributes. 
 
The pyparsing module handles some of the problems that are typically 
vexing when writing text parsers: 
 
  - extra or missing whitespace (the above program will also handle 
    &quot;Hello,World!&quot;, &quot;Hello  ,  World  !&quot;, etc.) 
  - quoted strings 
  - embedded comments 
 
 
Getting Started - 
----------------- 
Visit the classes :class:`ParserElement` and :class:`ParseResults` to 
see the base classes that most other pyparsing 
classes inherit from. Use the docstrings for examples of how to: 
 
 - construct literal match expressions from :class:`Literal` and 
   :class:`CaselessLiteral` classes 
 - construct character word-group expressions using the :class:`Word` 
   class 
 - see how to create repetitive expressions using :class:`ZeroOrMore` 
   and :class:`OneOrMore` classes 
 - use :class:`'+'&lt;And&gt;`, :class:`'|'&lt;MatchFirst&gt;`, :class:`'^'&lt;Or&gt;`, 
   and :class:`'&amp;'&lt;Each&gt;` operators to combine simple expressions into 
   more complex ones 
 - associate names with your parsed results using 
   :class:`ParserElement.setResultsName` 
 - access the parsed data, which is returned as a :class:`ParseResults` 
   object 
 - find some helpful expression short-cuts like :class:`delimitedList` 
   and :class:`oneOf` 
 - find more useful common expressions in the :class:`pyparsing_common` 
   namespace class 
&quot;&quot;&quot;</span>

<span class="s1">__version__ = </span><span class="s2">&quot;2.4.7&quot;</span>
<span class="s1">__versionTime__ = </span><span class="s2">&quot;30 Mar 2020 00:43 UTC&quot;</span>
<span class="s1">__author__ = </span><span class="s2">&quot;Paul McGuire &lt;ptmcg@users.sourceforge.net&gt;&quot;</span>

<span class="s3">import </span><span class="s1">string</span>
<span class="s3">from </span><span class="s1">weakref </span><span class="s3">import </span><span class="s1">ref </span><span class="s3">as </span><span class="s1">wkref</span>
<span class="s3">import </span><span class="s1">copy</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">sre_constants</span>
<span class="s3">import </span><span class="s1">collections</span>
<span class="s3">import </span><span class="s1">pprint</span>
<span class="s3">import </span><span class="s1">traceback</span>
<span class="s3">import </span><span class="s1">types</span>
<span class="s3">from </span><span class="s1">datetime </span><span class="s3">import </span><span class="s1">datetime</span>
<span class="s3">from </span><span class="s1">operator </span><span class="s3">import </span><span class="s1">itemgetter</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">wraps</span>
<span class="s3">from </span><span class="s1">contextlib </span><span class="s3">import </span><span class="s1">contextmanager</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s0"># Python 3</span>
    <span class="s3">from </span><span class="s1">itertools </span><span class="s3">import </span><span class="s1">filterfalse</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">from </span><span class="s1">itertools </span><span class="s3">import </span><span class="s1">ifilterfalse </span><span class="s3">as </span><span class="s1">filterfalse</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">_thread </span><span class="s3">import </span><span class="s1">RLock</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">from </span><span class="s1">threading </span><span class="s3">import </span><span class="s1">RLock</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s0"># Python 3</span>
    <span class="s3">from </span><span class="s1">collections.abc </span><span class="s3">import </span><span class="s1">Iterable</span>
    <span class="s3">from </span><span class="s1">collections.abc </span><span class="s3">import </span><span class="s1">MutableMapping</span><span class="s3">, </span><span class="s1">Mapping</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s0"># Python 2.7</span>
    <span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">Iterable</span>
    <span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">MutableMapping</span><span class="s3">, </span><span class="s1">Mapping</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">OrderedDict </span><span class="s3">as </span><span class="s1">_OrderedDict</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">from </span><span class="s1">ordereddict </span><span class="s3">import </span><span class="s1">OrderedDict </span><span class="s3">as </span><span class="s1">_OrderedDict</span>
    <span class="s3">except </span><span class="s1">ImportError:</span>
        <span class="s1">_OrderedDict = </span><span class="s3">None</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">types </span><span class="s3">import </span><span class="s1">SimpleNamespace</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">class </span><span class="s1">SimpleNamespace: </span><span class="s3">pass</span>

<span class="s0"># version compatibility configuration</span>
<span class="s1">__compat__ = SimpleNamespace()</span>
<span class="s1">__compat__.__doc__ = </span><span class="s2">&quot;&quot;&quot; 
    A cross-version compatibility configuration for pyparsing features that will be 
    released in a future version. By setting values in this configuration to True, 
    those features can be enabled in prior versions for compatibility development 
    and testing. 
 
     - collect_all_And_tokens - flag to enable fix for Issue #63 that fixes erroneous grouping 
       of results names when an And expression is nested within an Or or MatchFirst; set to 
       True to enable bugfix released in pyparsing 2.3.0, or False to preserve 
       pre-2.3.0 handling of named results 
&quot;&quot;&quot;</span>
<span class="s1">__compat__.collect_all_And_tokens = </span><span class="s3">True</span>

<span class="s1">__diag__ = SimpleNamespace()</span>
<span class="s1">__diag__.__doc__ = </span><span class="s2">&quot;&quot;&quot; 
Diagnostic configuration (all default to False) 
     - warn_multiple_tokens_in_named_alternation - flag to enable warnings when a results 
       name is defined on a MatchFirst or Or expression with one or more And subexpressions 
       (only warns if __compat__.collect_all_And_tokens is False) 
     - warn_ungrouped_named_tokens_in_collection - flag to enable warnings when a results 
       name is defined on a containing expression with ungrouped subexpressions that also 
       have results names 
     - warn_name_set_on_empty_Forward - flag to enable warnings whan a Forward is defined 
       with a results name, but has no contents defined 
     - warn_on_multiple_string_args_to_oneof - flag to enable warnings whan oneOf is 
       incorrectly called with multiple str arguments 
     - enable_debug_on_named_expressions - flag to auto-enable debug on all subsequent 
       calls to ParserElement.setName() 
&quot;&quot;&quot;</span>
<span class="s1">__diag__.warn_multiple_tokens_in_named_alternation = </span><span class="s3">False</span>
<span class="s1">__diag__.warn_ungrouped_named_tokens_in_collection = </span><span class="s3">False</span>
<span class="s1">__diag__.warn_name_set_on_empty_Forward = </span><span class="s3">False</span>
<span class="s1">__diag__.warn_on_multiple_string_args_to_oneof = </span><span class="s3">False</span>
<span class="s1">__diag__.enable_debug_on_named_expressions = </span><span class="s3">False</span>
<span class="s1">__diag__._all_names = [nm </span><span class="s3">for </span><span class="s1">nm </span><span class="s3">in </span><span class="s1">vars(__diag__) </span><span class="s3">if </span><span class="s1">nm.startswith(</span><span class="s2">&quot;enable_&quot;</span><span class="s1">) </span><span class="s3">or </span><span class="s1">nm.startswith(</span><span class="s2">&quot;warn_&quot;</span><span class="s1">)]</span>

<span class="s3">def </span><span class="s1">_enable_all_warnings():</span>
    <span class="s1">__diag__.warn_multiple_tokens_in_named_alternation = </span><span class="s3">True</span>
    <span class="s1">__diag__.warn_ungrouped_named_tokens_in_collection = </span><span class="s3">True</span>
    <span class="s1">__diag__.warn_name_set_on_empty_Forward = </span><span class="s3">True</span>
    <span class="s1">__diag__.warn_on_multiple_string_args_to_oneof = </span><span class="s3">True</span>
<span class="s1">__diag__.enable_all_warnings = _enable_all_warnings</span>


<span class="s1">__all__ = [</span><span class="s2">'__version__'</span><span class="s3">, </span><span class="s2">'__versionTime__'</span><span class="s3">, </span><span class="s2">'__author__'</span><span class="s3">, </span><span class="s2">'__compat__'</span><span class="s3">, </span><span class="s2">'__diag__'</span><span class="s3">,</span>
           <span class="s2">'And'</span><span class="s3">, </span><span class="s2">'CaselessKeyword'</span><span class="s3">, </span><span class="s2">'CaselessLiteral'</span><span class="s3">, </span><span class="s2">'CharsNotIn'</span><span class="s3">, </span><span class="s2">'Combine'</span><span class="s3">, </span><span class="s2">'Dict'</span><span class="s3">, </span><span class="s2">'Each'</span><span class="s3">, </span><span class="s2">'Empty'</span><span class="s3">,</span>
           <span class="s2">'FollowedBy'</span><span class="s3">, </span><span class="s2">'Forward'</span><span class="s3">, </span><span class="s2">'GoToColumn'</span><span class="s3">, </span><span class="s2">'Group'</span><span class="s3">, </span><span class="s2">'Keyword'</span><span class="s3">, </span><span class="s2">'LineEnd'</span><span class="s3">, </span><span class="s2">'LineStart'</span><span class="s3">, </span><span class="s2">'Literal'</span><span class="s3">,</span>
           <span class="s2">'PrecededBy'</span><span class="s3">, </span><span class="s2">'MatchFirst'</span><span class="s3">, </span><span class="s2">'NoMatch'</span><span class="s3">, </span><span class="s2">'NotAny'</span><span class="s3">, </span><span class="s2">'OneOrMore'</span><span class="s3">, </span><span class="s2">'OnlyOnce'</span><span class="s3">, </span><span class="s2">'Optional'</span><span class="s3">, </span><span class="s2">'Or'</span><span class="s3">,</span>
           <span class="s2">'ParseBaseException'</span><span class="s3">, </span><span class="s2">'ParseElementEnhance'</span><span class="s3">, </span><span class="s2">'ParseException'</span><span class="s3">, </span><span class="s2">'ParseExpression'</span><span class="s3">, </span><span class="s2">'ParseFatalException'</span><span class="s3">,</span>
           <span class="s2">'ParseResults'</span><span class="s3">, </span><span class="s2">'ParseSyntaxException'</span><span class="s3">, </span><span class="s2">'ParserElement'</span><span class="s3">, </span><span class="s2">'QuotedString'</span><span class="s3">, </span><span class="s2">'RecursiveGrammarException'</span><span class="s3">,</span>
           <span class="s2">'Regex'</span><span class="s3">, </span><span class="s2">'SkipTo'</span><span class="s3">, </span><span class="s2">'StringEnd'</span><span class="s3">, </span><span class="s2">'StringStart'</span><span class="s3">, </span><span class="s2">'Suppress'</span><span class="s3">, </span><span class="s2">'Token'</span><span class="s3">, </span><span class="s2">'TokenConverter'</span><span class="s3">,</span>
           <span class="s2">'White'</span><span class="s3">, </span><span class="s2">'Word'</span><span class="s3">, </span><span class="s2">'WordEnd'</span><span class="s3">, </span><span class="s2">'WordStart'</span><span class="s3">, </span><span class="s2">'ZeroOrMore'</span><span class="s3">, </span><span class="s2">'Char'</span><span class="s3">,</span>
           <span class="s2">'alphanums'</span><span class="s3">, </span><span class="s2">'alphas'</span><span class="s3">, </span><span class="s2">'alphas8bit'</span><span class="s3">, </span><span class="s2">'anyCloseTag'</span><span class="s3">, </span><span class="s2">'anyOpenTag'</span><span class="s3">, </span><span class="s2">'cStyleComment'</span><span class="s3">, </span><span class="s2">'col'</span><span class="s3">,</span>
           <span class="s2">'commaSeparatedList'</span><span class="s3">, </span><span class="s2">'commonHTMLEntity'</span><span class="s3">, </span><span class="s2">'countedArray'</span><span class="s3">, </span><span class="s2">'cppStyleComment'</span><span class="s3">, </span><span class="s2">'dblQuotedString'</span><span class="s3">,</span>
           <span class="s2">'dblSlashComment'</span><span class="s3">, </span><span class="s2">'delimitedList'</span><span class="s3">, </span><span class="s2">'dictOf'</span><span class="s3">, </span><span class="s2">'downcaseTokens'</span><span class="s3">, </span><span class="s2">'empty'</span><span class="s3">, </span><span class="s2">'hexnums'</span><span class="s3">,</span>
           <span class="s2">'htmlComment'</span><span class="s3">, </span><span class="s2">'javaStyleComment'</span><span class="s3">, </span><span class="s2">'line'</span><span class="s3">, </span><span class="s2">'lineEnd'</span><span class="s3">, </span><span class="s2">'lineStart'</span><span class="s3">, </span><span class="s2">'lineno'</span><span class="s3">,</span>
           <span class="s2">'makeHTMLTags'</span><span class="s3">, </span><span class="s2">'makeXMLTags'</span><span class="s3">, </span><span class="s2">'matchOnlyAtCol'</span><span class="s3">, </span><span class="s2">'matchPreviousExpr'</span><span class="s3">, </span><span class="s2">'matchPreviousLiteral'</span><span class="s3">,</span>
           <span class="s2">'nestedExpr'</span><span class="s3">, </span><span class="s2">'nullDebugAction'</span><span class="s3">, </span><span class="s2">'nums'</span><span class="s3">, </span><span class="s2">'oneOf'</span><span class="s3">, </span><span class="s2">'opAssoc'</span><span class="s3">, </span><span class="s2">'operatorPrecedence'</span><span class="s3">, </span><span class="s2">'printables'</span><span class="s3">,</span>
           <span class="s2">'punc8bit'</span><span class="s3">, </span><span class="s2">'pythonStyleComment'</span><span class="s3">, </span><span class="s2">'quotedString'</span><span class="s3">, </span><span class="s2">'removeQuotes'</span><span class="s3">, </span><span class="s2">'replaceHTMLEntity'</span><span class="s3">,</span>
           <span class="s2">'replaceWith'</span><span class="s3">, </span><span class="s2">'restOfLine'</span><span class="s3">, </span><span class="s2">'sglQuotedString'</span><span class="s3">, </span><span class="s2">'srange'</span><span class="s3">, </span><span class="s2">'stringEnd'</span><span class="s3">,</span>
           <span class="s2">'stringStart'</span><span class="s3">, </span><span class="s2">'traceParseAction'</span><span class="s3">, </span><span class="s2">'unicodeString'</span><span class="s3">, </span><span class="s2">'upcaseTokens'</span><span class="s3">, </span><span class="s2">'withAttribute'</span><span class="s3">,</span>
           <span class="s2">'indentedBlock'</span><span class="s3">, </span><span class="s2">'originalTextFor'</span><span class="s3">, </span><span class="s2">'ungroup'</span><span class="s3">, </span><span class="s2">'infixNotation'</span><span class="s3">, </span><span class="s2">'locatedExpr'</span><span class="s3">, </span><span class="s2">'withClass'</span><span class="s3">,</span>
           <span class="s2">'CloseMatch'</span><span class="s3">, </span><span class="s2">'tokenMap'</span><span class="s3">, </span><span class="s2">'pyparsing_common'</span><span class="s3">, </span><span class="s2">'pyparsing_unicode'</span><span class="s3">, </span><span class="s2">'unicode_set'</span><span class="s3">,</span>
           <span class="s2">'conditionAsParseAction'</span><span class="s3">, </span><span class="s2">'re'</span><span class="s3">,</span>
           <span class="s1">]</span>

<span class="s1">system_version = tuple(sys.version_info)[:</span><span class="s4">3</span><span class="s1">]</span>
<span class="s1">PY_3 = system_version[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">3</span>
<span class="s3">if </span><span class="s1">PY_3:</span>
    <span class="s1">_MAX_INT = sys.maxsize</span>
    <span class="s1">basestring = str</span>
    <span class="s1">unichr = chr</span>
    <span class="s1">unicode = str</span>
    <span class="s1">_ustr = str</span>

    <span class="s0"># build list of single arg builtins, that can be used as parse actions</span>
    <span class="s1">singleArgBuiltins = [sum</span><span class="s3">, </span><span class="s1">len</span><span class="s3">, </span><span class="s1">sorted</span><span class="s3">, </span><span class="s1">reversed</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">any</span><span class="s3">, </span><span class="s1">all</span><span class="s3">, </span><span class="s1">min</span><span class="s3">, </span><span class="s1">max]</span>

<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">_MAX_INT = sys.maxint</span>
    <span class="s1">range = xrange</span>

    <span class="s3">def </span><span class="s1">_ustr(obj):</span>
        <span class="s5">&quot;&quot;&quot;Drop-in replacement for str(obj) that tries to be Unicode 
        friendly. It first tries str(obj). If that fails with 
        a UnicodeEncodeError, then it tries unicode(obj). It then 
        &lt; returns the unicode object | encodes it with the default 
        encoding | ... &gt;. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">unicode):</span>
            <span class="s3">return </span><span class="s1">obj</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s0"># If this works, then _ustr(obj) has the same behaviour as str(obj), so</span>
            <span class="s0"># it won't break any existing code.</span>
            <span class="s3">return </span><span class="s1">str(obj)</span>

        <span class="s3">except </span><span class="s1">UnicodeEncodeError:</span>
            <span class="s0"># Else encode it</span>
            <span class="s1">ret = unicode(obj).encode(sys.getdefaultencoding()</span><span class="s3">, </span><span class="s2">'xmlcharrefreplace'</span><span class="s1">)</span>
            <span class="s1">xmlcharref = Regex(</span><span class="s2">r'&amp;#\d+;'</span><span class="s1">)</span>
            <span class="s1">xmlcharref.setParseAction(</span><span class="s3">lambda </span><span class="s1">t: </span><span class="s2">'</span><span class="s3">\\</span><span class="s2">u' </span><span class="s1">+ hex(int(t[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">2</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]))[</span><span class="s4">2</span><span class="s1">:])</span>
            <span class="s3">return </span><span class="s1">xmlcharref.transformString(ret)</span>

    <span class="s0"># build list of single arg builtins, tolerant of Python version, that can be used as parse actions</span>
    <span class="s1">singleArgBuiltins = []</span>
    <span class="s3">import </span><span class="s1">__builtin__</span>

    <span class="s3">for </span><span class="s1">fname </span><span class="s3">in </span><span class="s2">&quot;sum len sorted reversed list tuple set any all min max&quot;</span><span class="s1">.split():</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">singleArgBuiltins.append(getattr(__builtin__</span><span class="s3">, </span><span class="s1">fname))</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">continue</span>

<span class="s1">_generatorType = type((y </span><span class="s3">for </span><span class="s1">y </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s1">)))</span>

<span class="s3">def </span><span class="s1">_xml_escape(data):</span>
    <span class="s5">&quot;&quot;&quot;Escape &amp;, &lt;, &gt;, &quot;, ', etc. in a string of data.&quot;&quot;&quot;</span>

    <span class="s0"># ampersand must be replaced first</span>
    <span class="s1">from_symbols = </span><span class="s2">'&amp;&gt;&lt;&quot;</span><span class="s3">\'</span><span class="s2">'</span>
    <span class="s1">to_symbols = (</span><span class="s2">'&amp;' </span><span class="s1">+ s + </span><span class="s2">';' </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s2">&quot;amp gt lt quot apos&quot;</span><span class="s1">.split())</span>
    <span class="s3">for </span><span class="s1">from_</span><span class="s3">, </span><span class="s1">to_ </span><span class="s3">in </span><span class="s1">zip(from_symbols</span><span class="s3">, </span><span class="s1">to_symbols):</span>
        <span class="s1">data = data.replace(from_</span><span class="s3">, </span><span class="s1">to_)</span>
    <span class="s3">return </span><span class="s1">data</span>

<span class="s1">alphas = string.ascii_uppercase + string.ascii_lowercase</span>
<span class="s1">nums = </span><span class="s2">&quot;0123456789&quot;</span>
<span class="s1">hexnums = nums + </span><span class="s2">&quot;ABCDEFabcdef&quot;</span>
<span class="s1">alphanums = alphas + nums</span>
<span class="s1">_bslash = chr(</span><span class="s4">92</span><span class="s1">)</span>
<span class="s1">printables = </span><span class="s2">&quot;&quot;</span><span class="s1">.join(c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">string.printable </span><span class="s3">if </span><span class="s1">c </span><span class="s3">not in </span><span class="s1">string.whitespace)</span>


<span class="s3">def </span><span class="s1">conditionAsParseAction(fn</span><span class="s3">, </span><span class="s1">message=</span><span class="s3">None, </span><span class="s1">fatal=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s1">msg = message </span><span class="s3">if </span><span class="s1">message </span><span class="s3">is not None else </span><span class="s2">&quot;failed user-defined condition&quot;</span>
    <span class="s1">exc_type = ParseFatalException </span><span class="s3">if </span><span class="s1">fatal </span><span class="s3">else </span><span class="s1">ParseException</span>
    <span class="s1">fn = _trim_arity(fn)</span>

    <span class="s1">@wraps(fn)</span>
    <span class="s3">def </span><span class="s1">pa(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">if not </span><span class="s1">bool(fn(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t)):</span>
            <span class="s3">raise </span><span class="s1">exc_type(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">msg)</span>

    <span class="s3">return </span><span class="s1">pa</span>

<span class="s3">class </span><span class="s1">ParseBaseException(Exception):</span>
    <span class="s5">&quot;&quot;&quot;base exception class for all parsing runtime exceptions&quot;&quot;&quot;</span>
    <span class="s0"># Performance tuning: we construct a *lot* of these, so keep this</span>
    <span class="s0"># constructor as small and fast as possible</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">pstr</span><span class="s3">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None, </span><span class="s1">elem=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self.loc = loc</span>
        <span class="s3">if </span><span class="s1">msg </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.msg = pstr</span>
            <span class="s1">self.pstr = </span><span class="s2">&quot;&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.msg = msg</span>
            <span class="s1">self.pstr = pstr</span>
        <span class="s1">self.parserElement = elem</span>
        <span class="s1">self.args = (pstr</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">msg)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_from_exception(cls</span><span class="s3">, </span><span class="s1">pe):</span>
        <span class="s5">&quot;&quot;&quot; 
        internal factory method to simplify creating one type of ParseException 
        from another - avoids having __init__ signature conflicts among subclasses 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">cls(pe.pstr</span><span class="s3">, </span><span class="s1">pe.loc</span><span class="s3">, </span><span class="s1">pe.msg</span><span class="s3">, </span><span class="s1">pe.parserElement)</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">aname):</span>
        <span class="s5">&quot;&quot;&quot;supported attributes by name are: 
           - lineno - returns the line number of the exception text 
           - col - returns the column number of the exception text 
           - line - returns the line containing the exception text 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">aname == </span><span class="s2">&quot;lineno&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">lineno(self.loc</span><span class="s3">, </span><span class="s1">self.pstr)</span>
        <span class="s3">elif </span><span class="s1">aname </span><span class="s3">in </span><span class="s1">(</span><span class="s2">&quot;col&quot;</span><span class="s3">, </span><span class="s2">&quot;column&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">col(self.loc</span><span class="s3">, </span><span class="s1">self.pstr)</span>
        <span class="s3">elif </span><span class="s1">aname == </span><span class="s2">&quot;line&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">line(self.loc</span><span class="s3">, </span><span class="s1">self.pstr)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">AttributeError(aname)</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">if </span><span class="s1">self.pstr:</span>
            <span class="s3">if </span><span class="s1">self.loc &gt;= len(self.pstr):</span>
                <span class="s1">foundstr = </span><span class="s2">', found end of text'</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">foundstr = (</span><span class="s2">', found %r' </span><span class="s1">% self.pstr[self.loc:self.loc + </span><span class="s4">1</span><span class="s1">]).replace(</span><span class="s2">r'\\'</span><span class="s3">, </span><span class="s2">'</span><span class="s3">\\</span><span class="s2">'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">foundstr = </span><span class="s2">''</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s2">&quot;%s%s  (at char %d), (line:%d, col:%d)&quot; </span><span class="s1">%</span>
                   <span class="s1">(self.msg</span><span class="s3">, </span><span class="s1">foundstr</span><span class="s3">, </span><span class="s1">self.loc</span><span class="s3">, </span><span class="s1">self.lineno</span><span class="s3">, </span><span class="s1">self.column))</span>
    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s1">_ustr(self)</span>
    <span class="s3">def </span><span class="s1">markInputline(self</span><span class="s3">, </span><span class="s1">markerString=</span><span class="s2">&quot;&gt;!&lt;&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Extracts the exception line from the input string, and marks 
           the location of the exception with a special symbol. 
        &quot;&quot;&quot;</span>
        <span class="s1">line_str = self.line</span>
        <span class="s1">line_column = self.column - </span><span class="s4">1</span>
        <span class="s3">if </span><span class="s1">markerString:</span>
            <span class="s1">line_str = </span><span class="s2">&quot;&quot;</span><span class="s1">.join((line_str[:line_column]</span><span class="s3">,</span>
                                <span class="s1">markerString</span><span class="s3">, </span><span class="s1">line_str[line_column:]))</span>
        <span class="s3">return </span><span class="s1">line_str.strip()</span>
    <span class="s3">def </span><span class="s1">__dir__(self):</span>
        <span class="s3">return </span><span class="s2">&quot;lineno col line&quot;</span><span class="s1">.split() + dir(type(self))</span>

<span class="s3">class </span><span class="s1">ParseException(ParseBaseException):</span>
    <span class="s5">&quot;&quot;&quot; 
    Exception thrown when parse expressions don't match class; 
    supported attributes by name are: 
    - lineno - returns the line number of the exception text 
    - col - returns the column number of the exception text 
    - line - returns the line containing the exception text 
 
    Example:: 
 
        try: 
            Word(nums).setName(&quot;integer&quot;).parseString(&quot;ABC&quot;) 
        except ParseException as pe: 
            print(pe) 
            print(&quot;column: {}&quot;.format(pe.col)) 
 
    prints:: 
 
       Expected integer (at char 0), (line:1, col:1) 
        column: 1 
 
    &quot;&quot;&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">explain(exc</span><span class="s3">, </span><span class="s1">depth=</span><span class="s4">16</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Method to take an exception and translate the Python internal traceback into a list 
        of the pyparsing expressions that caused the exception to be raised. 
 
        Parameters: 
 
         - exc - exception raised during parsing (need not be a ParseException, in support 
           of Python exceptions that might be raised in a parse action) 
         - depth (default=16) - number of levels back in the stack trace to list expression 
           and function names; if None, the full stack trace names will be listed; if 0, only 
           the failing input line, marker, and exception string will be shown 
 
        Returns a multi-line string listing the ParserElements and/or function names in the 
        exception's stack trace. 
 
        Note: the diagnostic output will include string representations of the expressions 
        that failed to parse. These representations will be more helpful if you use `setName` to 
        give identifiable names to your expressions. Otherwise they will use the default string 
        forms, which may be cryptic to read. 
 
        explain() is only supported under Python 3. 
        &quot;&quot;&quot;</span>
        <span class="s3">import </span><span class="s1">inspect</span>

        <span class="s3">if </span><span class="s1">depth </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">depth = sys.getrecursionlimit()</span>
        <span class="s1">ret = []</span>
        <span class="s3">if </span><span class="s1">isinstance(exc</span><span class="s3">, </span><span class="s1">ParseBaseException):</span>
            <span class="s1">ret.append(exc.line)</span>
            <span class="s1">ret.append(</span><span class="s2">' ' </span><span class="s1">* (exc.col - </span><span class="s4">1</span><span class="s1">) + </span><span class="s2">'^'</span><span class="s1">)</span>
        <span class="s1">ret.append(</span><span class="s2">&quot;{0}: {1}&quot;</span><span class="s1">.format(type(exc).__name__</span><span class="s3">, </span><span class="s1">exc))</span>

        <span class="s3">if </span><span class="s1">depth &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">callers = inspect.getinnerframes(exc.__traceback__</span><span class="s3">, </span><span class="s1">context=depth)</span>
            <span class="s1">seen = set()</span>
            <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">ff </span><span class="s3">in </span><span class="s1">enumerate(callers[-depth:]):</span>
                <span class="s1">frm = ff[</span><span class="s4">0</span><span class="s1">]</span>

                <span class="s1">f_self = frm.f_locals.get(</span><span class="s2">'self'</span><span class="s3">, None</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">isinstance(f_self</span><span class="s3">, </span><span class="s1">ParserElement):</span>
                    <span class="s3">if </span><span class="s1">frm.f_code.co_name </span><span class="s3">not in </span><span class="s1">(</span><span class="s2">'parseImpl'</span><span class="s3">, </span><span class="s2">'_parseNoCache'</span><span class="s1">):</span>
                        <span class="s3">continue</span>
                    <span class="s3">if </span><span class="s1">f_self </span><span class="s3">in </span><span class="s1">seen:</span>
                        <span class="s3">continue</span>
                    <span class="s1">seen.add(f_self)</span>

                    <span class="s1">self_type = type(f_self)</span>
                    <span class="s1">ret.append(</span><span class="s2">&quot;{0}.{1} - {2}&quot;</span><span class="s1">.format(self_type.__module__</span><span class="s3">,</span>
                                                      <span class="s1">self_type.__name__</span><span class="s3">,</span>
                                                      <span class="s1">f_self))</span>
                <span class="s3">elif </span><span class="s1">f_self </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">self_type = type(f_self)</span>
                    <span class="s1">ret.append(</span><span class="s2">&quot;{0}.{1}&quot;</span><span class="s1">.format(self_type.__module__</span><span class="s3">,</span>
                                                <span class="s1">self_type.__name__))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">code = frm.f_code</span>
                    <span class="s3">if </span><span class="s1">code.co_name </span><span class="s3">in </span><span class="s1">(</span><span class="s2">'wrapper'</span><span class="s3">, </span><span class="s2">'&lt;module&gt;'</span><span class="s1">):</span>
                        <span class="s3">continue</span>

                    <span class="s1">ret.append(</span><span class="s2">&quot;{0}&quot;</span><span class="s1">.format(code.co_name))</span>

                <span class="s1">depth -= </span><span class="s4">1</span>
                <span class="s3">if not </span><span class="s1">depth:</span>
                    <span class="s3">break</span>

        <span class="s3">return </span><span class="s2">'</span><span class="s3">\n</span><span class="s2">'</span><span class="s1">.join(ret)</span>


<span class="s3">class </span><span class="s1">ParseFatalException(ParseBaseException):</span>
    <span class="s5">&quot;&quot;&quot;user-throwable exception thrown when inconsistent parse content 
       is found; stops all parsing immediately&quot;&quot;&quot;</span>
    <span class="s3">pass</span>

<span class="s3">class </span><span class="s1">ParseSyntaxException(ParseFatalException):</span>
    <span class="s5">&quot;&quot;&quot;just like :class:`ParseFatalException`, but thrown internally 
    when an :class:`ErrorStop&lt;And._ErrorStop&gt;` ('-' operator) indicates 
    that parsing is to stop immediately because an unbacktrackable 
    syntax error has been found. 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>

<span class="s0">#~ class ReparseException(ParseBaseException):</span>
    <span class="s0">#~ &quot;&quot;&quot;Experimental class - parse actions can raise this exception to cause</span>
       <span class="s0">#~ pyparsing to reparse the input string:</span>
        <span class="s0">#~ - with a modified input string, and/or</span>
        <span class="s0">#~ - with a modified start location</span>
       <span class="s0">#~ Set the values of the ReparseException in the constructor, and raise the</span>
       <span class="s0">#~ exception in a parse action to cause pyparsing to use the new string/location.</span>
       <span class="s0">#~ Setting the values as None causes no change to be made.</span>
       <span class="s0">#~ &quot;&quot;&quot;</span>
    <span class="s0">#~ def __init_( self, newstring, restartLoc ):</span>
        <span class="s0">#~ self.newParseText = newstring</span>
        <span class="s0">#~ self.reparseLoc = restartLoc</span>

<span class="s3">class </span><span class="s1">RecursiveGrammarException(Exception):</span>
    <span class="s5">&quot;&quot;&quot;exception thrown by :class:`ParserElement.validate` if the 
    grammar could be improperly recursive 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">parseElementList):</span>
        <span class="s1">self.parseElementTrace = parseElementList</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s2">&quot;RecursiveGrammarException: %s&quot; </span><span class="s1">% self.parseElementTrace</span>

<span class="s3">class </span><span class="s1">_ParseResultsWithOffset(object):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">, </span><span class="s1">p2):</span>
        <span class="s1">self.tup = (p1</span><span class="s3">, </span><span class="s1">p2)</span>
    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">i):</span>
        <span class="s3">return </span><span class="s1">self.tup[i]</span>
    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s1">repr(self.tup[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s3">def </span><span class="s1">setOffset(self</span><span class="s3">, </span><span class="s1">i):</span>
        <span class="s1">self.tup = (self.tup[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">i)</span>

<span class="s3">class </span><span class="s1">ParseResults(object):</span>
    <span class="s5">&quot;&quot;&quot;Structured parse results, to provide multiple means of access to 
    the parsed data: 
 
       - as a list (``len(results)``) 
       - by list index (``results[0], results[1]``, etc.) 
       - by attribute (``results.&lt;resultsName&gt;`` - see :class:`ParserElement.setResultsName`) 
 
    Example:: 
 
        integer = Word(nums) 
        date_str = (integer.setResultsName(&quot;year&quot;) + '/' 
                        + integer.setResultsName(&quot;month&quot;) + '/' 
                        + integer.setResultsName(&quot;day&quot;)) 
        # equivalent form: 
        # date_str = integer(&quot;year&quot;) + '/' + integer(&quot;month&quot;) + '/' + integer(&quot;day&quot;) 
 
        # parseString returns a ParseResults object 
        result = date_str.parseString(&quot;1999/12/31&quot;) 
 
        def test(s, fn=repr): 
            print(&quot;%s -&gt; %s&quot; % (s, fn(eval(s)))) 
        test(&quot;list(result)&quot;) 
        test(&quot;result[0]&quot;) 
        test(&quot;result['month']&quot;) 
        test(&quot;result.day&quot;) 
        test(&quot;'month' in result&quot;) 
        test(&quot;'minutes' in result&quot;) 
        test(&quot;result.dump()&quot;, str) 
 
    prints:: 
 
        list(result) -&gt; ['1999', '/', '12', '/', '31'] 
        result[0] -&gt; '1999' 
        result['month'] -&gt; '12' 
        result.day -&gt; '31' 
        'month' in result -&gt; True 
        'minutes' in result -&gt; False 
        result.dump() -&gt; ['1999', '/', '12', '/', '31'] 
        - day: 31 
        - month: 12 
        - year: 1999 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">toklist=</span><span class="s3">None, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">asList=</span><span class="s3">True, </span><span class="s1">modal=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">isinstance(toklist</span><span class="s3">, </span><span class="s1">cls):</span>
            <span class="s3">return </span><span class="s1">toklist</span>
        <span class="s1">retobj = object.__new__(cls)</span>
        <span class="s1">retobj.__doinit = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">retobj</span>

    <span class="s0"># Performance tuning: we construct a *lot* of these, so keep this</span>
    <span class="s0"># constructor as small and fast as possible</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">toklist=</span><span class="s3">None, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">asList=</span><span class="s3">True, </span><span class="s1">modal=</span><span class="s3">True, </span><span class="s1">isinstance=isinstance):</span>
        <span class="s3">if </span><span class="s1">self.__doinit:</span>
            <span class="s1">self.__doinit = </span><span class="s3">False</span>
            <span class="s1">self.__name = </span><span class="s3">None</span>
            <span class="s1">self.__parent = </span><span class="s3">None</span>
            <span class="s1">self.__accumNames = {}</span>
            <span class="s1">self.__asList = asList</span>
            <span class="s1">self.__modal = modal</span>
            <span class="s3">if </span><span class="s1">toklist </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">toklist = []</span>
            <span class="s3">if </span><span class="s1">isinstance(toklist</span><span class="s3">, </span><span class="s1">list):</span>
                <span class="s1">self.__toklist = toklist[:]</span>
            <span class="s3">elif </span><span class="s1">isinstance(toklist</span><span class="s3">, </span><span class="s1">_generatorType):</span>
                <span class="s1">self.__toklist = list(toklist)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.__toklist = [toklist]</span>
            <span class="s1">self.__tokdict = dict()</span>

        <span class="s3">if </span><span class="s1">name </span><span class="s3">is not None and </span><span class="s1">name:</span>
            <span class="s3">if not </span><span class="s1">modal:</span>
                <span class="s1">self.__accumNames[name] = </span><span class="s4">0</span>
            <span class="s3">if </span><span class="s1">isinstance(name</span><span class="s3">, </span><span class="s1">int):</span>
                <span class="s1">name = _ustr(name)  </span><span class="s0"># will always return a str, but use _ustr for consistency</span>
            <span class="s1">self.__name = name</span>
            <span class="s3">if not </span><span class="s1">(isinstance(toklist</span><span class="s3">, </span><span class="s1">(type(</span><span class="s3">None</span><span class="s1">)</span><span class="s3">, </span><span class="s1">basestring</span><span class="s3">, </span><span class="s1">list)) </span><span class="s3">and </span><span class="s1">toklist </span><span class="s3">in </span><span class="s1">(</span><span class="s3">None, </span><span class="s2">''</span><span class="s3">, </span><span class="s1">[])):</span>
                <span class="s3">if </span><span class="s1">isinstance(toklist</span><span class="s3">, </span><span class="s1">basestring):</span>
                    <span class="s1">toklist = [toklist]</span>
                <span class="s3">if </span><span class="s1">asList:</span>
                    <span class="s3">if </span><span class="s1">isinstance(toklist</span><span class="s3">, </span><span class="s1">ParseResults):</span>
                        <span class="s1">self[name] = _ParseResultsWithOffset(ParseResults(toklist.__toklist)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">self[name] = _ParseResultsWithOffset(ParseResults(toklist[</span><span class="s4">0</span><span class="s1">])</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s1">self[name].__name = name</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">self[name] = toklist[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s3">except </span><span class="s1">(KeyError</span><span class="s3">, </span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">IndexError):</span>
                        <span class="s1">self[name] = toklist</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">i):</span>
        <span class="s3">if </span><span class="s1">isinstance(i</span><span class="s3">, </span><span class="s1">(int</span><span class="s3">, </span><span class="s1">slice)):</span>
            <span class="s3">return </span><span class="s1">self.__toklist[i]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">i </span><span class="s3">not in </span><span class="s1">self.__accumNames:</span>
                <span class="s3">return </span><span class="s1">self.__tokdict[i][-</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">ParseResults([v[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.__tokdict[i]])</span>

    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">isinstance=isinstance):</span>
        <span class="s3">if </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">_ParseResultsWithOffset):</span>
            <span class="s1">self.__tokdict[k] = self.__tokdict.get(k</span><span class="s3">, </span><span class="s1">list()) + [v]</span>
            <span class="s1">sub = v[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">elif </span><span class="s1">isinstance(k</span><span class="s3">, </span><span class="s1">(int</span><span class="s3">, </span><span class="s1">slice)):</span>
            <span class="s1">self.__toklist[k] = v</span>
            <span class="s1">sub = v</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.__tokdict[k] = self.__tokdict.get(k</span><span class="s3">, </span><span class="s1">list()) + [_ParseResultsWithOffset(v</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)]</span>
            <span class="s1">sub = v</span>
        <span class="s3">if </span><span class="s1">isinstance(sub</span><span class="s3">, </span><span class="s1">ParseResults):</span>
            <span class="s1">sub.__parent = wkref(self)</span>

    <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">i):</span>
        <span class="s3">if </span><span class="s1">isinstance(i</span><span class="s3">, </span><span class="s1">(int</span><span class="s3">, </span><span class="s1">slice)):</span>
            <span class="s1">mylen = len(self.__toklist)</span>
            <span class="s3">del </span><span class="s1">self.__toklist[i]</span>

            <span class="s0"># convert int to slice</span>
            <span class="s3">if </span><span class="s1">isinstance(i</span><span class="s3">, </span><span class="s1">int):</span>
                <span class="s3">if </span><span class="s1">i &lt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">i += mylen</span>
                <span class="s1">i = slice(i</span><span class="s3">, </span><span class="s1">i + </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s0"># get removed indices</span>
            <span class="s1">removed = list(range(*i.indices(mylen)))</span>
            <span class="s1">removed.reverse()</span>
            <span class="s0"># fixup indices in token dictionary</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">occurrences </span><span class="s3">in </span><span class="s1">self.__tokdict.items():</span>
                <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">removed:</span>
                    <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">(value</span><span class="s3">, </span><span class="s1">position) </span><span class="s3">in </span><span class="s1">enumerate(occurrences):</span>
                        <span class="s1">occurrences[k] = _ParseResultsWithOffset(value</span><span class="s3">, </span><span class="s1">position - (position &gt; j))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">del </span><span class="s1">self.__tokdict[i]</span>

    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">k):</span>
        <span class="s3">return </span><span class="s1">k </span><span class="s3">in </span><span class="s1">self.__tokdict</span>

    <span class="s3">def </span><span class="s1">__len__(self):</span>
        <span class="s3">return </span><span class="s1">len(self.__toklist)</span>

    <span class="s3">def </span><span class="s1">__bool__(self):</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s3">not not </span><span class="s1">self.__toklist)</span>
    <span class="s1">__nonzero__ = __bool__</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s3">return </span><span class="s1">iter(self.__toklist)</span>

    <span class="s3">def </span><span class="s1">__reversed__(self):</span>
        <span class="s3">return </span><span class="s1">iter(self.__toklist[::-</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">_iterkeys(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self.__tokdict</span><span class="s3">, </span><span class="s2">&quot;iterkeys&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.__tokdict.iterkeys()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">iter(self.__tokdict)</span>

    <span class="s3">def </span><span class="s1">_itervalues(self):</span>
        <span class="s3">return </span><span class="s1">(self[k] </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">self._iterkeys())</span>

    <span class="s3">def </span><span class="s1">_iteritems(self):</span>
        <span class="s3">return </span><span class="s1">((k</span><span class="s3">, </span><span class="s1">self[k]) </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">self._iterkeys())</span>

    <span class="s3">if </span><span class="s1">PY_3:</span>
        <span class="s1">keys = _iterkeys</span>
        <span class="s2">&quot;&quot;&quot;Returns an iterator of all named result keys.&quot;&quot;&quot;</span>

        <span class="s1">values = _itervalues</span>
        <span class="s2">&quot;&quot;&quot;Returns an iterator of all named result values.&quot;&quot;&quot;</span>

        <span class="s1">items = _iteritems</span>
        <span class="s2">&quot;&quot;&quot;Returns an iterator of all named result key-value tuples.&quot;&quot;&quot;</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">iterkeys = _iterkeys</span>
        <span class="s2">&quot;&quot;&quot;Returns an iterator of all named result keys (Python 2.x only).&quot;&quot;&quot;</span>

        <span class="s1">itervalues = _itervalues</span>
        <span class="s2">&quot;&quot;&quot;Returns an iterator of all named result values (Python 2.x only).&quot;&quot;&quot;</span>

        <span class="s1">iteritems = _iteritems</span>
        <span class="s2">&quot;&quot;&quot;Returns an iterator of all named result key-value tuples (Python 2.x only).&quot;&quot;&quot;</span>

        <span class="s3">def </span><span class="s1">keys(self):</span>
            <span class="s5">&quot;&quot;&quot;Returns all named result keys (as a list in Python 2.x, as an iterator in Python 3.x).&quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">list(self.iterkeys())</span>

        <span class="s3">def </span><span class="s1">values(self):</span>
            <span class="s5">&quot;&quot;&quot;Returns all named result values (as a list in Python 2.x, as an iterator in Python 3.x).&quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">list(self.itervalues())</span>

        <span class="s3">def </span><span class="s1">items(self):</span>
            <span class="s5">&quot;&quot;&quot;Returns all named result key-values (as a list of tuples in Python 2.x, as an iterator in Python 3.x).&quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">list(self.iteritems())</span>

    <span class="s3">def </span><span class="s1">haskeys(self):</span>
        <span class="s5">&quot;&quot;&quot;Since keys() returns an iterator, this method is helpful in bypassing 
           code that looks for the existence of any defined results names.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">bool(self.__tokdict)</span>

    <span class="s3">def </span><span class="s1">pop(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot; 
        Removes and returns item at specified index (default= ``last``). 
        Supports both ``list`` and ``dict`` semantics for ``pop()``. If 
        passed no argument or an integer argument, it will use ``list`` 
        semantics and pop tokens from the list of parsed tokens. If passed 
        a non-integer argument (most likely a string), it will use ``dict`` 
        semantics and pop the corresponding value from any defined results 
        names. A second default return value argument is supported, just as in 
        ``dict.pop()``. 
 
        Example:: 
 
            def remove_first(tokens): 
                tokens.pop(0) 
            print(OneOrMore(Word(nums)).parseString(&quot;0 123 321&quot;)) # -&gt; ['0', '123', '321'] 
            print(OneOrMore(Word(nums)).addParseAction(remove_first).parseString(&quot;0 123 321&quot;)) # -&gt; ['123', '321'] 
 
            label = Word(alphas) 
            patt = label(&quot;LABEL&quot;) + OneOrMore(Word(nums)) 
            print(patt.parseString(&quot;AAB 123 321&quot;).dump()) 
 
            # Use pop() in a parse action to remove named result (note that corresponding value is not 
            # removed from list form of results) 
            def remove_LABEL(tokens): 
                tokens.pop(&quot;LABEL&quot;) 
                return tokens 
            patt.addParseAction(remove_LABEL) 
            print(patt.parseString(&quot;AAB 123 321&quot;).dump()) 
 
        prints:: 
 
            ['AAB', '123', '321'] 
            - LABEL: AAB 
 
            ['AAB', '123', '321'] 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">args:</span>
            <span class="s1">args = [-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">kwargs.items():</span>
            <span class="s3">if </span><span class="s1">k == </span><span class="s2">'default'</span><span class="s1">:</span>
                <span class="s1">args = (args[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">v)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;pop() got an unexpected keyword argument '%s'&quot; </span><span class="s1">% k)</span>
        <span class="s3">if </span><span class="s1">(isinstance(args[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">int)</span>
                <span class="s3">or </span><span class="s1">len(args) == </span><span class="s4">1</span>
                <span class="s3">or </span><span class="s1">args[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">self):</span>
            <span class="s1">index = args[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">ret = self[index]</span>
            <span class="s3">del </span><span class="s1">self[index]</span>
            <span class="s3">return </span><span class="s1">ret</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">defaultvalue = args[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s3">return </span><span class="s1">defaultvalue</span>

    <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">defaultValue=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns named result matching the given key, or if there is no 
        such name, then returns the given ``defaultValue`` or ``None`` if no 
        ``defaultValue`` is specified. 
 
        Similar to ``dict.get()``. 
 
        Example:: 
 
            integer = Word(nums) 
            date_str = integer(&quot;year&quot;) + '/' + integer(&quot;month&quot;) + '/' + integer(&quot;day&quot;) 
 
            result = date_str.parseString(&quot;1999/12/31&quot;) 
            print(result.get(&quot;year&quot;)) # -&gt; '1999' 
            print(result.get(&quot;hour&quot;, &quot;not specified&quot;)) # -&gt; 'not specified' 
            print(result.get(&quot;hour&quot;)) # -&gt; None 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self:</span>
            <span class="s3">return </span><span class="s1">self[key]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">defaultValue</span>

    <span class="s3">def </span><span class="s1">insert(self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">insStr):</span>
        <span class="s5">&quot;&quot;&quot; 
        Inserts new element at location index in the list of parsed tokens. 
 
        Similar to ``list.insert()``. 
 
        Example:: 
 
            print(OneOrMore(Word(nums)).parseString(&quot;0 123 321&quot;)) # -&gt; ['0', '123', '321'] 
 
            # use a parse action to insert the parse location in the front of the parsed results 
            def insert_locn(locn, tokens): 
                tokens.insert(0, locn) 
            print(OneOrMore(Word(nums)).addParseAction(insert_locn).parseString(&quot;0 123 321&quot;)) # -&gt; [0, '0', '123', '321'] 
        &quot;&quot;&quot;</span>
        <span class="s1">self.__toklist.insert(index</span><span class="s3">, </span><span class="s1">insStr)</span>
        <span class="s0"># fixup indices in token dictionary</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">occurrences </span><span class="s3">in </span><span class="s1">self.__tokdict.items():</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">(value</span><span class="s3">, </span><span class="s1">position) </span><span class="s3">in </span><span class="s1">enumerate(occurrences):</span>
                <span class="s1">occurrences[k] = _ParseResultsWithOffset(value</span><span class="s3">, </span><span class="s1">position + (position &gt; index))</span>

    <span class="s3">def </span><span class="s1">append(self</span><span class="s3">, </span><span class="s1">item):</span>
        <span class="s5">&quot;&quot;&quot; 
        Add single element to end of ParseResults list of elements. 
 
        Example:: 
 
            print(OneOrMore(Word(nums)).parseString(&quot;0 123 321&quot;)) # -&gt; ['0', '123', '321'] 
 
            # use a parse action to compute the sum of the parsed integers, and add it to the end 
            def append_sum(tokens): 
                tokens.append(sum(map(int, tokens))) 
            print(OneOrMore(Word(nums)).addParseAction(append_sum).parseString(&quot;0 123 321&quot;)) # -&gt; ['0', '123', '321', 444] 
        &quot;&quot;&quot;</span>
        <span class="s1">self.__toklist.append(item)</span>

    <span class="s3">def </span><span class="s1">extend(self</span><span class="s3">, </span><span class="s1">itemseq):</span>
        <span class="s5">&quot;&quot;&quot; 
        Add sequence of elements to end of ParseResults list of elements. 
 
        Example:: 
 
            patt = OneOrMore(Word(alphas)) 
 
            # use a parse action to append the reverse of the matched strings, to make a palindrome 
            def make_palindrome(tokens): 
                tokens.extend(reversed([t[::-1] for t in tokens])) 
                return ''.join(tokens) 
            print(patt.addParseAction(make_palindrome).parseString(&quot;lskdj sdlkjf lksd&quot;)) # -&gt; 'lskdjsdlkjflksddsklfjkldsjdksl' 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(itemseq</span><span class="s3">, </span><span class="s1">ParseResults):</span>
            <span class="s1">self.__iadd__(itemseq)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.__toklist.extend(itemseq)</span>

    <span class="s3">def </span><span class="s1">clear(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Clear all elements and results names. 
        &quot;&quot;&quot;</span>
        <span class="s3">del </span><span class="s1">self.__toklist[:]</span>
        <span class="s1">self.__tokdict.clear()</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self[name]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">return </span><span class="s2">&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__add__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">ret = self.copy()</span>
        <span class="s1">ret += other</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">__iadd__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">other.__tokdict:</span>
            <span class="s1">offset = len(self.__toklist)</span>
            <span class="s1">addoffset = </span><span class="s3">lambda </span><span class="s1">a: offset </span><span class="s3">if </span><span class="s1">a &lt; </span><span class="s4">0 </span><span class="s3">else </span><span class="s1">a + offset</span>
            <span class="s1">otheritems = other.__tokdict.items()</span>
            <span class="s1">otherdictitems = [(k</span><span class="s3">, </span><span class="s1">_ParseResultsWithOffset(v[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">addoffset(v[</span><span class="s4">1</span><span class="s1">])))</span>
                              <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">vlist </span><span class="s3">in </span><span class="s1">otheritems </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">vlist]</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">otherdictitems:</span>
                <span class="s1">self[k] = v</span>
                <span class="s3">if </span><span class="s1">isinstance(v[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ParseResults):</span>
                    <span class="s1">v[</span><span class="s4">0</span><span class="s1">].__parent = wkref(self)</span>

        <span class="s1">self.__toklist += other.__toklist</span>
        <span class="s1">self.__accumNames.update(other.__accumNames)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__radd__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">int) </span><span class="s3">and </span><span class="s1">other == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># useful for merging many ParseResults using sum() builtin</span>
            <span class="s3">return </span><span class="s1">self.copy()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># this may raise a TypeError - so be it</span>
            <span class="s3">return </span><span class="s1">other + self</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s2">&quot;(%s, %s)&quot; </span><span class="s1">% (repr(self.__toklist)</span><span class="s3">, </span><span class="s1">repr(self.__tokdict))</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s2">'[' </span><span class="s1">+ </span><span class="s2">', '</span><span class="s1">.join(_ustr(i) </span><span class="s3">if </span><span class="s1">isinstance(i</span><span class="s3">, </span><span class="s1">ParseResults) </span><span class="s3">else </span><span class="s1">repr(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">self.__toklist) + </span><span class="s2">']'</span>

    <span class="s3">def </span><span class="s1">_asStringList(self</span><span class="s3">, </span><span class="s1">sep=</span><span class="s2">''</span><span class="s1">):</span>
        <span class="s1">out = []</span>
        <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">self.__toklist:</span>
            <span class="s3">if </span><span class="s1">out </span><span class="s3">and </span><span class="s1">sep:</span>
                <span class="s1">out.append(sep)</span>
            <span class="s3">if </span><span class="s1">isinstance(item</span><span class="s3">, </span><span class="s1">ParseResults):</span>
                <span class="s1">out += item._asStringList()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">out.append(_ustr(item))</span>
        <span class="s3">return </span><span class="s1">out</span>

    <span class="s3">def </span><span class="s1">asList(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the parse results as a nested list of matching tokens, all converted to strings. 
 
        Example:: 
 
            patt = OneOrMore(Word(alphas)) 
            result = patt.parseString(&quot;sldkj lsdkj sldkj&quot;) 
            # even though the result prints in string-like form, it is actually a pyparsing ParseResults 
            print(type(result), result) # -&gt; &lt;class 'pyparsing.ParseResults'&gt; ['sldkj', 'lsdkj', 'sldkj'] 
 
            # Use asList() to create an actual list 
            result_list = result.asList() 
            print(type(result_list), result_list) # -&gt; &lt;class 'list'&gt; ['sldkj', 'lsdkj', 'sldkj'] 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">[res.asList() </span><span class="s3">if </span><span class="s1">isinstance(res</span><span class="s3">, </span><span class="s1">ParseResults) </span><span class="s3">else </span><span class="s1">res </span><span class="s3">for </span><span class="s1">res </span><span class="s3">in </span><span class="s1">self.__toklist]</span>

    <span class="s3">def </span><span class="s1">asDict(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the named parse results as a nested dictionary. 
 
        Example:: 
 
            integer = Word(nums) 
            date_str = integer(&quot;year&quot;) + '/' + integer(&quot;month&quot;) + '/' + integer(&quot;day&quot;) 
 
            result = date_str.parseString('12/31/1999') 
            print(type(result), repr(result)) # -&gt; &lt;class 'pyparsing.ParseResults'&gt; (['12', '/', '31', '/', '1999'], {'day': [('1999', 4)], 'year': [('12', 0)], 'month': [('31', 2)]}) 
 
            result_dict = result.asDict() 
            print(type(result_dict), repr(result_dict)) # -&gt; &lt;class 'dict'&gt; {'day': '1999', 'year': '12', 'month': '31'} 
 
            # even though a ParseResults supports dict-like access, sometime you just need to have a dict 
            import json 
            print(json.dumps(result)) # -&gt; Exception: TypeError: ... is not JSON serializable 
            print(json.dumps(result.asDict())) # -&gt; {&quot;month&quot;: &quot;31&quot;, &quot;day&quot;: &quot;1999&quot;, &quot;year&quot;: &quot;12&quot;} 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">PY_3:</span>
            <span class="s1">item_fn = self.items</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">item_fn = self.iteritems</span>

        <span class="s3">def </span><span class="s1">toItem(obj):</span>
            <span class="s3">if </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">ParseResults):</span>
                <span class="s3">if </span><span class="s1">obj.haskeys():</span>
                    <span class="s3">return </span><span class="s1">obj.asDict()</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">[toItem(v) </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">obj]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">obj</span>

        <span class="s3">return </span><span class="s1">dict((k</span><span class="s3">, </span><span class="s1">toItem(v)) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">item_fn())</span>

    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns a new copy of a :class:`ParseResults` object. 
        &quot;&quot;&quot;</span>
        <span class="s1">ret = ParseResults(self.__toklist)</span>
        <span class="s1">ret.__tokdict = dict(self.__tokdict.items())</span>
        <span class="s1">ret.__parent = self.__parent</span>
        <span class="s1">ret.__accumNames.update(self.__accumNames)</span>
        <span class="s1">ret.__name = self.__name</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">asXML(self</span><span class="s3">, </span><span class="s1">doctag=</span><span class="s3">None, </span><span class="s1">namedItemsOnly=</span><span class="s3">False, </span><span class="s1">indent=</span><span class="s2">&quot;&quot;</span><span class="s3">, </span><span class="s1">formatted=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        (Deprecated) Returns the parse results as XML. Tags are created for tokens and lists that have defined results names. 
        &quot;&quot;&quot;</span>
        <span class="s1">nl = </span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s1">out = []</span>
        <span class="s1">namedItems = dict((v[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">k) </span><span class="s3">for </span><span class="s1">(k</span><span class="s3">, </span><span class="s1">vlist) </span><span class="s3">in </span><span class="s1">self.__tokdict.items()</span>
                          <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">vlist)</span>
        <span class="s1">nextLevelIndent = indent + </span><span class="s2">&quot;  &quot;</span>

        <span class="s0"># collapse out indents if formatting is not desired</span>
        <span class="s3">if not </span><span class="s1">formatted:</span>
            <span class="s1">indent = </span><span class="s2">&quot;&quot;</span>
            <span class="s1">nextLevelIndent = </span><span class="s2">&quot;&quot;</span>
            <span class="s1">nl = </span><span class="s2">&quot;&quot;</span>

        <span class="s1">selfTag = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">doctag </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">selfTag = doctag</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.__name:</span>
                <span class="s1">selfTag = self.__name</span>

        <span class="s3">if not </span><span class="s1">selfTag:</span>
            <span class="s3">if </span><span class="s1">namedItemsOnly:</span>
                <span class="s3">return </span><span class="s2">&quot;&quot;</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">selfTag = </span><span class="s2">&quot;ITEM&quot;</span>

        <span class="s1">out += [nl</span><span class="s3">, </span><span class="s1">indent</span><span class="s3">, </span><span class="s2">&quot;&lt;&quot;</span><span class="s3">, </span><span class="s1">selfTag</span><span class="s3">, </span><span class="s2">&quot;&gt;&quot;</span><span class="s1">]</span>

        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">res </span><span class="s3">in </span><span class="s1">enumerate(self.__toklist):</span>
            <span class="s3">if </span><span class="s1">isinstance(res</span><span class="s3">, </span><span class="s1">ParseResults):</span>
                <span class="s3">if </span><span class="s1">i </span><span class="s3">in </span><span class="s1">namedItems:</span>
                    <span class="s1">out += [res.asXML(namedItems[i]</span><span class="s3">,</span>
                                      <span class="s1">namedItemsOnly </span><span class="s3">and </span><span class="s1">doctag </span><span class="s3">is None,</span>
                                      <span class="s1">nextLevelIndent</span><span class="s3">,</span>
                                      <span class="s1">formatted)]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">out += [res.asXML(</span><span class="s3">None,</span>
                                      <span class="s1">namedItemsOnly </span><span class="s3">and </span><span class="s1">doctag </span><span class="s3">is None,</span>
                                      <span class="s1">nextLevelIndent</span><span class="s3">,</span>
                                      <span class="s1">formatted)]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># individual token, see if there is a name for it</span>
                <span class="s1">resTag = </span><span class="s3">None</span>
                <span class="s3">if </span><span class="s1">i </span><span class="s3">in </span><span class="s1">namedItems:</span>
                    <span class="s1">resTag = namedItems[i]</span>
                <span class="s3">if not </span><span class="s1">resTag:</span>
                    <span class="s3">if </span><span class="s1">namedItemsOnly:</span>
                        <span class="s3">continue</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">resTag = </span><span class="s2">&quot;ITEM&quot;</span>
                <span class="s1">xmlBodyText = _xml_escape(_ustr(res))</span>
                <span class="s1">out += [nl</span><span class="s3">, </span><span class="s1">nextLevelIndent</span><span class="s3">, </span><span class="s2">&quot;&lt;&quot;</span><span class="s3">, </span><span class="s1">resTag</span><span class="s3">, </span><span class="s2">&quot;&gt;&quot;</span><span class="s3">,</span>
                        <span class="s1">xmlBodyText</span><span class="s3">,</span>
                                                <span class="s2">&quot;&lt;/&quot;</span><span class="s3">, </span><span class="s1">resTag</span><span class="s3">, </span><span class="s2">&quot;&gt;&quot;</span><span class="s1">]</span>

        <span class="s1">out += [nl</span><span class="s3">, </span><span class="s1">indent</span><span class="s3">, </span><span class="s2">&quot;&lt;/&quot;</span><span class="s3">, </span><span class="s1">selfTag</span><span class="s3">, </span><span class="s2">&quot;&gt;&quot;</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">.join(out)</span>

    <span class="s3">def </span><span class="s1">__lookup(self</span><span class="s3">, </span><span class="s1">sub):</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">vlist </span><span class="s3">in </span><span class="s1">self.__tokdict.items():</span>
            <span class="s3">for </span><span class="s1">v</span><span class="s3">, </span><span class="s1">loc </span><span class="s3">in </span><span class="s1">vlist:</span>
                <span class="s3">if </span><span class="s1">sub </span><span class="s3">is </span><span class="s1">v:</span>
                    <span class="s3">return </span><span class="s1">k</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">getName(self):</span>
        <span class="s5">r&quot;&quot;&quot; 
        Returns the results name for this token expression. Useful when several 
        different expressions might match at a particular location. 
 
        Example:: 
 
            integer = Word(nums) 
            ssn_expr = Regex(r&quot;\d\d\d-\d\d-\d\d\d\d&quot;) 
            house_number_expr = Suppress('#') + Word(nums, alphanums) 
            user_data = (Group(house_number_expr)(&quot;house_number&quot;) 
                        | Group(ssn_expr)(&quot;ssn&quot;) 
                        | Group(integer)(&quot;age&quot;)) 
            user_info = OneOrMore(user_data) 
 
            result = user_info.parseString(&quot;22 111-22-3333 #221B&quot;) 
            for item in result: 
                print(item.getName(), ':', item[0]) 
 
        prints:: 
 
            age : 22 
            ssn : 111-22-3333 
            house_number : 221B 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.__name:</span>
            <span class="s3">return </span><span class="s1">self.__name</span>
        <span class="s3">elif </span><span class="s1">self.__parent:</span>
            <span class="s1">par = self.__parent()</span>
            <span class="s3">if </span><span class="s1">par:</span>
                <span class="s3">return </span><span class="s1">par.__lookup(self)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return None</span>
        <span class="s3">elif </span><span class="s1">(len(self) == </span><span class="s4">1</span>
              <span class="s3">and </span><span class="s1">len(self.__tokdict) == </span><span class="s4">1</span>
              <span class="s3">and </span><span class="s1">next(iter(self.__tokdict.values()))[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] </span><span class="s3">in </span><span class="s1">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)):</span>
            <span class="s3">return </span><span class="s1">next(iter(self.__tokdict.keys()))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">dump(self</span><span class="s3">, </span><span class="s1">indent=</span><span class="s2">''</span><span class="s3">, </span><span class="s1">full=</span><span class="s3">True, </span><span class="s1">include_list=</span><span class="s3">True, </span><span class="s1">_depth=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Diagnostic method for listing out the contents of 
        a :class:`ParseResults`. Accepts an optional ``indent`` argument so 
        that this string can be embedded in a nested display of other data. 
 
        Example:: 
 
            integer = Word(nums) 
            date_str = integer(&quot;year&quot;) + '/' + integer(&quot;month&quot;) + '/' + integer(&quot;day&quot;) 
 
            result = date_str.parseString('12/31/1999') 
            print(result.dump()) 
 
        prints:: 
 
            ['12', '/', '31', '/', '1999'] 
            - day: 1999 
            - month: 31 
            - year: 12 
        &quot;&quot;&quot;</span>
        <span class="s1">out = []</span>
        <span class="s1">NL = </span><span class="s2">'</span><span class="s3">\n</span><span class="s2">'</span>
        <span class="s3">if </span><span class="s1">include_list:</span>
            <span class="s1">out.append(indent + _ustr(self.asList()))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">out.append(</span><span class="s2">''</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">full:</span>
            <span class="s3">if </span><span class="s1">self.haskeys():</span>
                <span class="s1">items = sorted((str(k)</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.items())</span>
                <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">items:</span>
                    <span class="s3">if </span><span class="s1">out:</span>
                        <span class="s1">out.append(NL)</span>
                    <span class="s1">out.append(</span><span class="s2">&quot;%s%s- %s: &quot; </span><span class="s1">% (indent</span><span class="s3">, </span><span class="s1">(</span><span class="s2">'  ' </span><span class="s1">* _depth)</span><span class="s3">, </span><span class="s1">k))</span>
                    <span class="s3">if </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">ParseResults):</span>
                        <span class="s3">if </span><span class="s1">v:</span>
                            <span class="s1">out.append(v.dump(indent=indent</span><span class="s3">, </span><span class="s1">full=full</span><span class="s3">, </span><span class="s1">include_list=include_list</span><span class="s3">, </span><span class="s1">_depth=_depth + </span><span class="s4">1</span><span class="s1">))</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s1">out.append(_ustr(v))</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">out.append(repr(v))</span>
            <span class="s3">elif </span><span class="s1">any(isinstance(vv</span><span class="s3">, </span><span class="s1">ParseResults) </span><span class="s3">for </span><span class="s1">vv </span><span class="s3">in </span><span class="s1">self):</span>
                <span class="s1">v = self</span>
                <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">vv </span><span class="s3">in </span><span class="s1">enumerate(v):</span>
                    <span class="s3">if </span><span class="s1">isinstance(vv</span><span class="s3">, </span><span class="s1">ParseResults):</span>
                        <span class="s1">out.append(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">%s%s[%d]:</span><span class="s3">\n</span><span class="s2">%s%s%s&quot; </span><span class="s1">% (indent</span><span class="s3">,</span>
                                                            <span class="s1">(</span><span class="s2">'  ' </span><span class="s1">* (_depth))</span><span class="s3">,</span>
                                                            <span class="s1">i</span><span class="s3">,</span>
                                                            <span class="s1">indent</span><span class="s3">,</span>
                                                            <span class="s1">(</span><span class="s2">'  ' </span><span class="s1">* (_depth + </span><span class="s4">1</span><span class="s1">))</span><span class="s3">,</span>
                                                            <span class="s1">vv.dump(indent=indent</span><span class="s3">,</span>
                                                                    <span class="s1">full=full</span><span class="s3">,</span>
                                                                    <span class="s1">include_list=include_list</span><span class="s3">,</span>
                                                                    <span class="s1">_depth=_depth + </span><span class="s4">1</span><span class="s1">)))</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">out.append(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">%s%s[%d]:</span><span class="s3">\n</span><span class="s2">%s%s%s&quot; </span><span class="s1">% (indent</span><span class="s3">,</span>
                                                            <span class="s1">(</span><span class="s2">'  ' </span><span class="s1">* (_depth))</span><span class="s3">,</span>
                                                            <span class="s1">i</span><span class="s3">,</span>
                                                            <span class="s1">indent</span><span class="s3">,</span>
                                                            <span class="s1">(</span><span class="s2">'  ' </span><span class="s1">* (_depth + </span><span class="s4">1</span><span class="s1">))</span><span class="s3">,</span>
                                                            <span class="s1">_ustr(vv)))</span>

        <span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">.join(out)</span>

    <span class="s3">def </span><span class="s1">pprint(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot; 
        Pretty-printer for parsed results as a list, using the 
        `pprint &lt;https://docs.python.org/3/library/pprint.html&gt;`_ module. 
        Accepts additional positional or keyword args as defined for 
        `pprint.pprint &lt;https://docs.python.org/3/library/pprint.html#pprint.pprint&gt;`_ . 
 
        Example:: 
 
            ident = Word(alphas, alphanums) 
            num = Word(nums) 
            func = Forward() 
            term = ident | num | Group('(' + func + ')') 
            func &lt;&lt;= ident + Group(Optional(delimitedList(term))) 
            result = func.parseString(&quot;fna a,b,(fnb c,d,200),100&quot;) 
            result.pprint(width=40) 
 
        prints:: 
 
            ['fna', 
             ['a', 
              'b', 
              ['(', 'fnb', ['c', 'd', '200'], ')'], 
              '100']] 
        &quot;&quot;&quot;</span>
        <span class="s1">pprint.pprint(self.asList()</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s0"># add support for pickle protocol</span>
    <span class="s3">def </span><span class="s1">__getstate__(self):</span>
        <span class="s3">return </span><span class="s1">(self.__toklist</span><span class="s3">,</span>
                <span class="s1">(self.__tokdict.copy()</span><span class="s3">,</span>
                 <span class="s1">self.__parent </span><span class="s3">is not None and </span><span class="s1">self.__parent() </span><span class="s3">or None,</span>
                 <span class="s1">self.__accumNames</span><span class="s3">,</span>
                 <span class="s1">self.__name))</span>

    <span class="s3">def </span><span class="s1">__setstate__(self</span><span class="s3">, </span><span class="s1">state):</span>
        <span class="s1">self.__toklist = state[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.__tokdict</span><span class="s3">, </span><span class="s1">par</span><span class="s3">, </span><span class="s1">inAccumNames</span><span class="s3">, </span><span class="s1">self.__name = state[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self.__accumNames = {}</span>
        <span class="s1">self.__accumNames.update(inAccumNames)</span>
        <span class="s3">if </span><span class="s1">par </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.__parent = wkref(par)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.__parent = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__getnewargs__(self):</span>
        <span class="s3">return </span><span class="s1">self.__toklist</span><span class="s3">, </span><span class="s1">self.__name</span><span class="s3">, </span><span class="s1">self.__asList</span><span class="s3">, </span><span class="s1">self.__modal</span>

    <span class="s3">def </span><span class="s1">__dir__(self):</span>
        <span class="s3">return </span><span class="s1">dir(type(self)) + list(self.keys())</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">from_dict(cls</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Helper classmethod to construct a ParseResults from a dict, preserving the 
        name-value relations as results names. If an optional 'name' argument is 
        given, a nested ParseResults will be returned 
        &quot;&quot;&quot;</span>
        <span class="s3">def </span><span class="s1">is_iterable(obj):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">iter(obj)</span>
            <span class="s3">except </span><span class="s1">Exception:</span>
                <span class="s3">return False</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">PY_3:</span>
                    <span class="s3">return not </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">(str</span><span class="s3">, </span><span class="s1">bytes))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">return not </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">basestring)</span>

        <span class="s1">ret = cls([])</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">other.items():</span>
            <span class="s3">if </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">Mapping):</span>
                <span class="s1">ret += cls.from_dict(v</span><span class="s3">, </span><span class="s1">name=k)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ret += cls([v]</span><span class="s3">, </span><span class="s1">name=k</span><span class="s3">, </span><span class="s1">asList=is_iterable(v))</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">ret = cls([ret]</span><span class="s3">, </span><span class="s1">name=name)</span>
        <span class="s3">return </span><span class="s1">ret</span>

<span class="s1">MutableMapping.register(ParseResults)</span>

<span class="s3">def </span><span class="s1">col (loc</span><span class="s3">, </span><span class="s1">strg):</span>
    <span class="s5">&quot;&quot;&quot;Returns current column within a string, counting newlines as line separators. 
   The first column is number 1. 
 
   Note: the default parsing behavior is to expand tabs in the input string 
   before starting the parsing process.  See 
   :class:`ParserElement.parseString` for more 
   information on parsing strings containing ``&lt;TAB&gt;`` s, and suggested 
   methods to maintain a consistent view of the parsed string, the parse 
   location, and line and column positions within the parsed string. 
   &quot;&quot;&quot;</span>
    <span class="s1">s = strg</span>
    <span class="s3">return </span><span class="s4">1 </span><span class="s3">if </span><span class="s4">0 </span><span class="s1">&lt; loc &lt; len(s) </span><span class="s3">and </span><span class="s1">s[loc-</span><span class="s4">1</span><span class="s1">] == </span><span class="s2">'</span><span class="s3">\n</span><span class="s2">' </span><span class="s3">else </span><span class="s1">loc - s.rfind(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">loc)</span>

<span class="s3">def </span><span class="s1">lineno(loc</span><span class="s3">, </span><span class="s1">strg):</span>
    <span class="s5">&quot;&quot;&quot;Returns current line number within a string, counting newlines as line separators. 
    The first line is number 1. 
 
    Note - the default parsing behavior is to expand tabs in the input string 
    before starting the parsing process.  See :class:`ParserElement.parseString` 
    for more information on parsing strings containing ``&lt;TAB&gt;`` s, and 
    suggested methods to maintain a consistent view of the parsed string, the 
    parse location, and line and column positions within the parsed string. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">strg.count(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">loc) + </span><span class="s4">1</span>

<span class="s3">def </span><span class="s1">line(loc</span><span class="s3">, </span><span class="s1">strg):</span>
    <span class="s5">&quot;&quot;&quot;Returns the line of text containing loc within a string, counting newlines as line separators. 
       &quot;&quot;&quot;</span>
    <span class="s1">lastCR = strg.rfind(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">loc)</span>
    <span class="s1">nextCR = strg.find(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s3">, </span><span class="s1">loc)</span>
    <span class="s3">if </span><span class="s1">nextCR &gt;= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">strg[lastCR + </span><span class="s4">1</span><span class="s1">:nextCR]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">strg[lastCR + </span><span class="s4">1</span><span class="s1">:]</span>

<span class="s3">def </span><span class="s1">_defaultStartDebugAction(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">expr):</span>
    <span class="s1">print((</span><span class="s2">&quot;Match &quot; </span><span class="s1">+ _ustr(expr) + </span><span class="s2">&quot; at loc &quot; </span><span class="s1">+ _ustr(loc) + </span><span class="s2">&quot;(%d,%d)&quot; </span><span class="s1">% (lineno(loc</span><span class="s3">, </span><span class="s1">instring)</span><span class="s3">, </span><span class="s1">col(loc</span><span class="s3">, </span><span class="s1">instring))))</span>

<span class="s3">def </span><span class="s1">_defaultSuccessDebugAction(instring</span><span class="s3">, </span><span class="s1">startloc</span><span class="s3">, </span><span class="s1">endloc</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">toks):</span>
    <span class="s1">print(</span><span class="s2">&quot;Matched &quot; </span><span class="s1">+ _ustr(expr) + </span><span class="s2">&quot; -&gt; &quot; </span><span class="s1">+ str(toks.asList()))</span>

<span class="s3">def </span><span class="s1">_defaultExceptionDebugAction(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">exc):</span>
    <span class="s1">print(</span><span class="s2">&quot;Exception raised:&quot; </span><span class="s1">+ _ustr(exc))</span>

<span class="s3">def </span><span class="s1">nullDebugAction(*args):</span>
    <span class="s5">&quot;&quot;&quot;'Do-nothing' debug action, to suppress debugging output during parsing.&quot;&quot;&quot;</span>
    <span class="s3">pass</span>

<span class="s0"># Only works on Python 3.x - nonlocal is toxic to Python 2 installs</span>
<span class="s0">#~ 'decorator to trim function calls to match the arity of the target'</span>
<span class="s0">#~ def _trim_arity(func, maxargs=3):</span>
    <span class="s0">#~ if func in singleArgBuiltins:</span>
        <span class="s0">#~ return lambda s,l,t: func(t)</span>
    <span class="s0">#~ limit = 0</span>
    <span class="s0">#~ foundArity = False</span>
    <span class="s0">#~ def wrapper(*args):</span>
        <span class="s0">#~ nonlocal limit,foundArity</span>
        <span class="s0">#~ while 1:</span>
            <span class="s0">#~ try:</span>
                <span class="s0">#~ ret = func(*args[limit:])</span>
                <span class="s0">#~ foundArity = True</span>
                <span class="s0">#~ return ret</span>
            <span class="s0">#~ except TypeError:</span>
                <span class="s0">#~ if limit == maxargs or foundArity:</span>
                    <span class="s0">#~ raise</span>
                <span class="s0">#~ limit += 1</span>
                <span class="s0">#~ continue</span>
    <span class="s0">#~ return wrapper</span>

<span class="s0"># this version is Python 2.x-3.x cross-compatible</span>
<span class="s2">'decorator to trim function calls to match the arity of the target'</span>
<span class="s3">def </span><span class="s1">_trim_arity(func</span><span class="s3">, </span><span class="s1">maxargs=</span><span class="s4">2</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s1">func </span><span class="s3">in </span><span class="s1">singleArgBuiltins:</span>
        <span class="s3">return lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t: func(t)</span>
    <span class="s1">limit = [</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">foundArity = [</span><span class="s3">False</span><span class="s1">]</span>

    <span class="s0"># traceback return data structure changed in Py3.5 - normalize back to plain tuples</span>
    <span class="s3">if </span><span class="s1">system_version[:</span><span class="s4">2</span><span class="s1">] &gt;= (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">5</span><span class="s1">):</span>
        <span class="s3">def </span><span class="s1">extract_stack(limit=</span><span class="s4">0</span><span class="s1">):</span>
            <span class="s0"># special handling for Python 3.5.0 - extra deep call stack by 1</span>
            <span class="s1">offset = -</span><span class="s4">3 </span><span class="s3">if </span><span class="s1">system_version == (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">0</span><span class="s1">) </span><span class="s3">else </span><span class="s1">-</span><span class="s4">2</span>
            <span class="s1">frame_summary = traceback.extract_stack(limit=-offset + limit - </span><span class="s4">1</span><span class="s1">)[offset]</span>
            <span class="s3">return </span><span class="s1">[frame_summary[:</span><span class="s4">2</span><span class="s1">]]</span>
        <span class="s3">def </span><span class="s1">extract_tb(tb</span><span class="s3">, </span><span class="s1">limit=</span><span class="s4">0</span><span class="s1">):</span>
            <span class="s1">frames = traceback.extract_tb(tb</span><span class="s3">, </span><span class="s1">limit=limit)</span>
            <span class="s1">frame_summary = frames[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s3">return </span><span class="s1">[frame_summary[:</span><span class="s4">2</span><span class="s1">]]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">extract_stack = traceback.extract_stack</span>
        <span class="s1">extract_tb = traceback.extract_tb</span>

    <span class="s0"># synthesize what would be returned by traceback.extract_stack at the call to</span>
    <span class="s0"># user's parse action 'func', so that we don't incur call penalty at parse time</span>

    <span class="s1">LINE_DIFF = </span><span class="s4">6</span>
    <span class="s0"># IF ANY CODE CHANGES, EVEN JUST COMMENTS OR BLANK LINES, BETWEEN THE NEXT LINE AND</span>
    <span class="s0"># THE CALL TO FUNC INSIDE WRAPPER, LINE_DIFF MUST BE MODIFIED!!!!</span>
    <span class="s1">this_line = extract_stack(limit=</span><span class="s4">2</span><span class="s1">)[-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">pa_call_line_synth = (this_line[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">this_line[</span><span class="s4">1</span><span class="s1">] + LINE_DIFF)</span>

    <span class="s3">def </span><span class="s1">wrapper(*args):</span>
        <span class="s3">while </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">ret = func(*args[limit[</span><span class="s4">0</span><span class="s1">]:])</span>
                <span class="s1">foundArity[</span><span class="s4">0</span><span class="s1">] = </span><span class="s3">True</span>
                <span class="s3">return </span><span class="s1">ret</span>
            <span class="s3">except </span><span class="s1">TypeError:</span>
                <span class="s0"># re-raise TypeErrors if they did not come from our arity testing</span>
                <span class="s3">if </span><span class="s1">foundArity[</span><span class="s4">0</span><span class="s1">]:</span>
                    <span class="s3">raise</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">tb = sys.exc_info()[-</span><span class="s4">1</span><span class="s1">]</span>
                        <span class="s3">if not </span><span class="s1">extract_tb(tb</span><span class="s3">, </span><span class="s1">limit=</span><span class="s4">2</span><span class="s1">)[-</span><span class="s4">1</span><span class="s1">][:</span><span class="s4">2</span><span class="s1">] == pa_call_line_synth:</span>
                            <span class="s3">raise</span>
                    <span class="s3">finally</span><span class="s1">:</span>
                        <span class="s3">try</span><span class="s1">:</span>
                            <span class="s3">del </span><span class="s1">tb</span>
                        <span class="s3">except </span><span class="s1">NameError:</span>
                            <span class="s3">pass</span>

                <span class="s3">if </span><span class="s1">limit[</span><span class="s4">0</span><span class="s1">] &lt;= maxargs:</span>
                    <span class="s1">limit[</span><span class="s4">0</span><span class="s1">] += </span><span class="s4">1</span>
                    <span class="s3">continue</span>
                <span class="s3">raise</span>

    <span class="s0"># copy func name to wrapper for sensible debug output</span>
    <span class="s1">func_name = </span><span class="s2">&quot;&lt;parse action&gt;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">func_name = getattr(func</span><span class="s3">, </span><span class="s2">'__name__'</span><span class="s3">,</span>
                            <span class="s1">getattr(func</span><span class="s3">, </span><span class="s2">'__class__'</span><span class="s1">).__name__)</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s1">func_name = str(func)</span>
    <span class="s1">wrapper.__name__ = func_name</span>

    <span class="s3">return </span><span class="s1">wrapper</span>


<span class="s3">class </span><span class="s1">ParserElement(object):</span>
    <span class="s5">&quot;&quot;&quot;Abstract base level parser element class.&quot;&quot;&quot;</span>
    <span class="s1">DEFAULT_WHITE_CHARS = </span><span class="s2">&quot; </span><span class="s3">\n\t\r</span><span class="s2">&quot;</span>
    <span class="s1">verbose_stacktrace = </span><span class="s3">False</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">setDefaultWhitespaceChars(chars):</span>
        <span class="s5">r&quot;&quot;&quot; 
        Overrides the default whitespace chars 
 
        Example:: 
 
            # default whitespace chars are space, &lt;TAB&gt; and newline 
            OneOrMore(Word(alphas)).parseString(&quot;abc def\nghi jkl&quot;)  # -&gt; ['abc', 'def', 'ghi', 'jkl'] 
 
            # change to just treat newline as significant 
            ParserElement.setDefaultWhitespaceChars(&quot; \t&quot;) 
            OneOrMore(Word(alphas)).parseString(&quot;abc def\nghi jkl&quot;)  # -&gt; ['abc', 'def'] 
        &quot;&quot;&quot;</span>
        <span class="s1">ParserElement.DEFAULT_WHITE_CHARS = chars</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">inlineLiteralsUsing(cls):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set class to be used for inclusion of string literals into a parser. 
 
        Example:: 
 
            # default literal class used is Literal 
            integer = Word(nums) 
            date_str = integer(&quot;year&quot;) + '/' + integer(&quot;month&quot;) + '/' + integer(&quot;day&quot;) 
 
            date_str.parseString(&quot;1999/12/31&quot;)  # -&gt; ['1999', '/', '12', '/', '31'] 
 
 
            # change to Suppress 
            ParserElement.inlineLiteralsUsing(Suppress) 
            date_str = integer(&quot;year&quot;) + '/' + integer(&quot;month&quot;) + '/' + integer(&quot;day&quot;) 
 
            date_str.parseString(&quot;1999/12/31&quot;)  # -&gt; ['1999', '12', '31'] 
        &quot;&quot;&quot;</span>
        <span class="s1">ParserElement._literalStringClass = cls</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_trim_traceback(cls</span><span class="s3">, </span><span class="s1">tb):</span>
        <span class="s3">while </span><span class="s1">tb.tb_next:</span>
            <span class="s1">tb = tb.tb_next</span>
        <span class="s3">return </span><span class="s1">tb</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">savelist=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">self.parseAction = list()</span>
        <span class="s1">self.failAction = </span><span class="s3">None</span>
        <span class="s0"># ~ self.name = &quot;&lt;unknown&gt;&quot;  # don't define self.name, let subclasses try/except upcall</span>
        <span class="s1">self.strRepr = </span><span class="s3">None</span>
        <span class="s1">self.resultsName = </span><span class="s3">None</span>
        <span class="s1">self.saveAsList = savelist</span>
        <span class="s1">self.skipWhitespace = </span><span class="s3">True</span>
        <span class="s1">self.whiteChars = set(ParserElement.DEFAULT_WHITE_CHARS)</span>
        <span class="s1">self.copyDefaultWhiteChars = </span><span class="s3">True</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">False </span><span class="s0"># used when checking for left-recursion</span>
        <span class="s1">self.keepTabs = </span><span class="s3">False</span>
        <span class="s1">self.ignoreExprs = list()</span>
        <span class="s1">self.debug = </span><span class="s3">False</span>
        <span class="s1">self.streamlined = </span><span class="s3">False</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">True </span><span class="s0"># used to optimize exception handling for subclasses that don't advance parse index</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;&quot;</span>
        <span class="s1">self.modalResults = </span><span class="s3">True </span><span class="s0"># used to mark results names as modal (report only last) or cumulative (list all)</span>
        <span class="s1">self.debugActions = (</span><span class="s3">None, None, None</span><span class="s1">)  </span><span class="s0"># custom debug actions</span>
        <span class="s1">self.re = </span><span class="s3">None</span>
        <span class="s1">self.callPreparse = </span><span class="s3">True </span><span class="s0"># used to avoid redundant calls to preParse</span>
        <span class="s1">self.callDuringTry = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Make a copy of this :class:`ParserElement`.  Useful for defining 
        different parse actions for the same parsing pattern, using copies of 
        the original parse element. 
 
        Example:: 
 
            integer = Word(nums).setParseAction(lambda toks: int(toks[0])) 
            integerK = integer.copy().addParseAction(lambda toks: toks[0] * 1024) + Suppress(&quot;K&quot;) 
            integerM = integer.copy().addParseAction(lambda toks: toks[0] * 1024 * 1024) + Suppress(&quot;M&quot;) 
 
            print(OneOrMore(integerK | integerM | integer).parseString(&quot;5K 100 640K 256M&quot;)) 
 
        prints:: 
 
            [5120, 100, 655360, 268435456] 
 
        Equivalent form of ``expr.copy()`` is just ``expr()``:: 
 
            integerM = integer().addParseAction(lambda toks: toks[0] * 1024 * 1024) + Suppress(&quot;M&quot;) 
        &quot;&quot;&quot;</span>
        <span class="s1">cpy = copy.copy(self)</span>
        <span class="s1">cpy.parseAction = self.parseAction[:]</span>
        <span class="s1">cpy.ignoreExprs = self.ignoreExprs[:]</span>
        <span class="s3">if </span><span class="s1">self.copyDefaultWhiteChars:</span>
            <span class="s1">cpy.whiteChars = ParserElement.DEFAULT_WHITE_CHARS</span>
        <span class="s3">return </span><span class="s1">cpy</span>

    <span class="s3">def </span><span class="s1">setName(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s5">&quot;&quot;&quot; 
        Define name for this expression, makes debugging and exception messages clearer. 
 
        Example:: 
 
            Word(nums).parseString(&quot;ABC&quot;)  # -&gt; Exception: Expected W:(0123...) (at char 0), (line:1, col:1) 
            Word(nums).setName(&quot;integer&quot;).parseString(&quot;ABC&quot;)  # -&gt; Exception: Expected integer (at char 0), (line:1, col:1) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s3">if </span><span class="s1">__diag__.enable_debug_on_named_expressions:</span>
            <span class="s1">self.setDebug()</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">setResultsName(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">listAllMatches=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Define name for referencing matching tokens as a nested attribute 
        of the returned parse results. 
        NOTE: this returns a *copy* of the original :class:`ParserElement` object; 
        this is so that the client can define a basic element, such as an 
        integer, and reference it in multiple places with different names. 
 
        You can also set results names using the abbreviated syntax, 
        ``expr(&quot;name&quot;)`` in place of ``expr.setResultsName(&quot;name&quot;)`` 
        - see :class:`__call__`. 
 
        Example:: 
 
            date_str = (integer.setResultsName(&quot;year&quot;) + '/' 
                        + integer.setResultsName(&quot;month&quot;) + '/' 
                        + integer.setResultsName(&quot;day&quot;)) 
 
            # equivalent form: 
            date_str = integer(&quot;year&quot;) + '/' + integer(&quot;month&quot;) + '/' + integer(&quot;day&quot;) 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._setResultsName(name</span><span class="s3">, </span><span class="s1">listAllMatches)</span>

    <span class="s3">def </span><span class="s1">_setResultsName(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">listAllMatches=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">newself = self.copy()</span>
        <span class="s3">if </span><span class="s1">name.endswith(</span><span class="s2">&quot;*&quot;</span><span class="s1">):</span>
            <span class="s1">name = name[:-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">listAllMatches = </span><span class="s3">True</span>
        <span class="s1">newself.resultsName = name</span>
        <span class="s1">newself.modalResults = </span><span class="s3">not </span><span class="s1">listAllMatches</span>
        <span class="s3">return </span><span class="s1">newself</span>

    <span class="s3">def </span><span class="s1">setBreak(self</span><span class="s3">, </span><span class="s1">breakFlag=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Method to invoke the Python pdb debugger when this element is 
           about to be parsed. Set ``breakFlag`` to True to enable, False to 
           disable. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">breakFlag:</span>
            <span class="s1">_parseMethod = self._parse</span>
            <span class="s3">def </span><span class="s1">breaker(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True, </span><span class="s1">callPreParse=</span><span class="s3">True</span><span class="s1">):</span>
                <span class="s3">import </span><span class="s1">pdb</span>
                <span class="s0"># this call to pdb.set_trace() is intentional, not a checkin error</span>
                <span class="s1">pdb.set_trace()</span>
                <span class="s3">return </span><span class="s1">_parseMethod(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions</span><span class="s3">, </span><span class="s1">callPreParse)</span>
            <span class="s1">breaker._originalParseMethod = _parseMethod</span>
            <span class="s1">self._parse = breaker</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">hasattr(self._parse</span><span class="s3">, </span><span class="s2">&quot;_originalParseMethod&quot;</span><span class="s1">):</span>
                <span class="s1">self._parse = self._parse._originalParseMethod</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">setParseAction(self</span><span class="s3">, </span><span class="s1">*fns</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot; 
        Define one or more actions to perform when successfully matching parse element definition. 
        Parse action fn is a callable method with 0-3 arguments, called as ``fn(s, loc, toks)`` , 
        ``fn(loc, toks)`` , ``fn(toks)`` , or just ``fn()`` , where: 
 
        - s   = the original string being parsed (see note below) 
        - loc = the location of the matching substring 
        - toks = a list of the matched tokens, packaged as a :class:`ParseResults` object 
 
        If the functions in fns modify the tokens, they can return them as the return 
        value from fn, and the modified list of tokens will replace the original. 
        Otherwise, fn does not need to return any value. 
 
        If None is passed as the parse action, all previously added parse actions for this 
        expression are cleared. 
 
        Optional keyword arguments: 
        - callDuringTry = (default= ``False``) indicate if parse action should be run during lookaheads and alternate testing 
 
        Note: the default parsing behavior is to expand tabs in the input string 
        before starting the parsing process.  See :class:`parseString for more 
        information on parsing strings containing ``&lt;TAB&gt;`` s, and suggested 
        methods to maintain a consistent view of the parsed string, the parse 
        location, and line and column positions within the parsed string. 
 
        Example:: 
 
            integer = Word(nums) 
            date_str = integer + '/' + integer + '/' + integer 
 
            date_str.parseString(&quot;1999/12/31&quot;)  # -&gt; ['1999', '/', '12', '/', '31'] 
 
            # use parse action to convert to ints at parse time 
            integer = Word(nums).setParseAction(lambda toks: int(toks[0])) 
            date_str = integer + '/' + integer + '/' + integer 
 
            # note that integer fields are now ints, not strings 
            date_str.parseString(&quot;1999/12/31&quot;)  # -&gt; [1999, '/', 12, '/', 31] 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">list(fns) == [</span><span class="s3">None,</span><span class="s1">]:</span>
            <span class="s1">self.parseAction = []</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">all(callable(fn) </span><span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">fns):</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;parse actions must be callable&quot;</span><span class="s1">)</span>
            <span class="s1">self.parseAction = list(map(_trim_arity</span><span class="s3">, </span><span class="s1">list(fns)))</span>
            <span class="s1">self.callDuringTry = kwargs.get(</span><span class="s2">&quot;callDuringTry&quot;</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">addParseAction(self</span><span class="s3">, </span><span class="s1">*fns</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot; 
        Add one or more parse actions to expression's list of parse actions. See :class:`setParseAction`. 
 
        See examples in :class:`copy`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.parseAction += list(map(_trim_arity</span><span class="s3">, </span><span class="s1">list(fns)))</span>
        <span class="s1">self.callDuringTry = self.callDuringTry </span><span class="s3">or </span><span class="s1">kwargs.get(</span><span class="s2">&quot;callDuringTry&quot;</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">addCondition(self</span><span class="s3">, </span><span class="s1">*fns</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Add a boolean predicate function to expression's list of parse actions. See 
        :class:`setParseAction` for function call signatures. Unlike ``setParseAction``, 
        functions passed to ``addCondition`` need to return boolean success/fail of the condition. 
 
        Optional keyword arguments: 
        - message = define a custom message to be used in the raised exception 
        - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException 
 
        Example:: 
 
            integer = Word(nums).setParseAction(lambda toks: int(toks[0])) 
            year_int = integer.copy() 
            year_int.addCondition(lambda toks: toks[0] &gt;= 2000, message=&quot;Only support years 2000 and later&quot;) 
            date_str = year_int + '/' + integer + '/' + integer 
 
            result = date_str.parseString(&quot;1999/12/31&quot;)  # -&gt; Exception: Only support years 2000 and later (at char 0), (line:1, col:1) 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">fns:</span>
            <span class="s1">self.parseAction.append(conditionAsParseAction(fn</span><span class="s3">, </span><span class="s1">message=kwargs.get(</span><span class="s2">'message'</span><span class="s1">)</span><span class="s3">,</span>
                                                           <span class="s1">fatal=kwargs.get(</span><span class="s2">'fatal'</span><span class="s3">, False</span><span class="s1">)))</span>

        <span class="s1">self.callDuringTry = self.callDuringTry </span><span class="s3">or </span><span class="s1">kwargs.get(</span><span class="s2">&quot;callDuringTry&quot;</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">setFailAction(self</span><span class="s3">, </span><span class="s1">fn):</span>
        <span class="s5">&quot;&quot;&quot;Define action to perform if parsing fails at this expression. 
           Fail acton fn is a callable function that takes the arguments 
           ``fn(s, loc, expr, err)`` where: 
           - s = string being parsed 
           - loc = location where expression match was attempted and failed 
           - expr = the parse expression that failed 
           - err = the exception thrown 
           The function returns no value.  It may throw :class:`ParseFatalException` 
           if it is desired to stop parsing immediately.&quot;&quot;&quot;</span>
        <span class="s1">self.failAction = fn</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_skipIgnorables(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc):</span>
        <span class="s1">exprsFound = </span><span class="s3">True</span>
        <span class="s3">while </span><span class="s1">exprsFound:</span>
            <span class="s1">exprsFound = </span><span class="s3">False</span>
            <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.ignoreExprs:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s3">while </span><span class="s4">1</span><span class="s1">:</span>
                        <span class="s1">loc</span><span class="s3">, </span><span class="s1">dummy = e._parse(instring</span><span class="s3">, </span><span class="s1">loc)</span>
                        <span class="s1">exprsFound = </span><span class="s3">True</span>
                <span class="s3">except </span><span class="s1">ParseException:</span>
                    <span class="s3">pass</span>
        <span class="s3">return </span><span class="s1">loc</span>

    <span class="s3">def </span><span class="s1">preParse(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc):</span>
        <span class="s3">if </span><span class="s1">self.ignoreExprs:</span>
            <span class="s1">loc = self._skipIgnorables(instring</span><span class="s3">, </span><span class="s1">loc)</span>

        <span class="s3">if </span><span class="s1">self.skipWhitespace:</span>
            <span class="s1">wt = self.whiteChars</span>
            <span class="s1">instrlen = len(instring)</span>
            <span class="s3">while </span><span class="s1">loc &lt; instrlen </span><span class="s3">and </span><span class="s1">instring[loc] </span><span class="s3">in </span><span class="s1">wt:</span>
                <span class="s1">loc += </span><span class="s4">1</span>

        <span class="s3">return </span><span class="s1">loc</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">[]</span>

    <span class="s3">def </span><span class="s1">postParse(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">tokenlist):</span>
        <span class="s3">return </span><span class="s1">tokenlist</span>

    <span class="s0"># ~ @profile</span>
    <span class="s3">def </span><span class="s1">_parseNoCache(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True, </span><span class="s1">callPreParse=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">TRY</span><span class="s3">, </span><span class="s1">MATCH</span><span class="s3">, </span><span class="s1">FAIL = </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span>
        <span class="s1">debugging = (self.debug)  </span><span class="s0"># and doActions)</span>

        <span class="s3">if </span><span class="s1">debugging </span><span class="s3">or </span><span class="s1">self.failAction:</span>
            <span class="s0"># ~ print (&quot;Match&quot;, self, &quot;at loc&quot;, loc, &quot;(%d, %d)&quot; % (lineno(loc, instring), col(loc, instring)))</span>
            <span class="s3">if </span><span class="s1">self.debugActions[TRY]:</span>
                <span class="s1">self.debugActions[TRY](instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">callPreParse </span><span class="s3">and </span><span class="s1">self.callPreparse:</span>
                    <span class="s1">preloc = self.preParse(instring</span><span class="s3">, </span><span class="s1">loc)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">preloc = loc</span>
                <span class="s1">tokensStart = preloc</span>
                <span class="s3">if </span><span class="s1">self.mayIndexError </span><span class="s3">or </span><span class="s1">preloc &gt;= len(instring):</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">loc</span><span class="s3">, </span><span class="s1">tokens = self.parseImpl(instring</span><span class="s3">, </span><span class="s1">preloc</span><span class="s3">, </span><span class="s1">doActions)</span>
                    <span class="s3">except </span><span class="s1">IndexError:</span>
                        <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">len(instring)</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">loc</span><span class="s3">, </span><span class="s1">tokens = self.parseImpl(instring</span><span class="s3">, </span><span class="s1">preloc</span><span class="s3">, </span><span class="s1">doActions)</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s0"># ~ print (&quot;Exception raised:&quot;, err)</span>
                <span class="s3">if </span><span class="s1">self.debugActions[FAIL]:</span>
                    <span class="s1">self.debugActions[FAIL](instring</span><span class="s3">, </span><span class="s1">tokensStart</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">err)</span>
                <span class="s3">if </span><span class="s1">self.failAction:</span>
                    <span class="s1">self.failAction(instring</span><span class="s3">, </span><span class="s1">tokensStart</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">err)</span>
                <span class="s3">raise</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">callPreParse </span><span class="s3">and </span><span class="s1">self.callPreparse:</span>
                <span class="s1">preloc = self.preParse(instring</span><span class="s3">, </span><span class="s1">loc)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">preloc = loc</span>
            <span class="s1">tokensStart = preloc</span>
            <span class="s3">if </span><span class="s1">self.mayIndexError </span><span class="s3">or </span><span class="s1">preloc &gt;= len(instring):</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">loc</span><span class="s3">, </span><span class="s1">tokens = self.parseImpl(instring</span><span class="s3">, </span><span class="s1">preloc</span><span class="s3">, </span><span class="s1">doActions)</span>
                <span class="s3">except </span><span class="s1">IndexError:</span>
                    <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">len(instring)</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">loc</span><span class="s3">, </span><span class="s1">tokens = self.parseImpl(instring</span><span class="s3">, </span><span class="s1">preloc</span><span class="s3">, </span><span class="s1">doActions)</span>

        <span class="s1">tokens = self.postParse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">tokens)</span>

        <span class="s1">retTokens = ParseResults(tokens</span><span class="s3">, </span><span class="s1">self.resultsName</span><span class="s3">, </span><span class="s1">asList=self.saveAsList</span><span class="s3">, </span><span class="s1">modal=self.modalResults)</span>
        <span class="s3">if </span><span class="s1">self.parseAction </span><span class="s3">and </span><span class="s1">(doActions </span><span class="s3">or </span><span class="s1">self.callDuringTry):</span>
            <span class="s3">if </span><span class="s1">debugging:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self.parseAction:</span>
                        <span class="s3">try</span><span class="s1">:</span>
                            <span class="s1">tokens = fn(instring</span><span class="s3">, </span><span class="s1">tokensStart</span><span class="s3">, </span><span class="s1">retTokens)</span>
                        <span class="s3">except </span><span class="s1">IndexError </span><span class="s3">as </span><span class="s1">parse_action_exc:</span>
                            <span class="s1">exc = ParseException(</span><span class="s2">&quot;exception raised in parse action&quot;</span><span class="s1">)</span>
                            <span class="s1">exc.__cause__ = parse_action_exc</span>
                            <span class="s3">raise </span><span class="s1">exc</span>

                        <span class="s3">if </span><span class="s1">tokens </span><span class="s3">is not None and </span><span class="s1">tokens </span><span class="s3">is not </span><span class="s1">retTokens:</span>
                            <span class="s1">retTokens = ParseResults(tokens</span><span class="s3">,</span>
                                                      <span class="s1">self.resultsName</span><span class="s3">,</span>
                                                      <span class="s1">asList=self.saveAsList </span><span class="s3">and </span><span class="s1">isinstance(tokens</span><span class="s3">, </span><span class="s1">(ParseResults</span><span class="s3">, </span><span class="s1">list))</span><span class="s3">,</span>
                                                      <span class="s1">modal=self.modalResults)</span>
                <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">err:</span>
                    <span class="s0"># ~ print &quot;Exception raised in user parse action:&quot;, err</span>
                    <span class="s3">if </span><span class="s1">self.debugActions[FAIL]:</span>
                        <span class="s1">self.debugActions[FAIL](instring</span><span class="s3">, </span><span class="s1">tokensStart</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">err)</span>
                    <span class="s3">raise</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self.parseAction:</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">tokens = fn(instring</span><span class="s3">, </span><span class="s1">tokensStart</span><span class="s3">, </span><span class="s1">retTokens)</span>
                    <span class="s3">except </span><span class="s1">IndexError </span><span class="s3">as </span><span class="s1">parse_action_exc:</span>
                        <span class="s1">exc = ParseException(</span><span class="s2">&quot;exception raised in parse action&quot;</span><span class="s1">)</span>
                        <span class="s1">exc.__cause__ = parse_action_exc</span>
                        <span class="s3">raise </span><span class="s1">exc</span>

                    <span class="s3">if </span><span class="s1">tokens </span><span class="s3">is not None and </span><span class="s1">tokens </span><span class="s3">is not </span><span class="s1">retTokens:</span>
                        <span class="s1">retTokens = ParseResults(tokens</span><span class="s3">,</span>
                                                  <span class="s1">self.resultsName</span><span class="s3">,</span>
                                                  <span class="s1">asList=self.saveAsList </span><span class="s3">and </span><span class="s1">isinstance(tokens</span><span class="s3">, </span><span class="s1">(ParseResults</span><span class="s3">, </span><span class="s1">list))</span><span class="s3">,</span>
                                                  <span class="s1">modal=self.modalResults)</span>
        <span class="s3">if </span><span class="s1">debugging:</span>
            <span class="s0"># ~ print (&quot;Matched&quot;, self, &quot;-&gt;&quot;, retTokens.asList())</span>
            <span class="s3">if </span><span class="s1">self.debugActions[MATCH]:</span>
                <span class="s1">self.debugActions[MATCH](instring</span><span class="s3">, </span><span class="s1">tokensStart</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">retTokens)</span>

        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">retTokens</span>

    <span class="s3">def </span><span class="s1">tryParse(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">False</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">except </span><span class="s1">ParseFatalException:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

    <span class="s3">def </span><span class="s1">canParseNext(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.tryParse(instring</span><span class="s3">, </span><span class="s1">loc)</span>
        <span class="s3">except </span><span class="s1">(ParseException</span><span class="s3">, </span><span class="s1">IndexError):</span>
            <span class="s3">return False</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return True</span>

    <span class="s3">class </span><span class="s1">_UnboundedCache(object):</span>
        <span class="s3">def </span><span class="s1">__init__(self):</span>
            <span class="s1">cache = {}</span>
            <span class="s1">self.not_in_cache = not_in_cache = object()</span>

            <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key):</span>
                <span class="s3">return </span><span class="s1">cache.get(key</span><span class="s3">, </span><span class="s1">not_in_cache)</span>

            <span class="s3">def </span><span class="s1">set(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
                <span class="s1">cache[key] = value</span>

            <span class="s3">def </span><span class="s1">clear(self):</span>
                <span class="s1">cache.clear()</span>

            <span class="s3">def </span><span class="s1">cache_len(self):</span>
                <span class="s3">return </span><span class="s1">len(cache)</span>

            <span class="s1">self.get = types.MethodType(get</span><span class="s3">, </span><span class="s1">self)</span>
            <span class="s1">self.set = types.MethodType(set</span><span class="s3">, </span><span class="s1">self)</span>
            <span class="s1">self.clear = types.MethodType(clear</span><span class="s3">, </span><span class="s1">self)</span>
            <span class="s1">self.__len__ = types.MethodType(cache_len</span><span class="s3">, </span><span class="s1">self)</span>

    <span class="s3">if </span><span class="s1">_OrderedDict </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">class </span><span class="s1">_FifoCache(object):</span>
            <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">size):</span>
                <span class="s1">self.not_in_cache = not_in_cache = object()</span>

                <span class="s1">cache = _OrderedDict()</span>

                <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key):</span>
                    <span class="s3">return </span><span class="s1">cache.get(key</span><span class="s3">, </span><span class="s1">not_in_cache)</span>

                <span class="s3">def </span><span class="s1">set(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
                    <span class="s1">cache[key] = value</span>
                    <span class="s3">while </span><span class="s1">len(cache) &gt; size:</span>
                        <span class="s3">try</span><span class="s1">:</span>
                            <span class="s1">cache.popitem(</span><span class="s3">False</span><span class="s1">)</span>
                        <span class="s3">except </span><span class="s1">KeyError:</span>
                            <span class="s3">pass</span>

                <span class="s3">def </span><span class="s1">clear(self):</span>
                    <span class="s1">cache.clear()</span>

                <span class="s3">def </span><span class="s1">cache_len(self):</span>
                    <span class="s3">return </span><span class="s1">len(cache)</span>

                <span class="s1">self.get = types.MethodType(get</span><span class="s3">, </span><span class="s1">self)</span>
                <span class="s1">self.set = types.MethodType(set</span><span class="s3">, </span><span class="s1">self)</span>
                <span class="s1">self.clear = types.MethodType(clear</span><span class="s3">, </span><span class="s1">self)</span>
                <span class="s1">self.__len__ = types.MethodType(cache_len</span><span class="s3">, </span><span class="s1">self)</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">class </span><span class="s1">_FifoCache(object):</span>
            <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">size):</span>
                <span class="s1">self.not_in_cache = not_in_cache = object()</span>

                <span class="s1">cache = {}</span>
                <span class="s1">key_fifo = collections.deque([]</span><span class="s3">, </span><span class="s1">size)</span>

                <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key):</span>
                    <span class="s3">return </span><span class="s1">cache.get(key</span><span class="s3">, </span><span class="s1">not_in_cache)</span>

                <span class="s3">def </span><span class="s1">set(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
                    <span class="s1">cache[key] = value</span>
                    <span class="s3">while </span><span class="s1">len(key_fifo) &gt; size:</span>
                        <span class="s1">cache.pop(key_fifo.popleft()</span><span class="s3">, None</span><span class="s1">)</span>
                    <span class="s1">key_fifo.append(key)</span>

                <span class="s3">def </span><span class="s1">clear(self):</span>
                    <span class="s1">cache.clear()</span>
                    <span class="s1">key_fifo.clear()</span>

                <span class="s3">def </span><span class="s1">cache_len(self):</span>
                    <span class="s3">return </span><span class="s1">len(cache)</span>

                <span class="s1">self.get = types.MethodType(get</span><span class="s3">, </span><span class="s1">self)</span>
                <span class="s1">self.set = types.MethodType(set</span><span class="s3">, </span><span class="s1">self)</span>
                <span class="s1">self.clear = types.MethodType(clear</span><span class="s3">, </span><span class="s1">self)</span>
                <span class="s1">self.__len__ = types.MethodType(cache_len</span><span class="s3">, </span><span class="s1">self)</span>

    <span class="s0"># argument cache for optimizing repeated calls when backtracking through recursive expressions</span>
    <span class="s1">packrat_cache = {} </span><span class="s0"># this is set later by enabledPackrat(); this is here so that resetCache() doesn't fail</span>
    <span class="s1">packrat_cache_lock = RLock()</span>
    <span class="s1">packrat_cache_stats = [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span>

    <span class="s0"># this method gets repeatedly called during backtracking with the same arguments -</span>
    <span class="s0"># we can cache these arguments and save ourselves the trouble of re-parsing the contained expression</span>
    <span class="s3">def </span><span class="s1">_parseCache(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True, </span><span class="s1">callPreParse=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">HIT</span><span class="s3">, </span><span class="s1">MISS = </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span>
        <span class="s1">lookup = (self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">callPreParse</span><span class="s3">, </span><span class="s1">doActions)</span>
        <span class="s3">with </span><span class="s1">ParserElement.packrat_cache_lock:</span>
            <span class="s1">cache = ParserElement.packrat_cache</span>
            <span class="s1">value = cache.get(lookup)</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">is </span><span class="s1">cache.not_in_cache:</span>
                <span class="s1">ParserElement.packrat_cache_stats[MISS] += </span><span class="s4">1</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">value = self._parseNoCache(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions</span><span class="s3">, </span><span class="s1">callPreParse)</span>
                <span class="s3">except </span><span class="s1">ParseBaseException </span><span class="s3">as </span><span class="s1">pe:</span>
                    <span class="s0"># cache a copy of the exception, without the traceback</span>
                    <span class="s1">cache.set(lookup</span><span class="s3">, </span><span class="s1">pe.__class__(*pe.args))</span>
                    <span class="s3">raise</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">cache.set(lookup</span><span class="s3">, </span><span class="s1">(value[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">value[</span><span class="s4">1</span><span class="s1">].copy()))</span>
                    <span class="s3">return </span><span class="s1">value</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ParserElement.packrat_cache_stats[HIT] += </span><span class="s4">1</span>
                <span class="s3">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">Exception):</span>
                    <span class="s3">raise </span><span class="s1">value</span>
                <span class="s3">return </span><span class="s1">value[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">value[</span><span class="s4">1</span><span class="s1">].copy()</span>

    <span class="s1">_parse = _parseNoCache</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">resetCache():</span>
        <span class="s1">ParserElement.packrat_cache.clear()</span>
        <span class="s1">ParserElement.packrat_cache_stats[:] = [</span><span class="s4">0</span><span class="s1">] * len(ParserElement.packrat_cache_stats)</span>

    <span class="s1">_packratEnabled = </span><span class="s3">False</span>
    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">enablePackrat(cache_size_limit=</span><span class="s4">128</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Enables &quot;packrat&quot; parsing, which adds memoizing to the parsing logic. 
           Repeated parse attempts at the same string location (which happens 
           often in many complex grammars) can immediately return a cached value, 
           instead of re-executing parsing/validating code.  Memoizing is done of 
           both valid results and parsing exceptions. 
 
           Parameters: 
 
           - cache_size_limit - (default= ``128``) - if an integer value is provided 
             will limit the size of the packrat cache; if None is passed, then 
             the cache size will be unbounded; if 0 is passed, the cache will 
             be effectively disabled. 
 
           This speedup may break existing programs that use parse actions that 
           have side-effects.  For this reason, packrat parsing is disabled when 
           you first import pyparsing.  To activate the packrat feature, your 
           program must call the class method :class:`ParserElement.enablePackrat`. 
           For best results, call ``enablePackrat()`` immediately after 
           importing pyparsing. 
 
           Example:: 
 
               from pip._vendor import pyparsing 
               pyparsing.ParserElement.enablePackrat() 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">ParserElement._packratEnabled:</span>
            <span class="s1">ParserElement._packratEnabled = </span><span class="s3">True</span>
            <span class="s3">if </span><span class="s1">cache_size_limit </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">ParserElement.packrat_cache = ParserElement._UnboundedCache()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ParserElement.packrat_cache = ParserElement._FifoCache(cache_size_limit)</span>
            <span class="s1">ParserElement._parse = ParserElement._parseCache</span>

    <span class="s3">def </span><span class="s1">parseString(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">parseAll=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Execute the parse expression with the given string. 
        This is the main interface to the client code, once the complete 
        expression has been built. 
 
        Returns the parsed data as a :class:`ParseResults` object, which may be 
        accessed as a list, or as a dict or object with attributes if the given parser 
        includes results names. 
 
        If you want the grammar to require that the entire input string be 
        successfully parsed, then set ``parseAll`` to True (equivalent to ending 
        the grammar with ``StringEnd()``). 
 
        Note: ``parseString`` implicitly calls ``expandtabs()`` on the input string, 
        in order to report proper column numbers in parse actions. 
        If the input string contains tabs and 
        the grammar uses parse actions that use the ``loc`` argument to index into the 
        string being parsed, you can ensure you have a consistent view of the input 
        string by: 
 
        - calling ``parseWithTabs`` on your grammar before calling ``parseString`` 
          (see :class:`parseWithTabs`) 
        - define your parse action using the full ``(s, loc, toks)`` signature, and 
          reference the input string using the parse action's ``s`` argument 
        - explictly expand the tabs in your input string before calling 
          ``parseString`` 
 
        Example:: 
 
            Word('a').parseString('aaaaabaaa')  # -&gt; ['aaaaa'] 
            Word('a').parseString('aaaaabaaa', parseAll=True)  # -&gt; Exception: Expected end of text 
        &quot;&quot;&quot;</span>
        <span class="s1">ParserElement.resetCache()</span>
        <span class="s3">if not </span><span class="s1">self.streamlined:</span>
            <span class="s1">self.streamline()</span>
            <span class="s0"># ~ self.saveAsList = True</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.ignoreExprs:</span>
            <span class="s1">e.streamline()</span>
        <span class="s3">if not </span><span class="s1">self.keepTabs:</span>
            <span class="s1">instring = instring.expandtabs()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">loc</span><span class="s3">, </span><span class="s1">tokens = self._parse(instring</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">parseAll:</span>
                <span class="s1">loc = self.preParse(instring</span><span class="s3">, </span><span class="s1">loc)</span>
                <span class="s1">se = Empty() + StringEnd()</span>
                <span class="s1">se._parse(instring</span><span class="s3">, </span><span class="s1">loc)</span>
        <span class="s3">except </span><span class="s1">ParseBaseException </span><span class="s3">as </span><span class="s1">exc:</span>
            <span class="s3">if </span><span class="s1">ParserElement.verbose_stacktrace:</span>
                <span class="s3">raise</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># catch and re-raise exception from here, clearing out pyparsing internal stack trace</span>
                <span class="s3">if </span><span class="s1">getattr(exc</span><span class="s3">, </span><span class="s2">'__traceback__'</span><span class="s3">, None</span><span class="s1">) </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">exc.__traceback__ = self._trim_traceback(exc.__traceback__)</span>
                <span class="s3">raise </span><span class="s1">exc</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">tokens</span>

    <span class="s3">def </span><span class="s1">scanString(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">maxMatches=_MAX_INT</span><span class="s3">, </span><span class="s1">overlap=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Scan the input string for expression matches.  Each match will return the 
        matching tokens, start location, and end location.  May be called with optional 
        ``maxMatches`` argument, to clip scanning after 'n' matches are found.  If 
        ``overlap`` is specified, then overlapping matches will be reported. 
 
        Note that the start and end locations are reported relative to the string 
        being parsed.  See :class:`parseString` for more information on parsing 
        strings with embedded tabs. 
 
        Example:: 
 
            source = &quot;sldjf123lsdjjkf345sldkjf879lkjsfd987&quot; 
            print(source) 
            for tokens, start, end in Word(alphas).scanString(source): 
                print(' '*start + '^'*(end-start)) 
                print(' '*start + tokens[0]) 
 
        prints:: 
 
            sldjf123lsdjjkf345sldkjf879lkjsfd987 
            ^^^^^ 
            sldjf 
                    ^^^^^^^ 
                    lsdjjkf 
                              ^^^^^^ 
                              sldkjf 
                                       ^^^^^^ 
                                       lkjsfd 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self.streamlined:</span>
            <span class="s1">self.streamline()</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.ignoreExprs:</span>
            <span class="s1">e.streamline()</span>

        <span class="s3">if not </span><span class="s1">self.keepTabs:</span>
            <span class="s1">instring = _ustr(instring).expandtabs()</span>
        <span class="s1">instrlen = len(instring)</span>
        <span class="s1">loc = </span><span class="s4">0</span>
        <span class="s1">preparseFn = self.preParse</span>
        <span class="s1">parseFn = self._parse</span>
        <span class="s1">ParserElement.resetCache()</span>
        <span class="s1">matches = </span><span class="s4">0</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">while </span><span class="s1">loc &lt;= instrlen </span><span class="s3">and </span><span class="s1">matches &lt; maxMatches:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">preloc = preparseFn(instring</span><span class="s3">, </span><span class="s1">loc)</span>
                    <span class="s1">nextLoc</span><span class="s3">, </span><span class="s1">tokens = parseFn(instring</span><span class="s3">, </span><span class="s1">preloc</span><span class="s3">, </span><span class="s1">callPreParse=</span><span class="s3">False</span><span class="s1">)</span>
                <span class="s3">except </span><span class="s1">ParseException:</span>
                    <span class="s1">loc = preloc + </span><span class="s4">1</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">nextLoc &gt; loc:</span>
                        <span class="s1">matches += </span><span class="s4">1</span>
                        <span class="s3">yield </span><span class="s1">tokens</span><span class="s3">, </span><span class="s1">preloc</span><span class="s3">, </span><span class="s1">nextLoc</span>
                        <span class="s3">if </span><span class="s1">overlap:</span>
                            <span class="s1">nextloc = preparseFn(instring</span><span class="s3">, </span><span class="s1">loc)</span>
                            <span class="s3">if </span><span class="s1">nextloc &gt; loc:</span>
                                <span class="s1">loc = nextLoc</span>
                            <span class="s3">else</span><span class="s1">:</span>
                                <span class="s1">loc += </span><span class="s4">1</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s1">loc = nextLoc</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">loc = preloc + </span><span class="s4">1</span>
        <span class="s3">except </span><span class="s1">ParseBaseException </span><span class="s3">as </span><span class="s1">exc:</span>
            <span class="s3">if </span><span class="s1">ParserElement.verbose_stacktrace:</span>
                <span class="s3">raise</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># catch and re-raise exception from here, clearing out pyparsing internal stack trace</span>
                <span class="s3">if </span><span class="s1">getattr(exc</span><span class="s3">, </span><span class="s2">'__traceback__'</span><span class="s3">, None</span><span class="s1">) </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">exc.__traceback__ = self._trim_traceback(exc.__traceback__)</span>
                <span class="s3">raise </span><span class="s1">exc</span>

    <span class="s3">def </span><span class="s1">transformString(self</span><span class="s3">, </span><span class="s1">instring):</span>
        <span class="s5">&quot;&quot;&quot; 
        Extension to :class:`scanString`, to modify matching text with modified tokens that may 
        be returned from a parse action.  To use ``transformString``, define a grammar and 
        attach a parse action to it that modifies the returned token list. 
        Invoking ``transformString()`` on a target string will then scan for matches, 
        and replace the matched text patterns according to the logic in the parse 
        action.  ``transformString()`` returns the resulting transformed string. 
 
        Example:: 
 
            wd = Word(alphas) 
            wd.setParseAction(lambda toks: toks[0].title()) 
 
            print(wd.transformString(&quot;now is the winter of our discontent made glorious summer by this sun of york.&quot;)) 
 
        prints:: 
 
            Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York. 
        &quot;&quot;&quot;</span>
        <span class="s1">out = []</span>
        <span class="s1">lastE = </span><span class="s4">0</span>
        <span class="s0"># force preservation of &lt;TAB&gt;s, to minimize unwanted transformation of string, and to</span>
        <span class="s0"># keep string locs straight between transformString and scanString</span>
        <span class="s1">self.keepTabs = </span><span class="s3">True</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">t</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.scanString(instring):</span>
                <span class="s1">out.append(instring[lastE:s])</span>
                <span class="s3">if </span><span class="s1">t:</span>
                    <span class="s3">if </span><span class="s1">isinstance(t</span><span class="s3">, </span><span class="s1">ParseResults):</span>
                        <span class="s1">out += t.asList()</span>
                    <span class="s3">elif </span><span class="s1">isinstance(t</span><span class="s3">, </span><span class="s1">list):</span>
                        <span class="s1">out += t</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">out.append(t)</span>
                <span class="s1">lastE = e</span>
            <span class="s1">out.append(instring[lastE:])</span>
            <span class="s1">out = [o </span><span class="s3">for </span><span class="s1">o </span><span class="s3">in </span><span class="s1">out </span><span class="s3">if </span><span class="s1">o]</span>
            <span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">.join(map(_ustr</span><span class="s3">, </span><span class="s1">_flatten(out)))</span>
        <span class="s3">except </span><span class="s1">ParseBaseException </span><span class="s3">as </span><span class="s1">exc:</span>
            <span class="s3">if </span><span class="s1">ParserElement.verbose_stacktrace:</span>
                <span class="s3">raise</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># catch and re-raise exception from here, clearing out pyparsing internal stack trace</span>
                <span class="s3">if </span><span class="s1">getattr(exc</span><span class="s3">, </span><span class="s2">'__traceback__'</span><span class="s3">, None</span><span class="s1">) </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">exc.__traceback__ = self._trim_traceback(exc.__traceback__)</span>
                <span class="s3">raise </span><span class="s1">exc</span>

    <span class="s3">def </span><span class="s1">searchString(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">maxMatches=_MAX_INT):</span>
        <span class="s5">&quot;&quot;&quot; 
        Another extension to :class:`scanString`, simplifying the access to the tokens found 
        to match the given parse expression.  May be called with optional 
        ``maxMatches`` argument, to clip searching after 'n' matches are found. 
 
        Example:: 
 
            # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters 
            cap_word = Word(alphas.upper(), alphas.lower()) 
 
            print(cap_word.searchString(&quot;More than Iron, more than Lead, more than Gold I need Electricity&quot;)) 
 
            # the sum() builtin can be used to merge results into a single ParseResults object 
            print(sum(cap_word.searchString(&quot;More than Iron, more than Lead, more than Gold I need Electricity&quot;))) 
 
        prints:: 
 
            [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']] 
            ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity'] 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">ParseResults([t </span><span class="s3">for </span><span class="s1">t</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.scanString(instring</span><span class="s3">, </span><span class="s1">maxMatches)])</span>
        <span class="s3">except </span><span class="s1">ParseBaseException </span><span class="s3">as </span><span class="s1">exc:</span>
            <span class="s3">if </span><span class="s1">ParserElement.verbose_stacktrace:</span>
                <span class="s3">raise</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># catch and re-raise exception from here, clearing out pyparsing internal stack trace</span>
                <span class="s3">if </span><span class="s1">getattr(exc</span><span class="s3">, </span><span class="s2">'__traceback__'</span><span class="s3">, None</span><span class="s1">) </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">exc.__traceback__ = self._trim_traceback(exc.__traceback__)</span>
                <span class="s3">raise </span><span class="s1">exc</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">maxsplit=_MAX_INT</span><span class="s3">, </span><span class="s1">includeSeparators=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Generator method to split a string using the given expression as a separator. 
        May be called with optional ``maxsplit`` argument, to limit the number of splits; 
        and the optional ``includeSeparators`` argument (default= ``False``), if the separating 
        matching text should be included in the split results. 
 
        Example:: 
 
            punc = oneOf(list(&quot;.,;:/-!?&quot;)) 
            print(list(punc.split(&quot;This, this?, this sentence, is badly punctuated!&quot;))) 
 
        prints:: 
 
            ['This', ' this', '', ' this sentence', ' is badly punctuated', ''] 
        &quot;&quot;&quot;</span>
        <span class="s1">splits = </span><span class="s4">0</span>
        <span class="s1">last = </span><span class="s4">0</span>
        <span class="s3">for </span><span class="s1">t</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.scanString(instring</span><span class="s3">, </span><span class="s1">maxMatches=maxsplit):</span>
            <span class="s3">yield </span><span class="s1">instring[last:s]</span>
            <span class="s3">if </span><span class="s1">includeSeparators:</span>
                <span class="s3">yield </span><span class="s1">t[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">last = e</span>
        <span class="s3">yield </span><span class="s1">instring[last:]</span>

    <span class="s3">def </span><span class="s1">__add__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implementation of + operator - returns :class:`And`. Adding strings to a ParserElement 
        converts them to :class:`Literal`s by default. 
 
        Example:: 
 
            greet = Word(alphas) + &quot;,&quot; + Word(alphas) + &quot;!&quot; 
            hello = &quot;Hello, World!&quot; 
            print (hello, &quot;-&gt;&quot;, greet.parseString(hello)) 
 
        prints:: 
 
            Hello, World! -&gt; ['Hello', ',', 'World', '!'] 
 
        ``...`` may be used as a parse expression as a short form of :class:`SkipTo`. 
 
            Literal('start') + ... + Literal('end') 
 
        is equivalent to: 
 
            Literal('start') + SkipTo('end')(&quot;_skipped*&quot;) + Literal('end') 
 
        Note that the skipped text is returned with '_skipped' as a results name, 
        and to support having multiple skips in the same parser, the value returned is 
        a list of all skipped text. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">other </span><span class="s3">is </span><span class="s1">Ellipsis:</span>
            <span class="s3">return </span><span class="s1">_PendingSkip(self)</span>

        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">ParserElement):</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Cannot combine element of type %s with ParserElement&quot; </span><span class="s1">% type(other)</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">And([self</span><span class="s3">, </span><span class="s1">other])</span>

    <span class="s3">def </span><span class="s1">__radd__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implementation of + operator when left operand is not a :class:`ParserElement` 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">other </span><span class="s3">is </span><span class="s1">Ellipsis:</span>
            <span class="s3">return </span><span class="s1">SkipTo(self)(</span><span class="s2">&quot;_skipped*&quot;</span><span class="s1">) + self</span>

        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">ParserElement):</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Cannot combine element of type %s with ParserElement&quot; </span><span class="s1">% type(other)</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">other + self</span>

    <span class="s3">def </span><span class="s1">__sub__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implementation of - operator, returns :class:`And` with error stop 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">ParserElement):</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Cannot combine element of type %s with ParserElement&quot; </span><span class="s1">% type(other)</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">self + And._ErrorStop() + other</span>

    <span class="s3">def </span><span class="s1">__rsub__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implementation of - operator when left operand is not a :class:`ParserElement` 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">ParserElement):</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Cannot combine element of type %s with ParserElement&quot; </span><span class="s1">% type(other)</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">other - self</span>

    <span class="s3">def </span><span class="s1">__mul__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implementation of * operator, allows use of ``expr * 3`` in place of 
        ``expr + expr + expr``.  Expressions may also me multiplied by a 2-integer 
        tuple, similar to ``{min, max}`` multipliers in regular expressions.  Tuples 
        may also include ``None`` as in: 
         - ``expr*(n, None)`` or ``expr*(n, )`` is equivalent 
              to ``expr*n + ZeroOrMore(expr)`` 
              (read as &quot;at least n instances of ``expr``&quot;) 
         - ``expr*(None, n)`` is equivalent to ``expr*(0, n)`` 
              (read as &quot;0 to n instances of ``expr``&quot;) 
         - ``expr*(None, None)`` is equivalent to ``ZeroOrMore(expr)`` 
         - ``expr*(1, None)`` is equivalent to ``OneOrMore(expr)`` 
 
        Note that ``expr*(None, n)`` does not raise an exception if 
        more than n exprs exist in the input stream; that is, 
        ``expr*(None, n)`` does not enforce a maximum number of expr 
        occurrences.  If this behavior is desired, then write 
        ``expr*(None, n) + ~expr`` 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">other </span><span class="s3">is </span><span class="s1">Ellipsis:</span>
            <span class="s1">other = (</span><span class="s4">0</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">tuple) </span><span class="s3">and </span><span class="s1">other[:</span><span class="s4">1</span><span class="s1">] == (Ellipsis</span><span class="s3">,</span><span class="s1">):</span>
            <span class="s1">other = ((</span><span class="s4">0</span><span class="s3">, </span><span class="s1">) + other[</span><span class="s4">1</span><span class="s1">:] + (</span><span class="s3">None,</span><span class="s1">))[:</span><span class="s4">2</span><span class="s1">]</span>

        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">int):</span>
            <span class="s1">minElements</span><span class="s3">, </span><span class="s1">optElements = other</span><span class="s3">, </span><span class="s4">0</span>
        <span class="s3">elif </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s1">other = tuple(o </span><span class="s3">if </span><span class="s1">o </span><span class="s3">is not </span><span class="s1">Ellipsis </span><span class="s3">else None for </span><span class="s1">o </span><span class="s3">in </span><span class="s1">other)</span>
            <span class="s1">other = (other + (</span><span class="s3">None, None</span><span class="s1">))[:</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">other[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">other = (</span><span class="s4">0</span><span class="s3">, </span><span class="s1">other[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s3">if </span><span class="s1">isinstance(other[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">int) </span><span class="s3">and </span><span class="s1">other[</span><span class="s4">1</span><span class="s1">] </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">other[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">ZeroOrMore(self)</span>
                <span class="s3">if </span><span class="s1">other[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">OneOrMore(self)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">self * other[</span><span class="s4">0</span><span class="s1">] + ZeroOrMore(self)</span>
            <span class="s3">elif </span><span class="s1">isinstance(other[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">int) </span><span class="s3">and </span><span class="s1">isinstance(other[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">int):</span>
                <span class="s1">minElements</span><span class="s3">, </span><span class="s1">optElements = other</span>
                <span class="s1">optElements -= minElements</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;cannot multiply 'ParserElement' and ('%s', '%s') objects&quot;</span><span class="s3">, </span><span class="s1">type(other[</span><span class="s4">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">type(other[</span><span class="s4">1</span><span class="s1">]))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;cannot multiply 'ParserElement' and '%s' objects&quot;</span><span class="s3">, </span><span class="s1">type(other))</span>

        <span class="s3">if </span><span class="s1">minElements &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;cannot multiply ParserElement by negative value&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">optElements &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;second tuple value must be greater or equal to first tuple value&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">minElements == optElements == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;cannot multiply ParserElement by 0 or (0, 0)&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">optElements:</span>
            <span class="s3">def </span><span class="s1">makeOptionalList(n):</span>
                <span class="s3">if </span><span class="s1">n &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">Optional(self + makeOptionalList(n - </span><span class="s4">1</span><span class="s1">))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">Optional(self)</span>
            <span class="s3">if </span><span class="s1">minElements:</span>
                <span class="s3">if </span><span class="s1">minElements == </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">ret = self + makeOptionalList(optElements)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">ret = And([self] * minElements) + makeOptionalList(optElements)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ret = makeOptionalList(optElements)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">minElements == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">ret = self</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ret = And([self] * minElements)</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">__rmul__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return </span><span class="s1">self.__mul__(other)</span>

    <span class="s3">def </span><span class="s1">__or__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implementation of | operator - returns :class:`MatchFirst` 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">other </span><span class="s3">is </span><span class="s1">Ellipsis:</span>
            <span class="s3">return </span><span class="s1">_PendingSkip(self</span><span class="s3">, </span><span class="s1">must_skip=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">ParserElement):</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Cannot combine element of type %s with ParserElement&quot; </span><span class="s1">% type(other)</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">MatchFirst([self</span><span class="s3">, </span><span class="s1">other])</span>

    <span class="s3">def </span><span class="s1">__ror__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implementation of | operator when left operand is not a :class:`ParserElement` 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">ParserElement):</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Cannot combine element of type %s with ParserElement&quot; </span><span class="s1">% type(other)</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">other | self</span>

    <span class="s3">def </span><span class="s1">__xor__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implementation of ^ operator - returns :class:`Or` 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">ParserElement):</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Cannot combine element of type %s with ParserElement&quot; </span><span class="s1">% type(other)</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">Or([self</span><span class="s3">, </span><span class="s1">other])</span>

    <span class="s3">def </span><span class="s1">__rxor__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implementation of ^ operator when left operand is not a :class:`ParserElement` 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">ParserElement):</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Cannot combine element of type %s with ParserElement&quot; </span><span class="s1">% type(other)</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">other ^ self</span>

    <span class="s3">def </span><span class="s1">__and__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implementation of &amp; operator - returns :class:`Each` 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">ParserElement):</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Cannot combine element of type %s with ParserElement&quot; </span><span class="s1">% type(other)</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">Each([self</span><span class="s3">, </span><span class="s1">other])</span>

    <span class="s3">def </span><span class="s1">__rand__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implementation of &amp; operator when left operand is not a :class:`ParserElement` 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">ParserElement):</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Cannot combine element of type %s with ParserElement&quot; </span><span class="s1">% type(other)</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">other &amp; self</span>

    <span class="s3">def </span><span class="s1">__invert__(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implementation of ~ operator - returns :class:`NotAny` 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">NotAny(self)</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s0"># must implement __iter__ to override legacy use of sequential access to __getitem__ to</span>
        <span class="s0"># iterate over a sequence</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'%r object is not iterable' </span><span class="s1">% self.__class__.__name__)</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s5">&quot;&quot;&quot; 
        use ``[]`` indexing notation as a short form for expression repetition: 
         - ``expr[n]`` is equivalent to ``expr*n`` 
         - ``expr[m, n]`` is equivalent to ``expr*(m, n)`` 
         - ``expr[n, ...]`` or ``expr[n,]`` is equivalent 
              to ``expr*n + ZeroOrMore(expr)`` 
              (read as &quot;at least n instances of ``expr``&quot;) 
         - ``expr[..., n]`` is equivalent to ``expr*(0, n)`` 
              (read as &quot;0 to n instances of ``expr``&quot;) 
         - ``expr[...]`` and ``expr[0, ...]`` are equivalent to ``ZeroOrMore(expr)`` 
         - ``expr[1, ...]`` is equivalent to ``OneOrMore(expr)`` 
         ``None`` may be used in place of ``...``. 
 
        Note that ``expr[..., n]`` and ``expr[m, n]``do not raise an exception 
        if more than ``n`` ``expr``s exist in the input stream.  If this behavior is 
        desired, then write ``expr[..., n] + ~expr``. 
       &quot;&quot;&quot;</span>

        <span class="s0"># convert single arg keys to tuples</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">isinstance(key</span><span class="s3">, </span><span class="s1">str):</span>
                <span class="s1">key = (key</span><span class="s3">,</span><span class="s1">)</span>
            <span class="s1">iter(key)</span>
        <span class="s3">except </span><span class="s1">TypeError:</span>
            <span class="s1">key = (key</span><span class="s3">, </span><span class="s1">key)</span>

        <span class="s3">if </span><span class="s1">len(key) &gt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;only 1 or 2 index arguments supported ({0}{1})&quot;</span><span class="s1">.format(key[:</span><span class="s4">5</span><span class="s1">]</span><span class="s3">,</span>
                                                                                <span class="s2">'... [{0}]'</span><span class="s1">.format(len(key))</span>
                                                                                <span class="s3">if </span><span class="s1">len(key) &gt; </span><span class="s4">5 </span><span class="s3">else </span><span class="s2">''</span><span class="s1">))</span>

        <span class="s0"># clip to 2 elements</span>
        <span class="s1">ret = self * tuple(key[:</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Shortcut for :class:`setResultsName`, with ``listAllMatches=False``. 
 
        If ``name`` is given with a trailing ``'*'`` character, then ``listAllMatches`` will be 
        passed as ``True``. 
 
        If ``name` is omitted, same as calling :class:`copy`. 
 
        Example:: 
 
            # these are equivalent 
            userdata = Word(alphas).setResultsName(&quot;name&quot;) + Word(nums + &quot;-&quot;).setResultsName(&quot;socsecno&quot;) 
            userdata = Word(alphas)(&quot;name&quot;) + Word(nums + &quot;-&quot;)(&quot;socsecno&quot;) 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._setResultsName(name)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.copy()</span>

    <span class="s3">def </span><span class="s1">suppress(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Suppresses the output of this :class:`ParserElement`; useful to keep punctuation from 
        cluttering up returned output. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Suppress(self)</span>

    <span class="s3">def </span><span class="s1">leaveWhitespace(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Disables the skipping of whitespace before matching the characters in the 
        :class:`ParserElement`'s defined pattern.  This is normally only used internally by 
        the pyparsing module, but may be needed in some whitespace-sensitive grammars. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.skipWhitespace = </span><span class="s3">False</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">setWhitespaceChars(self</span><span class="s3">, </span><span class="s1">chars):</span>
        <span class="s5">&quot;&quot;&quot; 
        Overrides the default whitespace chars 
        &quot;&quot;&quot;</span>
        <span class="s1">self.skipWhitespace = </span><span class="s3">True</span>
        <span class="s1">self.whiteChars = chars</span>
        <span class="s1">self.copyDefaultWhiteChars = </span><span class="s3">False</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">parseWithTabs(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Overrides default behavior to expand ``&lt;TAB&gt;``s to spaces before parsing the input string. 
        Must be called before ``parseString`` when the input grammar contains elements that 
        match ``&lt;TAB&gt;`` characters. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.keepTabs = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">ignore(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot; 
        Define expression to be ignored (e.g., comments) while doing pattern 
        matching; may be called repeatedly, to define multiple comment or other 
        ignorable patterns. 
 
        Example:: 
 
            patt = OneOrMore(Word(alphas)) 
            patt.parseString('ablaj /* comment */ lskjd') # -&gt; ['ablaj'] 
 
            patt.ignore(cStyleComment) 
            patt.parseString('ablaj /* comment */ lskjd') # -&gt; ['ablaj', 'lskjd'] 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = Suppress(other)</span>

        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Suppress):</span>
            <span class="s3">if </span><span class="s1">other </span><span class="s3">not in </span><span class="s1">self.ignoreExprs:</span>
                <span class="s1">self.ignoreExprs.append(other)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.ignoreExprs.append(Suppress(other.copy()))</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">setDebugActions(self</span><span class="s3">, </span><span class="s1">startAction</span><span class="s3">, </span><span class="s1">successAction</span><span class="s3">, </span><span class="s1">exceptionAction):</span>
        <span class="s5">&quot;&quot;&quot; 
        Enable display of debugging messages while doing pattern matching. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.debugActions = (startAction </span><span class="s3">or </span><span class="s1">_defaultStartDebugAction</span><span class="s3">,</span>
                             <span class="s1">successAction </span><span class="s3">or </span><span class="s1">_defaultSuccessDebugAction</span><span class="s3">,</span>
                             <span class="s1">exceptionAction </span><span class="s3">or </span><span class="s1">_defaultExceptionDebugAction)</span>
        <span class="s1">self.debug = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">setDebug(self</span><span class="s3">, </span><span class="s1">flag=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Enable display of debugging messages while doing pattern matching. 
        Set ``flag`` to True to enable, False to disable. 
 
        Example:: 
 
            wd = Word(alphas).setName(&quot;alphaword&quot;) 
            integer = Word(nums).setName(&quot;numword&quot;) 
            term = wd | integer 
 
            # turn on debugging for wd 
            wd.setDebug() 
 
            OneOrMore(term).parseString(&quot;abc 123 xyz 890&quot;) 
 
        prints:: 
 
            Match alphaword at loc 0(1,1) 
            Matched alphaword -&gt; ['abc'] 
            Match alphaword at loc 3(1,4) 
            Exception raised:Expected alphaword (at char 4), (line:1, col:5) 
            Match alphaword at loc 7(1,8) 
            Matched alphaword -&gt; ['xyz'] 
            Match alphaword at loc 11(1,12) 
            Exception raised:Expected alphaword (at char 12), (line:1, col:13) 
            Match alphaword at loc 15(1,16) 
            Exception raised:Expected alphaword (at char 15), (line:1, col:16) 
 
        The output shown is that produced by the default debug actions - custom debug actions can be 
        specified using :class:`setDebugActions`. Prior to attempting 
        to match the ``wd`` expression, the debugging message ``&quot;Match &lt;exprname&gt; at loc &lt;n&gt;(&lt;line&gt;,&lt;col&gt;)&quot;`` 
        is shown. Then if the parse succeeds, a ``&quot;Matched&quot;`` message is shown, or an ``&quot;Exception raised&quot;`` 
        message is shown. Also note the use of :class:`setName` to assign a human-readable name to the expression, 
        which makes debugging and exception messages easier to understand - for instance, the default 
        name created for the :class:`Word` expression without calling ``setName`` is ``&quot;W:(ABCD...)&quot;``. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">flag:</span>
            <span class="s1">self.setDebugActions(_defaultStartDebugAction</span><span class="s3">, </span><span class="s1">_defaultSuccessDebugAction</span><span class="s3">, </span><span class="s1">_defaultExceptionDebugAction)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.debug = </span><span class="s3">False</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s1">self.name</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s1">_ustr(self)</span>

    <span class="s3">def </span><span class="s1">streamline(self):</span>
        <span class="s1">self.streamlined = </span><span class="s3">True</span>
        <span class="s1">self.strRepr = </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">checkRecursion(self</span><span class="s3">, </span><span class="s1">parseElementList):</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">validate(self</span><span class="s3">, </span><span class="s1">validateTrace=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Check defined expressions for valid structure, check for infinite recursive definitions. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.checkRecursion([])</span>

    <span class="s3">def </span><span class="s1">parseFile(self</span><span class="s3">, </span><span class="s1">file_or_filename</span><span class="s3">, </span><span class="s1">parseAll=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Execute the parse expression on the given file or filename. 
        If a filename is specified (instead of a file object), 
        the entire file is opened, read, and closed before parsing. 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">file_contents = file_or_filename.read()</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">with </span><span class="s1">open(file_or_filename</span><span class="s3">, </span><span class="s2">&quot;r&quot;</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
                <span class="s1">file_contents = f.read()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.parseString(file_contents</span><span class="s3">, </span><span class="s1">parseAll)</span>
        <span class="s3">except </span><span class="s1">ParseBaseException </span><span class="s3">as </span><span class="s1">exc:</span>
            <span class="s3">if </span><span class="s1">ParserElement.verbose_stacktrace:</span>
                <span class="s3">raise</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># catch and re-raise exception from here, clearing out pyparsing internal stack trace</span>
                <span class="s3">if </span><span class="s1">getattr(exc</span><span class="s3">, </span><span class="s2">'__traceback__'</span><span class="s3">, None</span><span class="s1">) </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">exc.__traceback__ = self._trim_traceback(exc.__traceback__)</span>
                <span class="s3">raise </span><span class="s1">exc</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">self </span><span class="s3">is </span><span class="s1">other:</span>
            <span class="s3">return True</span>
        <span class="s3">elif </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s3">return </span><span class="s1">self.matches(other)</span>
        <span class="s3">elif </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">ParserElement):</span>
            <span class="s3">return </span><span class="s1">vars(self) == vars(other)</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return not </span><span class="s1">(self == other)</span>

    <span class="s3">def </span><span class="s1">__hash__(self):</span>
        <span class="s3">return </span><span class="s1">id(self)</span>

    <span class="s3">def </span><span class="s1">__req__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return </span><span class="s1">self == other</span>

    <span class="s3">def </span><span class="s1">__rne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return not </span><span class="s1">(self == other)</span>

    <span class="s3">def </span><span class="s1">matches(self</span><span class="s3">, </span><span class="s1">testString</span><span class="s3">, </span><span class="s1">parseAll=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Method for quick testing of a parser against a test string. Good for simple 
        inline microtests of sub expressions while building up larger parser. 
 
        Parameters: 
         - testString - to test against this expression for a match 
         - parseAll - (default= ``True``) - flag to pass to :class:`parseString` when running tests 
 
        Example:: 
 
            expr = Word(nums) 
            assert expr.matches(&quot;100&quot;) 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.parseString(_ustr(testString)</span><span class="s3">, </span><span class="s1">parseAll=parseAll)</span>
            <span class="s3">return True</span>
        <span class="s3">except </span><span class="s1">ParseBaseException:</span>
            <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">runTests(self</span><span class="s3">, </span><span class="s1">tests</span><span class="s3">, </span><span class="s1">parseAll=</span><span class="s3">True, </span><span class="s1">comment=</span><span class="s2">'#'</span><span class="s3">,</span>
                 <span class="s1">fullDump=</span><span class="s3">True, </span><span class="s1">printResults=</span><span class="s3">True, </span><span class="s1">failureTests=</span><span class="s3">False, </span><span class="s1">postParse=</span><span class="s3">None,</span>
                 <span class="s1">file=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Execute the parse expression on a series of test strings, showing each 
        test, the parsed results or where the parse failed. Quick and easy way to 
        run a parse expression against a list of sample strings. 
 
        Parameters: 
         - tests - a list of separate test strings, or a multiline string of test strings 
         - parseAll - (default= ``True``) - flag to pass to :class:`parseString` when running tests 
         - comment - (default= ``'#'``) - expression for indicating embedded comments in the test 
              string; pass None to disable comment filtering 
         - fullDump - (default= ``True``) - dump results as list followed by results names in nested outline; 
              if False, only dump nested list 
         - printResults - (default= ``True``) prints test output to stdout 
         - failureTests - (default= ``False``) indicates if these tests are expected to fail parsing 
         - postParse - (default= ``None``) optional callback for successful parse results; called as 
              `fn(test_string, parse_results)` and returns a string to be added to the test output 
         - file - (default=``None``) optional file-like object to which test output will be written; 
              if None, will default to ``sys.stdout`` 
 
        Returns: a (success, results) tuple, where success indicates that all tests succeeded 
        (or failed if ``failureTests`` is True), and the results contain a list of lines of each 
        test's output 
 
        Example:: 
 
            number_expr = pyparsing_common.number.copy() 
 
            result = number_expr.runTests(''' 
                # unsigned integer 
                100 
                # negative integer 
                -100 
                # float with scientific notation 
                6.02e23 
                # integer with scientific notation 
                1e-12 
                ''') 
            print(&quot;Success&quot; if result[0] else &quot;Failed!&quot;) 
 
            result = number_expr.runTests(''' 
                # stray character 
                100Z 
                # missing leading digit before '.' 
                -.100 
                # too many '.' 
                3.14.159 
                ''', failureTests=True) 
            print(&quot;Success&quot; if result[0] else &quot;Failed!&quot;) 
 
        prints:: 
 
            # unsigned integer 
            100 
            [100] 
 
            # negative integer 
            -100 
            [-100] 
 
            # float with scientific notation 
            6.02e23 
            [6.02e+23] 
 
            # integer with scientific notation 
            1e-12 
            [1e-12] 
 
            Success 
 
            # stray character 
            100Z 
               ^ 
            FAIL: Expected end of text (at char 3), (line:1, col:4) 
 
            # missing leading digit before '.' 
            -.100 
            ^ 
            FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1) 
 
            # too many '.' 
            3.14.159 
                ^ 
            FAIL: Expected end of text (at char 4), (line:1, col:5) 
 
            Success 
 
        Each test string must be on a single line. If you want to test a string that spans multiple 
        lines, create a test like this:: 
 
            expr.runTest(r&quot;this is a test\\n of strings that spans \\n 3 lines&quot;) 
 
        (Note that this is a raw string literal, you must include the leading 'r'.) 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(tests</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">tests = list(map(str.strip</span><span class="s3">, </span><span class="s1">tests.rstrip().splitlines()))</span>
        <span class="s3">if </span><span class="s1">isinstance(comment</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">comment = Literal(comment)</span>
        <span class="s3">if </span><span class="s1">file </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">file = sys.stdout</span>
        <span class="s1">print_ = file.write</span>

        <span class="s1">allResults = []</span>
        <span class="s1">comments = []</span>
        <span class="s1">success = </span><span class="s3">True</span>
        <span class="s1">NL = Literal(</span><span class="s2">r'\n'</span><span class="s1">).addParseAction(replaceWith(</span><span class="s2">'</span><span class="s3">\n</span><span class="s2">'</span><span class="s1">)).ignore(quotedString)</span>
        <span class="s1">BOM = </span><span class="s2">u'</span><span class="s3">\ufeff</span><span class="s2">'</span>
        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">tests:</span>
            <span class="s3">if </span><span class="s1">comment </span><span class="s3">is not None and </span><span class="s1">comment.matches(t</span><span class="s3">, False</span><span class="s1">) </span><span class="s3">or </span><span class="s1">comments </span><span class="s3">and not </span><span class="s1">t:</span>
                <span class="s1">comments.append(t)</span>
                <span class="s3">continue</span>
            <span class="s3">if not </span><span class="s1">t:</span>
                <span class="s3">continue</span>
            <span class="s1">out = [</span><span class="s2">'</span><span class="s3">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'</span><span class="s3">\n</span><span class="s2">'</span><span class="s1">.join(comments) </span><span class="s3">if </span><span class="s1">comments </span><span class="s3">else </span><span class="s2">''</span><span class="s3">, </span><span class="s1">t]</span>
            <span class="s1">comments = []</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s0"># convert newline marks to actual newlines, and strip leading BOM if present</span>
                <span class="s1">t = NL.transformString(t.lstrip(BOM))</span>
                <span class="s1">result = self.parseString(t</span><span class="s3">, </span><span class="s1">parseAll=parseAll)</span>
            <span class="s3">except </span><span class="s1">ParseBaseException </span><span class="s3">as </span><span class="s1">pe:</span>
                <span class="s1">fatal = </span><span class="s2">&quot;(FATAL)&quot; </span><span class="s3">if </span><span class="s1">isinstance(pe</span><span class="s3">, </span><span class="s1">ParseFatalException) </span><span class="s3">else </span><span class="s2">&quot;&quot;</span>
                <span class="s3">if </span><span class="s2">'</span><span class="s3">\n</span><span class="s2">' </span><span class="s3">in </span><span class="s1">t:</span>
                    <span class="s1">out.append(line(pe.loc</span><span class="s3">, </span><span class="s1">t))</span>
                    <span class="s1">out.append(</span><span class="s2">' ' </span><span class="s1">* (col(pe.loc</span><span class="s3">, </span><span class="s1">t) - </span><span class="s4">1</span><span class="s1">) + </span><span class="s2">'^' </span><span class="s1">+ fatal)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">out.append(</span><span class="s2">' ' </span><span class="s1">* pe.loc + </span><span class="s2">'^' </span><span class="s1">+ fatal)</span>
                <span class="s1">out.append(</span><span class="s2">&quot;FAIL: &quot; </span><span class="s1">+ str(pe))</span>
                <span class="s1">success = success </span><span class="s3">and </span><span class="s1">failureTests</span>
                <span class="s1">result = pe</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">exc:</span>
                <span class="s1">out.append(</span><span class="s2">&quot;FAIL-EXCEPTION: &quot; </span><span class="s1">+ str(exc))</span>
                <span class="s1">success = success </span><span class="s3">and </span><span class="s1">failureTests</span>
                <span class="s1">result = exc</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">success = success </span><span class="s3">and not </span><span class="s1">failureTests</span>
                <span class="s3">if </span><span class="s1">postParse </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">pp_value = postParse(t</span><span class="s3">, </span><span class="s1">result)</span>
                        <span class="s3">if </span><span class="s1">pp_value </span><span class="s3">is not None</span><span class="s1">:</span>
                            <span class="s3">if </span><span class="s1">isinstance(pp_value</span><span class="s3">, </span><span class="s1">ParseResults):</span>
                                <span class="s1">out.append(pp_value.dump())</span>
                            <span class="s3">else</span><span class="s1">:</span>
                                <span class="s1">out.append(str(pp_value))</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s1">out.append(result.dump())</span>
                    <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e:</span>
                        <span class="s1">out.append(result.dump(full=fullDump))</span>
                        <span class="s1">out.append(</span><span class="s2">&quot;{0} failed: {1}: {2}&quot;</span><span class="s1">.format(postParse.__name__</span><span class="s3">, </span><span class="s1">type(e).__name__</span><span class="s3">, </span><span class="s1">e))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">out.append(result.dump(full=fullDump))</span>

            <span class="s3">if </span><span class="s1">printResults:</span>
                <span class="s3">if </span><span class="s1">fullDump:</span>
                    <span class="s1">out.append(</span><span class="s2">''</span><span class="s1">)</span>
                <span class="s1">print_(</span><span class="s2">'</span><span class="s3">\n</span><span class="s2">'</span><span class="s1">.join(out))</span>

            <span class="s1">allResults.append((t</span><span class="s3">, </span><span class="s1">result))</span>

        <span class="s3">return </span><span class="s1">success</span><span class="s3">, </span><span class="s1">allResults</span>


<span class="s3">class </span><span class="s1">_PendingSkip(ParserElement):</span>
    <span class="s0"># internal placeholder class to hold a place were '...' is added to a parser element,</span>
    <span class="s0"># once another ParserElement is added, this placeholder will be replaced with a SkipTo</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">must_skip=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">super(_PendingSkip</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.strRepr = str(expr + Empty()).replace(</span><span class="s2">'Empty'</span><span class="s3">, </span><span class="s2">'...'</span><span class="s1">)</span>
        <span class="s1">self.name = self.strRepr</span>
        <span class="s1">self.anchor = expr</span>
        <span class="s1">self.must_skip = must_skip</span>

    <span class="s3">def </span><span class="s1">__add__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">skipper = SkipTo(other).setName(</span><span class="s2">&quot;...&quot;</span><span class="s1">)(</span><span class="s2">&quot;_skipped*&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.must_skip:</span>
            <span class="s3">def </span><span class="s1">must_skip(t):</span>
                <span class="s3">if not </span><span class="s1">t._skipped </span><span class="s3">or </span><span class="s1">t._skipped.asList() == [</span><span class="s2">''</span><span class="s1">]:</span>
                    <span class="s3">del </span><span class="s1">t[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s1">t.pop(</span><span class="s2">&quot;_skipped&quot;</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s3">def </span><span class="s1">show_skip(t):</span>
                <span class="s3">if </span><span class="s1">t._skipped.asList()[-</span><span class="s4">1</span><span class="s1">:] == [</span><span class="s2">''</span><span class="s1">]:</span>
                    <span class="s1">skipped = t.pop(</span><span class="s2">'_skipped'</span><span class="s1">)</span>
                    <span class="s1">t[</span><span class="s2">'_skipped'</span><span class="s1">] = </span><span class="s2">'missing &lt;' </span><span class="s1">+ repr(self.anchor) + </span><span class="s2">'&gt;'</span>
            <span class="s3">return </span><span class="s1">(self.anchor + skipper().addParseAction(must_skip)</span>
                    <span class="s1">| skipper().addParseAction(show_skip)) + other</span>

        <span class="s3">return </span><span class="s1">self.anchor + skipper + other</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s1">self.strRepr</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;use of `...` expression without following SkipTo target expression&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">Token(ParserElement):</span>
    <span class="s5">&quot;&quot;&quot;Abstract :class:`ParserElement` subclass, for defining atomic 
    matching patterns. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super(Token</span><span class="s3">, </span><span class="s1">self).__init__(savelist=</span><span class="s3">False</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">Empty(Token):</span>
    <span class="s5">&quot;&quot;&quot;An empty token, will always match. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super(Empty</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.name = </span><span class="s2">&quot;Empty&quot;</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">False</span>


<span class="s3">class </span><span class="s1">NoMatch(Token):</span>
    <span class="s5">&quot;&quot;&quot;A token that will never match. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super(NoMatch</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.name = </span><span class="s2">&quot;NoMatch&quot;</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">False</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Unmatchable token&quot;</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>


<span class="s3">class </span><span class="s1">Literal(Token):</span>
    <span class="s5">&quot;&quot;&quot;Token to exactly match a specified string. 
 
    Example:: 
 
        Literal('blah').parseString('blah')  # -&gt; ['blah'] 
        Literal('blah').parseString('blahfooblah')  # -&gt; ['blah'] 
        Literal('blah').parseString('bla')  # -&gt; Exception: Expected &quot;blah&quot; 
 
    For case-insensitive matching, use :class:`CaselessLiteral`. 
 
    For keyword matching (force word break before and after the matched string), 
    use :class:`Keyword` or :class:`CaselessKeyword`. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">matchString):</span>
        <span class="s1">super(Literal</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.match = matchString</span>
        <span class="s1">self.matchLen = len(matchString)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.firstMatchChar = matchString[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">except </span><span class="s1">IndexError:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;null string passed to Literal; use Empty() instead&quot;</span><span class="s3">,</span>
                            <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">self.__class__ = Empty</span>
        <span class="s1">self.name = </span><span class="s2">'&quot;%s&quot;' </span><span class="s1">% _ustr(self.match)</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">False</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">False</span>

        <span class="s0"># Performance tuning: modify __class__ to select</span>
        <span class="s0"># a parseImpl optimized for single-character check</span>
        <span class="s3">if </span><span class="s1">self.matchLen == </span><span class="s4">1 </span><span class="s3">and </span><span class="s1">type(self) </span><span class="s3">is </span><span class="s1">Literal:</span>
            <span class="s1">self.__class__ = _SingleCharLiteral</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">instring[loc] == self.firstMatchChar </span><span class="s3">and </span><span class="s1">instring.startswith(self.match</span><span class="s3">, </span><span class="s1">loc):</span>
            <span class="s3">return </span><span class="s1">loc + self.matchLen</span><span class="s3">, </span><span class="s1">self.match</span>
        <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

<span class="s3">class </span><span class="s1">_SingleCharLiteral(Literal):</span>
    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">instring[loc] == self.firstMatchChar:</span>
            <span class="s3">return </span><span class="s1">loc + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">self.match</span>
        <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

<span class="s1">_L = Literal</span>
<span class="s1">ParserElement._literalStringClass = Literal</span>

<span class="s3">class </span><span class="s1">Keyword(Token):</span>
    <span class="s5">&quot;&quot;&quot;Token to exactly match a specified string as a keyword, that is, 
    it must be immediately followed by a non-keyword character.  Compare 
    with :class:`Literal`: 
 
     - ``Literal(&quot;if&quot;)`` will match the leading ``'if'`` in 
       ``'ifAndOnlyIf'``. 
     - ``Keyword(&quot;if&quot;)`` will not; it will only match the leading 
       ``'if'`` in ``'if x=1'``, or ``'if(y==2)'`` 
 
    Accepts two optional constructor arguments in addition to the 
    keyword string: 
 
     - ``identChars`` is a string of characters that would be valid 
       identifier characters, defaulting to all alphanumerics + &quot;_&quot; and 
       &quot;$&quot; 
     - ``caseless`` allows case-insensitive matching, default is ``False``. 
 
    Example:: 
 
        Keyword(&quot;start&quot;).parseString(&quot;start&quot;)  # -&gt; ['start'] 
        Keyword(&quot;start&quot;).parseString(&quot;starting&quot;)  # -&gt; Exception 
 
    For case-insensitive matching, use :class:`CaselessKeyword`. 
    &quot;&quot;&quot;</span>
    <span class="s1">DEFAULT_KEYWORD_CHARS = alphanums + </span><span class="s2">&quot;_$&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">matchString</span><span class="s3">, </span><span class="s1">identChars=</span><span class="s3">None, </span><span class="s1">caseless=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">super(Keyword</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s3">if </span><span class="s1">identChars </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">identChars = Keyword.DEFAULT_KEYWORD_CHARS</span>
        <span class="s1">self.match = matchString</span>
        <span class="s1">self.matchLen = len(matchString)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.firstMatchChar = matchString[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">except </span><span class="s1">IndexError:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;null string passed to Keyword; use Empty() instead&quot;</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.name = </span><span class="s2">'&quot;%s&quot;' </span><span class="s1">% self.match</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">False</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">False</span>
        <span class="s1">self.caseless = caseless</span>
        <span class="s3">if </span><span class="s1">caseless:</span>
            <span class="s1">self.caselessmatch = matchString.upper()</span>
            <span class="s1">identChars = identChars.upper()</span>
        <span class="s1">self.identChars = set(identChars)</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">self.caseless:</span>
            <span class="s3">if </span><span class="s1">((instring[loc:loc + self.matchLen].upper() == self.caselessmatch)</span>
                    <span class="s3">and </span><span class="s1">(loc &gt;= len(instring) - self.matchLen</span>
                         <span class="s3">or </span><span class="s1">instring[loc + self.matchLen].upper() </span><span class="s3">not in </span><span class="s1">self.identChars)</span>
                    <span class="s3">and </span><span class="s1">(loc == </span><span class="s4">0</span>
                         <span class="s3">or </span><span class="s1">instring[loc - </span><span class="s4">1</span><span class="s1">].upper() </span><span class="s3">not in </span><span class="s1">self.identChars)):</span>
                <span class="s3">return </span><span class="s1">loc + self.matchLen</span><span class="s3">, </span><span class="s1">self.match</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">instring[loc] == self.firstMatchChar:</span>
                <span class="s3">if </span><span class="s1">((self.matchLen == </span><span class="s4">1 </span><span class="s3">or </span><span class="s1">instring.startswith(self.match</span><span class="s3">, </span><span class="s1">loc))</span>
                        <span class="s3">and </span><span class="s1">(loc &gt;= len(instring) - self.matchLen</span>
                             <span class="s3">or </span><span class="s1">instring[loc + self.matchLen] </span><span class="s3">not in </span><span class="s1">self.identChars)</span>
                        <span class="s3">and </span><span class="s1">(loc == </span><span class="s4">0 </span><span class="s3">or </span><span class="s1">instring[loc - </span><span class="s4">1</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">self.identChars)):</span>
                    <span class="s3">return </span><span class="s1">loc + self.matchLen</span><span class="s3">, </span><span class="s1">self.match</span>

        <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s1">c = super(Keyword</span><span class="s3">, </span><span class="s1">self).copy()</span>
        <span class="s1">c.identChars = Keyword.DEFAULT_KEYWORD_CHARS</span>
        <span class="s3">return </span><span class="s1">c</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">setDefaultKeywordChars(chars):</span>
        <span class="s5">&quot;&quot;&quot;Overrides the default Keyword chars 
        &quot;&quot;&quot;</span>
        <span class="s1">Keyword.DEFAULT_KEYWORD_CHARS = chars</span>

<span class="s3">class </span><span class="s1">CaselessLiteral(Literal):</span>
    <span class="s5">&quot;&quot;&quot;Token to match a specified string, ignoring case of letters. 
    Note: the matched results will always be in the case of the given 
    match string, NOT the case of the input text. 
 
    Example:: 
 
        OneOrMore(CaselessLiteral(&quot;CMD&quot;)).parseString(&quot;cmd CMD Cmd10&quot;) # -&gt; ['CMD', 'CMD', 'CMD'] 
 
    (Contrast with example for :class:`CaselessKeyword`.) 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">matchString):</span>
        <span class="s1">super(CaselessLiteral</span><span class="s3">, </span><span class="s1">self).__init__(matchString.upper())</span>
        <span class="s0"># Preserve the defining literal.</span>
        <span class="s1">self.returnString = matchString</span>
        <span class="s1">self.name = </span><span class="s2">&quot;'%s'&quot; </span><span class="s1">% self.returnString</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected &quot; </span><span class="s1">+ self.name</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">instring[loc:loc + self.matchLen].upper() == self.match:</span>
            <span class="s3">return </span><span class="s1">loc + self.matchLen</span><span class="s3">, </span><span class="s1">self.returnString</span>
        <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

<span class="s3">class </span><span class="s1">CaselessKeyword(Keyword):</span>
    <span class="s5">&quot;&quot;&quot; 
    Caseless version of :class:`Keyword`. 
 
    Example:: 
 
        OneOrMore(CaselessKeyword(&quot;CMD&quot;)).parseString(&quot;cmd CMD Cmd10&quot;) # -&gt; ['CMD', 'CMD'] 
 
    (Contrast with example for :class:`CaselessLiteral`.) 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">matchString</span><span class="s3">, </span><span class="s1">identChars=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super(CaselessKeyword</span><span class="s3">, </span><span class="s1">self).__init__(matchString</span><span class="s3">, </span><span class="s1">identChars</span><span class="s3">, </span><span class="s1">caseless=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s3">class </span><span class="s1">CloseMatch(Token):</span>
    <span class="s5">&quot;&quot;&quot;A variation on :class:`Literal` which matches &quot;close&quot; matches, 
    that is, strings with at most 'n' mismatching characters. 
    :class:`CloseMatch` takes parameters: 
 
     - ``match_string`` - string to be matched 
     - ``maxMismatches`` - (``default=1``) maximum number of 
       mismatches allowed to count as a match 
 
    The results from a successful parse will contain the matched text 
    from the input string and the following named results: 
 
     - ``mismatches`` - a list of the positions within the 
       match_string where mismatches were found 
     - ``original`` - the original match_string used to compare 
       against the input string 
 
    If ``mismatches`` is an empty list, then the match was an exact 
    match. 
 
    Example:: 
 
        patt = CloseMatch(&quot;ATCATCGAATGGA&quot;) 
        patt.parseString(&quot;ATCATCGAAXGGA&quot;) # -&gt; (['ATCATCGAAXGGA'], {'mismatches': [[9]], 'original': ['ATCATCGAATGGA']}) 
        patt.parseString(&quot;ATCAXCGAAXGGA&quot;) # -&gt; Exception: Expected 'ATCATCGAATGGA' (with up to 1 mismatches) (at char 0), (line:1, col:1) 
 
        # exact match 
        patt.parseString(&quot;ATCATCGAATGGA&quot;) # -&gt; (['ATCATCGAATGGA'], {'mismatches': [[]], 'original': ['ATCATCGAATGGA']}) 
 
        # close match allowing up to 2 mismatches 
        patt = CloseMatch(&quot;ATCATCGAATGGA&quot;, maxMismatches=2) 
        patt.parseString(&quot;ATCAXCGAAXGGA&quot;) # -&gt; (['ATCAXCGAAXGGA'], {'mismatches': [[4, 9]], 'original': ['ATCATCGAATGGA']}) 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">match_string</span><span class="s3">, </span><span class="s1">maxMismatches=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">super(CloseMatch</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.name = match_string</span>
        <span class="s1">self.match_string = match_string</span>
        <span class="s1">self.maxMismatches = maxMismatches</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected %r (with up to %d mismatches)&quot; </span><span class="s1">% (self.match_string</span><span class="s3">, </span><span class="s1">self.maxMismatches)</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">False</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">start = loc</span>
        <span class="s1">instrlen = len(instring)</span>
        <span class="s1">maxloc = start + len(self.match_string)</span>

        <span class="s3">if </span><span class="s1">maxloc &lt;= instrlen:</span>
            <span class="s1">match_string = self.match_string</span>
            <span class="s1">match_stringloc = </span><span class="s4">0</span>
            <span class="s1">mismatches = []</span>
            <span class="s1">maxMismatches = self.maxMismatches</span>

            <span class="s3">for </span><span class="s1">match_stringloc</span><span class="s3">, </span><span class="s1">s_m </span><span class="s3">in </span><span class="s1">enumerate(zip(instring[loc:maxloc]</span><span class="s3">, </span><span class="s1">match_string)):</span>
                <span class="s1">src</span><span class="s3">, </span><span class="s1">mat = s_m</span>
                <span class="s3">if </span><span class="s1">src != mat:</span>
                    <span class="s1">mismatches.append(match_stringloc)</span>
                    <span class="s3">if </span><span class="s1">len(mismatches) &gt; maxMismatches:</span>
                        <span class="s3">break</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">loc = match_stringloc + </span><span class="s4">1</span>
                <span class="s1">results = ParseResults([instring[start:loc]])</span>
                <span class="s1">results[</span><span class="s2">'original'</span><span class="s1">] = match_string</span>
                <span class="s1">results[</span><span class="s2">'mismatches'</span><span class="s1">] = mismatches</span>
                <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">results</span>

        <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>


<span class="s3">class </span><span class="s1">Word(Token):</span>
    <span class="s5">&quot;&quot;&quot;Token for matching words composed of allowed character sets. 
    Defined with string containing all allowed initial characters, an 
    optional string containing allowed body characters (if omitted, 
    defaults to the initial character set), and an optional minimum, 
    maximum, and/or exact length.  The default value for ``min`` is 
    1 (a minimum value &lt; 1 is not valid); the default values for 
    ``max`` and ``exact`` are 0, meaning no maximum or exact 
    length restriction. An optional ``excludeChars`` parameter can 
    list characters that might be found in the input ``bodyChars`` 
    string; useful to define a word of all printables except for one or 
    two characters, for instance. 
 
    :class:`srange` is useful for defining custom character set strings 
    for defining ``Word`` expressions, using range notation from 
    regular expression character sets. 
 
    A common mistake is to use :class:`Word` to match a specific literal 
    string, as in ``Word(&quot;Address&quot;)``. Remember that :class:`Word` 
    uses the string argument to define *sets* of matchable characters. 
    This expression would match &quot;Add&quot;, &quot;AAA&quot;, &quot;dAred&quot;, or any other word 
    made up of the characters 'A', 'd', 'r', 'e', and 's'. To match an 
    exact literal string, use :class:`Literal` or :class:`Keyword`. 
 
    pyparsing includes helper strings for building Words: 
 
     - :class:`alphas` 
     - :class:`nums` 
     - :class:`alphanums` 
     - :class:`hexnums` 
     - :class:`alphas8bit` (alphabetic characters in ASCII range 128-255 
       - accented, tilded, umlauted, etc.) 
     - :class:`punc8bit` (non-alphabetic characters in ASCII range 
       128-255 - currency, symbols, superscripts, diacriticals, etc.) 
     - :class:`printables` (any non-whitespace character) 
 
    Example:: 
 
        # a word composed of digits 
        integer = Word(nums) # equivalent to Word(&quot;0123456789&quot;) or Word(srange(&quot;0-9&quot;)) 
 
        # a word with a leading capital, and zero or more lowercase 
        capital_word = Word(alphas.upper(), alphas.lower()) 
 
        # hostnames are alphanumeric, with leading alpha, and '-' 
        hostname = Word(alphas, alphanums + '-') 
 
        # roman numeral (not a strict parser, accepts invalid mix of characters) 
        roman = Word(&quot;IVXLCDM&quot;) 
 
        # any string of non-whitespace characters, except for ',' 
        csv_value = Word(printables, excludeChars=&quot;,&quot;) 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">initChars</span><span class="s3">, </span><span class="s1">bodyChars=</span><span class="s3">None, </span><span class="s1">min=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">max=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">exact=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">asKeyword=</span><span class="s3">False, </span><span class="s1">excludeChars=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super(Word</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s3">if </span><span class="s1">excludeChars:</span>
            <span class="s1">excludeChars = set(excludeChars)</span>
            <span class="s1">initChars = </span><span class="s2">''</span><span class="s1">.join(c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">initChars </span><span class="s3">if </span><span class="s1">c </span><span class="s3">not in </span><span class="s1">excludeChars)</span>
            <span class="s3">if </span><span class="s1">bodyChars:</span>
                <span class="s1">bodyChars = </span><span class="s2">''</span><span class="s1">.join(c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">bodyChars </span><span class="s3">if </span><span class="s1">c </span><span class="s3">not in </span><span class="s1">excludeChars)</span>
        <span class="s1">self.initCharsOrig = initChars</span>
        <span class="s1">self.initChars = set(initChars)</span>
        <span class="s3">if </span><span class="s1">bodyChars:</span>
            <span class="s1">self.bodyCharsOrig = bodyChars</span>
            <span class="s1">self.bodyChars = set(bodyChars)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.bodyCharsOrig = initChars</span>
            <span class="s1">self.bodyChars = set(initChars)</span>

        <span class="s1">self.maxSpecified = max &gt; </span><span class="s4">0</span>

        <span class="s3">if </span><span class="s1">min &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;cannot specify a minimum length &lt; 1; use Optional(Word()) if zero-length word is permitted&quot;</span><span class="s1">)</span>

        <span class="s1">self.minLen = min</span>

        <span class="s3">if </span><span class="s1">max &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.maxLen = max</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.maxLen = _MAX_INT</span>

        <span class="s3">if </span><span class="s1">exact &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.maxLen = exact</span>
            <span class="s1">self.minLen = exact</span>

        <span class="s1">self.name = _ustr(self)</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">False</span>
        <span class="s1">self.asKeyword = asKeyword</span>

        <span class="s3">if </span><span class="s2">' ' </span><span class="s3">not in </span><span class="s1">self.initCharsOrig + self.bodyCharsOrig </span><span class="s3">and </span><span class="s1">(min == </span><span class="s4">1 </span><span class="s3">and </span><span class="s1">max == </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">exact == </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">self.bodyCharsOrig == self.initCharsOrig:</span>
                <span class="s1">self.reString = </span><span class="s2">&quot;[%s]+&quot; </span><span class="s1">% _escapeRegexRangeChars(self.initCharsOrig)</span>
            <span class="s3">elif </span><span class="s1">len(self.initCharsOrig) == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self.reString = </span><span class="s2">&quot;%s[%s]*&quot; </span><span class="s1">% (re.escape(self.initCharsOrig)</span><span class="s3">,</span>
                                             <span class="s1">_escapeRegexRangeChars(self.bodyCharsOrig)</span><span class="s3">,</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.reString = </span><span class="s2">&quot;[%s][%s]*&quot; </span><span class="s1">% (_escapeRegexRangeChars(self.initCharsOrig)</span><span class="s3">,</span>
                                               <span class="s1">_escapeRegexRangeChars(self.bodyCharsOrig)</span><span class="s3">,</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">self.asKeyword:</span>
                <span class="s1">self.reString = </span><span class="s2">r&quot;\b&quot; </span><span class="s1">+ self.reString + </span><span class="s2">r&quot;\b&quot;</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.re = re.compile(self.reString)</span>
            <span class="s3">except </span><span class="s1">Exception:</span>
                <span class="s1">self.re = </span><span class="s3">None</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.re_match = self.re.match</span>
                <span class="s1">self.__class__ = _WordRegex</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">instring[loc] </span><span class="s3">not in </span><span class="s1">self.initChars:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

        <span class="s1">start = loc</span>
        <span class="s1">loc += </span><span class="s4">1</span>
        <span class="s1">instrlen = len(instring)</span>
        <span class="s1">bodychars = self.bodyChars</span>
        <span class="s1">maxloc = start + self.maxLen</span>
        <span class="s1">maxloc = min(maxloc</span><span class="s3">, </span><span class="s1">instrlen)</span>
        <span class="s3">while </span><span class="s1">loc &lt; maxloc </span><span class="s3">and </span><span class="s1">instring[loc] </span><span class="s3">in </span><span class="s1">bodychars:</span>
            <span class="s1">loc += </span><span class="s4">1</span>

        <span class="s1">throwException = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">loc - start &lt; self.minLen:</span>
            <span class="s1">throwException = </span><span class="s3">True</span>
        <span class="s3">elif </span><span class="s1">self.maxSpecified </span><span class="s3">and </span><span class="s1">loc &lt; instrlen </span><span class="s3">and </span><span class="s1">instring[loc] </span><span class="s3">in </span><span class="s1">bodychars:</span>
            <span class="s1">throwException = </span><span class="s3">True</span>
        <span class="s3">elif </span><span class="s1">self.asKeyword:</span>
            <span class="s3">if </span><span class="s1">(start &gt; </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">instring[start - </span><span class="s4">1</span><span class="s1">] </span><span class="s3">in </span><span class="s1">bodychars</span>
                    <span class="s3">or </span><span class="s1">loc &lt; instrlen </span><span class="s3">and </span><span class="s1">instring[loc] </span><span class="s3">in </span><span class="s1">bodychars):</span>
                <span class="s1">throwException = </span><span class="s3">True</span>

        <span class="s3">if </span><span class="s1">throwException:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">instring[start:loc]</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">super(Word</span><span class="s3">, </span><span class="s1">self).__str__()</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s3">pass</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>

            <span class="s3">def </span><span class="s1">charsAsStr(s):</span>
                <span class="s3">if </span><span class="s1">len(s) &gt; </span><span class="s4">4</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">s[:</span><span class="s4">4</span><span class="s1">] + </span><span class="s2">&quot;...&quot;</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">s</span>

            <span class="s3">if </span><span class="s1">self.initCharsOrig != self.bodyCharsOrig:</span>
                <span class="s1">self.strRepr = </span><span class="s2">&quot;W:(%s, %s)&quot; </span><span class="s1">% (charsAsStr(self.initCharsOrig)</span><span class="s3">, </span><span class="s1">charsAsStr(self.bodyCharsOrig))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.strRepr = </span><span class="s2">&quot;W:(%s)&quot; </span><span class="s1">% charsAsStr(self.initCharsOrig)</span>

        <span class="s3">return </span><span class="s1">self.strRepr</span>

<span class="s3">class </span><span class="s1">_WordRegex(Word):</span>
    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">result = self.re_match(instring</span><span class="s3">, </span><span class="s1">loc)</span>
        <span class="s3">if not </span><span class="s1">result:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

        <span class="s1">loc = result.end()</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">result.group()</span>


<span class="s3">class </span><span class="s1">Char(_WordRegex):</span>
    <span class="s5">&quot;&quot;&quot;A short-cut class for defining ``Word(characters, exact=1)``, 
    when defining a match of any single character in a string of 
    characters. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">charset</span><span class="s3">, </span><span class="s1">asKeyword=</span><span class="s3">False, </span><span class="s1">excludeChars=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super(Char</span><span class="s3">, </span><span class="s1">self).__init__(charset</span><span class="s3">, </span><span class="s1">exact=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">asKeyword=asKeyword</span><span class="s3">, </span><span class="s1">excludeChars=excludeChars)</span>
        <span class="s1">self.reString = </span><span class="s2">&quot;[%s]&quot; </span><span class="s1">% _escapeRegexRangeChars(</span><span class="s2">''</span><span class="s1">.join(self.initChars))</span>
        <span class="s3">if </span><span class="s1">asKeyword:</span>
            <span class="s1">self.reString = </span><span class="s2">r&quot;\b%s\b&quot; </span><span class="s1">% self.reString</span>
        <span class="s1">self.re = re.compile(self.reString)</span>
        <span class="s1">self.re_match = self.re.match</span>


<span class="s3">class </span><span class="s1">Regex(Token):</span>
    <span class="s5">r&quot;&quot;&quot;Token for matching strings that match a given regular 
    expression. Defined with string specifying the regular expression in 
    a form recognized by the stdlib Python  `re module &lt;https://docs.python.org/3/library/re.html&gt;`_. 
    If the given regex contains named groups (defined using ``(?P&lt;name&gt;...)``), 
    these will be preserved as named parse results. 
 
    If instead of the Python stdlib re module you wish to use a different RE module 
    (such as the `regex` module), you can replace it by either building your 
    Regex object with a compiled RE that was compiled using regex: 
 
    Example:: 
 
        realnum = Regex(r&quot;[+-]?\d+\.\d*&quot;) 
        date = Regex(r'(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d\d?)-(?P&lt;day&gt;\d\d?)') 
        # ref: https://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression 
        roman = Regex(r&quot;M{0,4}(CM|CD|D?{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})&quot;) 
 
        # use regex module instead of stdlib re module to construct a Regex using 
        # a compiled regular expression 
        import regex 
        parser = pp.Regex(regex.compile(r'[0-9]')) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">pattern</span><span class="s3">, </span><span class="s1">flags=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">asGroupList=</span><span class="s3">False, </span><span class="s1">asMatch=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;The parameters ``pattern`` and ``flags`` are passed 
        to the ``re.compile()`` function as-is. See the Python 
        `re module &lt;https://docs.python.org/3/library/re.html&gt;`_ module for an 
        explanation of the acceptable patterns and flags. 
        &quot;&quot;&quot;</span>
        <span class="s1">super(Regex</span><span class="s3">, </span><span class="s1">self).__init__()</span>

        <span class="s3">if </span><span class="s1">isinstance(pattern</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s3">if not </span><span class="s1">pattern:</span>
                <span class="s1">warnings.warn(</span><span class="s2">&quot;null string passed to Regex; use Empty() instead&quot;</span><span class="s3">,</span>
                              <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>

            <span class="s1">self.pattern = pattern</span>
            <span class="s1">self.flags = flags</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.re = re.compile(self.pattern</span><span class="s3">, </span><span class="s1">self.flags)</span>
                <span class="s1">self.reString = self.pattern</span>
            <span class="s3">except </span><span class="s1">sre_constants.error:</span>
                <span class="s1">warnings.warn(</span><span class="s2">&quot;invalid pattern (%s) passed to Regex&quot; </span><span class="s1">% pattern</span><span class="s3">,</span>
                              <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
                <span class="s3">raise</span>

        <span class="s3">elif </span><span class="s1">hasattr(pattern</span><span class="s3">, </span><span class="s2">'pattern'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">hasattr(pattern</span><span class="s3">, </span><span class="s2">'match'</span><span class="s1">):</span>
            <span class="s1">self.re = pattern</span>
            <span class="s1">self.pattern = self.reString = pattern.pattern</span>
            <span class="s1">self.flags = flags</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Regex may only be constructed with a string or a compiled RE object&quot;</span><span class="s1">)</span>

        <span class="s1">self.re_match = self.re.match</span>

        <span class="s1">self.name = _ustr(self)</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">False</span>
        <span class="s1">self.mayReturnEmpty = self.re_match(</span><span class="s2">&quot;&quot;</span><span class="s1">) </span><span class="s3">is not None</span>
        <span class="s1">self.asGroupList = asGroupList</span>
        <span class="s1">self.asMatch = asMatch</span>
        <span class="s3">if </span><span class="s1">self.asGroupList:</span>
            <span class="s1">self.parseImpl = self.parseImplAsGroupList</span>
        <span class="s3">if </span><span class="s1">self.asMatch:</span>
            <span class="s1">self.parseImpl = self.parseImplAsMatch</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">result = self.re_match(instring</span><span class="s3">, </span><span class="s1">loc)</span>
        <span class="s3">if not </span><span class="s1">result:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

        <span class="s1">loc = result.end()</span>
        <span class="s1">ret = ParseResults(result.group())</span>
        <span class="s1">d = result.groupdict()</span>
        <span class="s3">if </span><span class="s1">d:</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">d.items():</span>
                <span class="s1">ret[k] = v</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">parseImplAsGroupList(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">result = self.re_match(instring</span><span class="s3">, </span><span class="s1">loc)</span>
        <span class="s3">if not </span><span class="s1">result:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

        <span class="s1">loc = result.end()</span>
        <span class="s1">ret = result.groups()</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">parseImplAsMatch(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">result = self.re_match(instring</span><span class="s3">, </span><span class="s1">loc)</span>
        <span class="s3">if not </span><span class="s1">result:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

        <span class="s1">loc = result.end()</span>
        <span class="s1">ret = result</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">super(Regex</span><span class="s3">, </span><span class="s1">self).__str__()</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s3">pass</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.strRepr = </span><span class="s2">&quot;Re:(%s)&quot; </span><span class="s1">% repr(self.pattern)</span>

        <span class="s3">return </span><span class="s1">self.strRepr</span>

    <span class="s3">def </span><span class="s1">sub(self</span><span class="s3">, </span><span class="s1">repl):</span>
        <span class="s5">r&quot;&quot;&quot; 
        Return Regex with an attached parse action to transform the parsed 
        result as if called using `re.sub(expr, repl, string) &lt;https://docs.python.org/3/library/re.html#re.sub&gt;`_. 
 
        Example:: 
 
            make_html = Regex(r&quot;(\w+):(.*?):&quot;).sub(r&quot;&lt;\1&gt;\2&lt;/\1&gt;&quot;) 
            print(make_html.transformString(&quot;h1:main title:&quot;)) 
            # prints &quot;&lt;h1&gt;main title&lt;/h1&gt;&quot; 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.asGroupList:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;cannot use sub() with Regex(asGroupList=True)&quot;</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">raise </span><span class="s1">SyntaxError()</span>

        <span class="s3">if </span><span class="s1">self.asMatch </span><span class="s3">and </span><span class="s1">callable(repl):</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;cannot use sub() with a callable with Regex(asMatch=True)&quot;</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">raise </span><span class="s1">SyntaxError()</span>

        <span class="s3">if </span><span class="s1">self.asMatch:</span>
            <span class="s3">def </span><span class="s1">pa(tokens):</span>
                <span class="s3">return </span><span class="s1">tokens[</span><span class="s4">0</span><span class="s1">].expand(repl)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">def </span><span class="s1">pa(tokens):</span>
                <span class="s3">return </span><span class="s1">self.re.sub(repl</span><span class="s3">, </span><span class="s1">tokens[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s3">return </span><span class="s1">self.addParseAction(pa)</span>

<span class="s3">class </span><span class="s1">QuotedString(Token):</span>
    <span class="s5">r&quot;&quot;&quot; 
    Token for matching strings that are delimited by quoting characters. 
 
    Defined with the following parameters: 
 
        - quoteChar - string of one or more characters defining the 
          quote delimiting string 
        - escChar - character to escape quotes, typically backslash 
          (default= ``None``) 
        - escQuote - special quote sequence to escape an embedded quote 
          string (such as SQL's ``&quot;&quot;`` to escape an embedded ``&quot;``) 
          (default= ``None``) 
        - multiline - boolean indicating whether quotes can span 
          multiple lines (default= ``False``) 
        - unquoteResults - boolean indicating whether the matched text 
          should be unquoted (default= ``True``) 
        - endQuoteChar - string of one or more characters defining the 
          end of the quote delimited string (default= ``None``  =&gt; same as 
          quoteChar) 
        - convertWhitespaceEscapes - convert escaped whitespace 
          (``'\t'``, ``'\n'``, etc.) to actual whitespace 
          (default= ``True``) 
 
    Example:: 
 
        qs = QuotedString('&quot;') 
        print(qs.searchString('lsjdf &quot;This is the quote&quot; sldjf')) 
        complex_qs = QuotedString('{{', endQuoteChar='}}') 
        print(complex_qs.searchString('lsjdf {{This is the &quot;quote&quot;}} sldjf')) 
        sql_qs = QuotedString('&quot;', escQuote='&quot;&quot;') 
        print(sql_qs.searchString('lsjdf &quot;This is the quote with &quot;&quot;embedded&quot;&quot; quotes&quot; sldjf')) 
 
    prints:: 
 
        [['This is the quote']] 
        [['This is the &quot;quote&quot;']] 
        [['This is the quote with &quot;embedded&quot; quotes']] 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">quoteChar</span><span class="s3">, </span><span class="s1">escChar=</span><span class="s3">None, </span><span class="s1">escQuote=</span><span class="s3">None, </span><span class="s1">multiline=</span><span class="s3">False,</span>
                 <span class="s1">unquoteResults=</span><span class="s3">True, </span><span class="s1">endQuoteChar=</span><span class="s3">None, </span><span class="s1">convertWhitespaceEscapes=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">super(QuotedString</span><span class="s3">, </span><span class="s1">self).__init__()</span>

        <span class="s0"># remove white space from quote chars - wont work anyway</span>
        <span class="s1">quoteChar = quoteChar.strip()</span>
        <span class="s3">if not </span><span class="s1">quoteChar:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;quoteChar cannot be the empty string&quot;</span><span class="s3">, </span><span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">raise </span><span class="s1">SyntaxError()</span>

        <span class="s3">if </span><span class="s1">endQuoteChar </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">endQuoteChar = quoteChar</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">endQuoteChar = endQuoteChar.strip()</span>
            <span class="s3">if not </span><span class="s1">endQuoteChar:</span>
                <span class="s1">warnings.warn(</span><span class="s2">&quot;endQuoteChar cannot be the empty string&quot;</span><span class="s3">, </span><span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
                <span class="s3">raise </span><span class="s1">SyntaxError()</span>

        <span class="s1">self.quoteChar = quoteChar</span>
        <span class="s1">self.quoteCharLen = len(quoteChar)</span>
        <span class="s1">self.firstQuoteChar = quoteChar[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.endQuoteChar = endQuoteChar</span>
        <span class="s1">self.endQuoteCharLen = len(endQuoteChar)</span>
        <span class="s1">self.escChar = escChar</span>
        <span class="s1">self.escQuote = escQuote</span>
        <span class="s1">self.unquoteResults = unquoteResults</span>
        <span class="s1">self.convertWhitespaceEscapes = convertWhitespaceEscapes</span>

        <span class="s3">if </span><span class="s1">multiline:</span>
            <span class="s1">self.flags = re.MULTILINE | re.DOTALL</span>
            <span class="s1">self.pattern = </span><span class="s2">r'%s(?:[^%s%s]' </span><span class="s1">% (re.escape(self.quoteChar)</span><span class="s3">,</span>
                                              <span class="s1">_escapeRegexRangeChars(self.endQuoteChar[</span><span class="s4">0</span><span class="s1">])</span><span class="s3">,</span>
                                              <span class="s1">(escChar </span><span class="s3">is not None and </span><span class="s1">_escapeRegexRangeChars(escChar) </span><span class="s3">or </span><span class="s2">''</span><span class="s1">))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.flags = </span><span class="s4">0</span>
            <span class="s1">self.pattern = </span><span class="s2">r'%s(?:[^%s\n\r%s]' </span><span class="s1">% (re.escape(self.quoteChar)</span><span class="s3">,</span>
                                                  <span class="s1">_escapeRegexRangeChars(self.endQuoteChar[</span><span class="s4">0</span><span class="s1">])</span><span class="s3">,</span>
                                                  <span class="s1">(escChar </span><span class="s3">is not None and </span><span class="s1">_escapeRegexRangeChars(escChar) </span><span class="s3">or </span><span class="s2">''</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">len(self.endQuoteChar) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">self.pattern += (</span>
                <span class="s2">'|(?:' </span><span class="s1">+ </span><span class="s2">')|(?:'</span><span class="s1">.join(</span><span class="s2">&quot;%s[^%s]&quot; </span><span class="s1">% (re.escape(self.endQuoteChar[:i])</span><span class="s3">,</span>
                                                   <span class="s1">_escapeRegexRangeChars(self.endQuoteChar[i]))</span>
                                      <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(self.endQuoteChar) - </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)) + </span><span class="s2">')'</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">escQuote:</span>
            <span class="s1">self.pattern += (</span><span class="s2">r'|(?:%s)' </span><span class="s1">% re.escape(escQuote))</span>
        <span class="s3">if </span><span class="s1">escChar:</span>
            <span class="s1">self.pattern += (</span><span class="s2">r'|(?:%s.)' </span><span class="s1">% re.escape(escChar))</span>
            <span class="s1">self.escCharReplacePattern = re.escape(self.escChar) + </span><span class="s2">&quot;(.)&quot;</span>
        <span class="s1">self.pattern += (</span><span class="s2">r')*%s' </span><span class="s1">% re.escape(self.endQuoteChar))</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.re = re.compile(self.pattern</span><span class="s3">, </span><span class="s1">self.flags)</span>
            <span class="s1">self.reString = self.pattern</span>
            <span class="s1">self.re_match = self.re.match</span>
        <span class="s3">except </span><span class="s1">sre_constants.error:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;invalid pattern (%s) passed to Regex&quot; </span><span class="s1">% self.pattern</span><span class="s3">,</span>
                          <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">raise</span>

        <span class="s1">self.name = _ustr(self)</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">False</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">result = instring[loc] == self.firstQuoteChar </span><span class="s3">and </span><span class="s1">self.re_match(instring</span><span class="s3">, </span><span class="s1">loc) </span><span class="s3">or None</span>
        <span class="s3">if not </span><span class="s1">result:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

        <span class="s1">loc = result.end()</span>
        <span class="s1">ret = result.group()</span>

        <span class="s3">if </span><span class="s1">self.unquoteResults:</span>

            <span class="s0"># strip off quotes</span>
            <span class="s1">ret = ret[self.quoteCharLen: -self.endQuoteCharLen]</span>

            <span class="s3">if </span><span class="s1">isinstance(ret</span><span class="s3">, </span><span class="s1">basestring):</span>
                <span class="s0"># replace escaped whitespace</span>
                <span class="s3">if </span><span class="s2">'</span><span class="s3">\\</span><span class="s2">' </span><span class="s3">in </span><span class="s1">ret </span><span class="s3">and </span><span class="s1">self.convertWhitespaceEscapes:</span>
                    <span class="s1">ws_map = {</span>
                        <span class="s2">r'\t'</span><span class="s1">: </span><span class="s2">'</span><span class="s3">\t</span><span class="s2">'</span><span class="s3">,</span>
                        <span class="s2">r'\n'</span><span class="s1">: </span><span class="s2">'</span><span class="s3">\n</span><span class="s2">'</span><span class="s3">,</span>
                        <span class="s2">r'\f'</span><span class="s1">: </span><span class="s2">'</span><span class="s3">\f</span><span class="s2">'</span><span class="s3">,</span>
                        <span class="s2">r'\r'</span><span class="s1">: </span><span class="s2">'</span><span class="s3">\r</span><span class="s2">'</span><span class="s3">,</span>
                    <span class="s1">}</span>
                    <span class="s3">for </span><span class="s1">wslit</span><span class="s3">, </span><span class="s1">wschar </span><span class="s3">in </span><span class="s1">ws_map.items():</span>
                        <span class="s1">ret = ret.replace(wslit</span><span class="s3">, </span><span class="s1">wschar)</span>

                <span class="s0"># replace escaped characters</span>
                <span class="s3">if </span><span class="s1">self.escChar:</span>
                    <span class="s1">ret = re.sub(self.escCharReplacePattern</span><span class="s3">, </span><span class="s2">r&quot;\g&lt;1&gt;&quot;</span><span class="s3">, </span><span class="s1">ret)</span>

                <span class="s0"># replace escaped quotes</span>
                <span class="s3">if </span><span class="s1">self.escQuote:</span>
                    <span class="s1">ret = ret.replace(self.escQuote</span><span class="s3">, </span><span class="s1">self.endQuoteChar)</span>

        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">super(QuotedString</span><span class="s3">, </span><span class="s1">self).__str__()</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s3">pass</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.strRepr = </span><span class="s2">&quot;quoted string, starting with %s ending with %s&quot; </span><span class="s1">% (self.quoteChar</span><span class="s3">, </span><span class="s1">self.endQuoteChar)</span>

        <span class="s3">return </span><span class="s1">self.strRepr</span>


<span class="s3">class </span><span class="s1">CharsNotIn(Token):</span>
    <span class="s5">&quot;&quot;&quot;Token for matching words composed of characters *not* in a given 
    set (will include whitespace in matched characters if not listed in 
    the provided exclusion set - see example). Defined with string 
    containing all disallowed characters, and an optional minimum, 
    maximum, and/or exact length.  The default value for ``min`` is 
    1 (a minimum value &lt; 1 is not valid); the default values for 
    ``max`` and ``exact`` are 0, meaning no maximum or exact 
    length restriction. 
 
    Example:: 
 
        # define a comma-separated-value as anything that is not a ',' 
        csv_value = CharsNotIn(',') 
        print(delimitedList(csv_value).parseString(&quot;dkls,lsdkjf,s12 34,@!#,213&quot;)) 
 
    prints:: 
 
        ['dkls', 'lsdkjf', 's12 34', '@!#', '213'] 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">notChars</span><span class="s3">, </span><span class="s1">min=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">max=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">exact=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">super(CharsNotIn</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.skipWhitespace = </span><span class="s3">False</span>
        <span class="s1">self.notChars = notChars</span>

        <span class="s3">if </span><span class="s1">min &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;cannot specify a minimum length &lt; 1; use &quot;</span>
                             <span class="s2">&quot;Optional(CharsNotIn()) if zero-length char group is permitted&quot;</span><span class="s1">)</span>

        <span class="s1">self.minLen = min</span>

        <span class="s3">if </span><span class="s1">max &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.maxLen = max</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.maxLen = _MAX_INT</span>

        <span class="s3">if </span><span class="s1">exact &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.maxLen = exact</span>
            <span class="s1">self.minLen = exact</span>

        <span class="s1">self.name = _ustr(self)</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected &quot; </span><span class="s1">+ self.name</span>
        <span class="s1">self.mayReturnEmpty = (self.minLen == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">instring[loc] </span><span class="s3">in </span><span class="s1">self.notChars:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

        <span class="s1">start = loc</span>
        <span class="s1">loc += </span><span class="s4">1</span>
        <span class="s1">notchars = self.notChars</span>
        <span class="s1">maxlen = min(start + self.maxLen</span><span class="s3">, </span><span class="s1">len(instring))</span>
        <span class="s3">while </span><span class="s1">loc &lt; maxlen </span><span class="s3">and </span><span class="s1">instring[loc] </span><span class="s3">not in </span><span class="s1">notchars:</span>
            <span class="s1">loc += </span><span class="s4">1</span>

        <span class="s3">if </span><span class="s1">loc - start &lt; self.minLen:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">instring[start:loc]</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">super(CharsNotIn</span><span class="s3">, </span><span class="s1">self).__str__()</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s3">pass</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">len(self.notChars) &gt; </span><span class="s4">4</span><span class="s1">:</span>
                <span class="s1">self.strRepr = </span><span class="s2">&quot;!W:(%s...)&quot; </span><span class="s1">% self.notChars[:</span><span class="s4">4</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.strRepr = </span><span class="s2">&quot;!W:(%s)&quot; </span><span class="s1">% self.notChars</span>

        <span class="s3">return </span><span class="s1">self.strRepr</span>

<span class="s3">class </span><span class="s1">White(Token):</span>
    <span class="s5">&quot;&quot;&quot;Special matching class for matching whitespace.  Normally, 
    whitespace is ignored by pyparsing grammars.  This class is included 
    when some whitespace structures are significant.  Define with 
    a string containing the whitespace characters to be matched; default 
    is ``&quot; \\t\\r\\n&quot;``.  Also takes optional ``min``, 
    ``max``, and ``exact`` arguments, as defined for the 
    :class:`Word` class. 
    &quot;&quot;&quot;</span>
    <span class="s1">whiteStrs = {</span>
        <span class="s2">' ' </span><span class="s1">: </span><span class="s2">'&lt;SP&gt;'</span><span class="s3">,</span>
        <span class="s2">'</span><span class="s3">\t</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;TAB&gt;'</span><span class="s3">,</span>
        <span class="s2">'</span><span class="s3">\n</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;LF&gt;'</span><span class="s3">,</span>
        <span class="s2">'</span><span class="s3">\r</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;CR&gt;'</span><span class="s3">,</span>
        <span class="s2">'</span><span class="s3">\f</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;FF&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u00A0</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;NBSP&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u1680</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;OGHAM_SPACE_MARK&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u180E</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;MONGOLIAN_VOWEL_SEPARATOR&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u2000</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;EN_QUAD&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u2001</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;EM_QUAD&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u2002</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;EN_SPACE&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u2003</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;EM_SPACE&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u2004</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;THREE-PER-EM_SPACE&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u2005</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;FOUR-PER-EM_SPACE&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u2006</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;SIX-PER-EM_SPACE&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u2007</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;FIGURE_SPACE&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u2008</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;PUNCTUATION_SPACE&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u2009</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;THIN_SPACE&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u200A</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;HAIR_SPACE&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u200B</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;ZERO_WIDTH_SPACE&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u202F</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;NNBSP&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u205F</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;MMSP&gt;'</span><span class="s3">,</span>
        <span class="s2">u'</span><span class="s3">\u3000</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'&lt;IDEOGRAPHIC_SPACE&gt;'</span><span class="s3">,</span>
        <span class="s1">}</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">ws=</span><span class="s2">&quot; </span><span class="s3">\t\r\n</span><span class="s2">&quot;</span><span class="s3">, </span><span class="s1">min=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">max=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">exact=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">super(White</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.matchWhite = ws</span>
        <span class="s1">self.setWhitespaceChars(</span><span class="s2">&quot;&quot;</span><span class="s1">.join(c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self.whiteChars </span><span class="s3">if </span><span class="s1">c </span><span class="s3">not in </span><span class="s1">self.matchWhite))</span>
        <span class="s0"># ~ self.leaveWhitespace()</span>
        <span class="s1">self.name = (</span><span class="s2">&quot;&quot;</span><span class="s1">.join(White.whiteStrs[c] </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self.matchWhite))</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected &quot; </span><span class="s1">+ self.name</span>

        <span class="s1">self.minLen = min</span>

        <span class="s3">if </span><span class="s1">max &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.maxLen = max</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.maxLen = _MAX_INT</span>

        <span class="s3">if </span><span class="s1">exact &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.maxLen = exact</span>
            <span class="s1">self.minLen = exact</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">instring[loc] </span><span class="s3">not in </span><span class="s1">self.matchWhite:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s1">start = loc</span>
        <span class="s1">loc += </span><span class="s4">1</span>
        <span class="s1">maxloc = start + self.maxLen</span>
        <span class="s1">maxloc = min(maxloc</span><span class="s3">, </span><span class="s1">len(instring))</span>
        <span class="s3">while </span><span class="s1">loc &lt; maxloc </span><span class="s3">and </span><span class="s1">instring[loc] </span><span class="s3">in </span><span class="s1">self.matchWhite:</span>
            <span class="s1">loc += </span><span class="s4">1</span>

        <span class="s3">if </span><span class="s1">loc - start &lt; self.minLen:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">instring[start:loc]</span>


<span class="s3">class </span><span class="s1">_PositionToken(Token):</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super(_PositionToken</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.name = self.__class__.__name__</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">False</span>

<span class="s3">class </span><span class="s1">GoToColumn(_PositionToken):</span>
    <span class="s5">&quot;&quot;&quot;Token to advance to a specific column of input text; useful for 
    tabular report scraping. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">colno):</span>
        <span class="s1">super(GoToColumn</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.col = colno</span>

    <span class="s3">def </span><span class="s1">preParse(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc):</span>
        <span class="s3">if </span><span class="s1">col(loc</span><span class="s3">, </span><span class="s1">instring) != self.col:</span>
            <span class="s1">instrlen = len(instring)</span>
            <span class="s3">if </span><span class="s1">self.ignoreExprs:</span>
                <span class="s1">loc = self._skipIgnorables(instring</span><span class="s3">, </span><span class="s1">loc)</span>
            <span class="s3">while </span><span class="s1">loc &lt; instrlen </span><span class="s3">and </span><span class="s1">instring[loc].isspace() </span><span class="s3">and </span><span class="s1">col(loc</span><span class="s3">, </span><span class="s1">instring) != self.col:</span>
                <span class="s1">loc += </span><span class="s4">1</span>
        <span class="s3">return </span><span class="s1">loc</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">thiscol = col(loc</span><span class="s3">, </span><span class="s1">instring)</span>
        <span class="s3">if </span><span class="s1">thiscol &gt; self.col:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s2">&quot;Text not in expected column&quot;</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s1">newloc = loc + self.col - thiscol</span>
        <span class="s1">ret = instring[loc: newloc]</span>
        <span class="s3">return </span><span class="s1">newloc</span><span class="s3">, </span><span class="s1">ret</span>


<span class="s3">class </span><span class="s1">LineStart(_PositionToken):</span>
    <span class="s5">r&quot;&quot;&quot;Matches if current position is at the beginning of a line within 
    the parse string 
 
    Example:: 
 
        test = '''\ 
        AAA this line 
        AAA and this line 
          AAA but not this one 
        B AAA and definitely not this one 
        ''' 
 
        for t in (LineStart() + 'AAA' + restOfLine).searchString(test): 
            print(t) 
 
    prints:: 
 
        ['AAA', ' this line'] 
        ['AAA', ' and this line'] 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super(LineStart</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected start of line&quot;</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">col(loc</span><span class="s3">, </span><span class="s1">instring) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">[]</span>
        <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

<span class="s3">class </span><span class="s1">LineEnd(_PositionToken):</span>
    <span class="s5">&quot;&quot;&quot;Matches if current position is at the end of a line within the 
    parse string 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super(LineEnd</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.setWhitespaceChars(ParserElement.DEFAULT_WHITE_CHARS.replace(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s3">, </span><span class="s2">&quot;&quot;</span><span class="s1">))</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected end of line&quot;</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">loc &lt; len(instring):</span>
            <span class="s3">if </span><span class="s1">instring[loc] == </span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">loc + </span><span class="s4">1</span><span class="s3">, </span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s3">elif </span><span class="s1">loc == len(instring):</span>
            <span class="s3">return </span><span class="s1">loc + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">[]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

<span class="s3">class </span><span class="s1">StringStart(_PositionToken):</span>
    <span class="s5">&quot;&quot;&quot;Matches if current position is at the beginning of the parse 
    string 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super(StringStart</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected start of text&quot;</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">loc != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># see if entire string up to here is just whitespace and ignoreables</span>
            <span class="s3">if </span><span class="s1">loc != self.preParse(instring</span><span class="s3">, </span><span class="s4">0</span><span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">[]</span>

<span class="s3">class </span><span class="s1">StringEnd(_PositionToken):</span>
    <span class="s5">&quot;&quot;&quot;Matches if current position is at the end of the parse string 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super(StringEnd</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected end of text&quot;</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">loc &lt; len(instring):</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s3">elif </span><span class="s1">loc == len(instring):</span>
            <span class="s3">return </span><span class="s1">loc + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">[]</span>
        <span class="s3">elif </span><span class="s1">loc &gt; len(instring):</span>
            <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">[]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

<span class="s3">class </span><span class="s1">WordStart(_PositionToken):</span>
    <span class="s5">&quot;&quot;&quot;Matches if the current position is at the beginning of a Word, 
    and is not preceded by any character in a given set of 
    ``wordChars`` (default= ``printables``). To emulate the 
    ``\b`` behavior of regular expressions, use 
    ``WordStart(alphanums)``. ``WordStart`` will also match at 
    the beginning of the string being parsed, or at the beginning of 
    a line. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">wordChars=printables):</span>
        <span class="s1">super(WordStart</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.wordChars = set(wordChars)</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Not at the start of a word&quot;</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">loc != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(instring[loc - </span><span class="s4">1</span><span class="s1">] </span><span class="s3">in </span><span class="s1">self.wordChars</span>
                    <span class="s3">or </span><span class="s1">instring[loc] </span><span class="s3">not in </span><span class="s1">self.wordChars):</span>
                <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">[]</span>

<span class="s3">class </span><span class="s1">WordEnd(_PositionToken):</span>
    <span class="s5">&quot;&quot;&quot;Matches if the current position is at the end of a Word, and is 
    not followed by any character in a given set of ``wordChars`` 
    (default= ``printables``). To emulate the ``\b`` behavior of 
    regular expressions, use ``WordEnd(alphanums)``. ``WordEnd`` 
    will also match at the end of the string being parsed, or at the end 
    of a line. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">wordChars=printables):</span>
        <span class="s1">super(WordEnd</span><span class="s3">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self.wordChars = set(wordChars)</span>
        <span class="s1">self.skipWhitespace = </span><span class="s3">False</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Not at the end of a word&quot;</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">instrlen = len(instring)</span>
        <span class="s3">if </span><span class="s1">instrlen &gt; </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">loc &lt; instrlen:</span>
            <span class="s3">if </span><span class="s1">(instring[loc] </span><span class="s3">in </span><span class="s1">self.wordChars </span><span class="s3">or</span>
                    <span class="s1">instring[loc - </span><span class="s4">1</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">self.wordChars):</span>
                <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">[]</span>


<span class="s3">class </span><span class="s1">ParseExpression(ParserElement):</span>
    <span class="s5">&quot;&quot;&quot;Abstract subclass of ParserElement, for combining and 
    post-processing parsed tokens. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">exprs</span><span class="s3">, </span><span class="s1">savelist=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">super(ParseExpression</span><span class="s3">, </span><span class="s1">self).__init__(savelist)</span>
        <span class="s3">if </span><span class="s1">isinstance(exprs</span><span class="s3">, </span><span class="s1">_generatorType):</span>
            <span class="s1">exprs = list(exprs)</span>

        <span class="s3">if </span><span class="s1">isinstance(exprs</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">self.exprs = [self._literalStringClass(exprs)]</span>
        <span class="s3">elif </span><span class="s1">isinstance(exprs</span><span class="s3">, </span><span class="s1">ParserElement):</span>
            <span class="s1">self.exprs = [exprs]</span>
        <span class="s3">elif </span><span class="s1">isinstance(exprs</span><span class="s3">, </span><span class="s1">Iterable):</span>
            <span class="s1">exprs = list(exprs)</span>
            <span class="s0"># if sequence of strings provided, wrap with Literal</span>
            <span class="s3">if </span><span class="s1">any(isinstance(expr</span><span class="s3">, </span><span class="s1">basestring) </span><span class="s3">for </span><span class="s1">expr </span><span class="s3">in </span><span class="s1">exprs):</span>
                <span class="s1">exprs = (self._literalStringClass(e) </span><span class="s3">if </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">basestring) </span><span class="s3">else </span><span class="s1">e </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">exprs)</span>
            <span class="s1">self.exprs = list(exprs)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.exprs = list(exprs)</span>
            <span class="s3">except </span><span class="s1">TypeError:</span>
                <span class="s1">self.exprs = [exprs]</span>
        <span class="s1">self.callPreparse = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">append(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">self.exprs.append(other)</span>
        <span class="s1">self.strRepr = </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">leaveWhitespace(self):</span>
        <span class="s5">&quot;&quot;&quot;Extends ``leaveWhitespace`` defined in base class, and also invokes ``leaveWhitespace`` on 
           all contained expressions.&quot;&quot;&quot;</span>
        <span class="s1">self.skipWhitespace = </span><span class="s3">False</span>
        <span class="s1">self.exprs = [e.copy() </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs]</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs:</span>
            <span class="s1">e.leaveWhitespace()</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">ignore(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Suppress):</span>
            <span class="s3">if </span><span class="s1">other </span><span class="s3">not in </span><span class="s1">self.ignoreExprs:</span>
                <span class="s1">super(ParseExpression</span><span class="s3">, </span><span class="s1">self).ignore(other)</span>
                <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs:</span>
                    <span class="s1">e.ignore(self.ignoreExprs[-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">super(ParseExpression</span><span class="s3">, </span><span class="s1">self).ignore(other)</span>
            <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs:</span>
                <span class="s1">e.ignore(self.ignoreExprs[-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">super(ParseExpression</span><span class="s3">, </span><span class="s1">self).__str__()</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s3">pass</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.strRepr = </span><span class="s2">&quot;%s:(%s)&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">_ustr(self.exprs))</span>
        <span class="s3">return </span><span class="s1">self.strRepr</span>

    <span class="s3">def </span><span class="s1">streamline(self):</span>
        <span class="s1">super(ParseExpression</span><span class="s3">, </span><span class="s1">self).streamline()</span>

        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs:</span>
            <span class="s1">e.streamline()</span>

        <span class="s0"># collapse nested And's of the form And(And(And(a, b), c), d) to And(a, b, c, d)</span>
        <span class="s0"># but only if there are no parse actions or resultsNames on the nested And's</span>
        <span class="s0"># (likewise for Or's and MatchFirst's)</span>
        <span class="s3">if </span><span class="s1">len(self.exprs) == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">other = self.exprs[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">(isinstance(other</span><span class="s3">, </span><span class="s1">self.__class__)</span>
                    <span class="s3">and not </span><span class="s1">other.parseAction</span>
                    <span class="s3">and </span><span class="s1">other.resultsName </span><span class="s3">is None</span>
                    <span class="s3">and not </span><span class="s1">other.debug):</span>
                <span class="s1">self.exprs = other.exprs[:] + [self.exprs[</span><span class="s4">1</span><span class="s1">]]</span>
                <span class="s1">self.strRepr = </span><span class="s3">None</span>
                <span class="s1">self.mayReturnEmpty |= other.mayReturnEmpty</span>
                <span class="s1">self.mayIndexError  |= other.mayIndexError</span>

            <span class="s1">other = self.exprs[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">(isinstance(other</span><span class="s3">, </span><span class="s1">self.__class__)</span>
                    <span class="s3">and not </span><span class="s1">other.parseAction</span>
                    <span class="s3">and </span><span class="s1">other.resultsName </span><span class="s3">is None</span>
                    <span class="s3">and not </span><span class="s1">other.debug):</span>
                <span class="s1">self.exprs = self.exprs[:-</span><span class="s4">1</span><span class="s1">] + other.exprs[:]</span>
                <span class="s1">self.strRepr = </span><span class="s3">None</span>
                <span class="s1">self.mayReturnEmpty |= other.mayReturnEmpty</span>
                <span class="s1">self.mayIndexError  |= other.mayIndexError</span>

        <span class="s1">self.errmsg = </span><span class="s2">&quot;Expected &quot; </span><span class="s1">+ _ustr(self)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">validate(self</span><span class="s3">, </span><span class="s1">validateTrace=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">tmp = (validateTrace </span><span class="s3">if </span><span class="s1">validateTrace </span><span class="s3">is not None else </span><span class="s1">[])[:] + [self]</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs:</span>
            <span class="s1">e.validate(tmp)</span>
        <span class="s1">self.checkRecursion([])</span>

    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s1">ret = super(ParseExpression</span><span class="s3">, </span><span class="s1">self).copy()</span>
        <span class="s1">ret.exprs = [e.copy() </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs]</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">_setResultsName(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">listAllMatches=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">__diag__.warn_ungrouped_named_tokens_in_collection:</span>
            <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs:</span>
                <span class="s3">if </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">ParserElement) </span><span class="s3">and </span><span class="s1">e.resultsName:</span>
                    <span class="s1">warnings.warn(</span><span class="s2">&quot;{0}: setting results name {1!r} on {2} expression &quot;</span>
                                  <span class="s2">&quot;collides with {3!r} on contained expression&quot;</span><span class="s1">.format(</span><span class="s2">&quot;warn_ungrouped_named_tokens_in_collection&quot;</span><span class="s3">,</span>
                                                                                       <span class="s1">name</span><span class="s3">,</span>
                                                                                       <span class="s1">type(self).__name__</span><span class="s3">,</span>
                                                                                       <span class="s1">e.resultsName)</span><span class="s3">,</span>
                                  <span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">super(ParseExpression</span><span class="s3">, </span><span class="s1">self)._setResultsName(name</span><span class="s3">, </span><span class="s1">listAllMatches)</span>


<span class="s3">class </span><span class="s1">And(ParseExpression):</span>
    <span class="s5">&quot;&quot;&quot; 
    Requires all given :class:`ParseExpression` s to be found in the given order. 
    Expressions may be separated by whitespace. 
    May be constructed using the ``'+'`` operator. 
    May also be constructed using the ``'-'`` operator, which will 
    suppress backtracking. 
 
    Example:: 
 
        integer = Word(nums) 
        name_expr = OneOrMore(Word(alphas)) 
 
        expr = And([integer(&quot;id&quot;), name_expr(&quot;name&quot;), integer(&quot;age&quot;)]) 
        # more easily written as: 
        expr = integer(&quot;id&quot;) + name_expr(&quot;name&quot;) + integer(&quot;age&quot;) 
    &quot;&quot;&quot;</span>

    <span class="s3">class </span><span class="s1">_ErrorStop(Empty):</span>
        <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
            <span class="s1">super(And._ErrorStop</span><span class="s3">, </span><span class="s1">self).__init__(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
            <span class="s1">self.name = </span><span class="s2">'-'</span>
            <span class="s1">self.leaveWhitespace()</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">exprs</span><span class="s3">, </span><span class="s1">savelist=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">exprs = list(exprs)</span>
        <span class="s3">if </span><span class="s1">exprs </span><span class="s3">and </span><span class="s1">Ellipsis </span><span class="s3">in </span><span class="s1">exprs:</span>
            <span class="s1">tmp = []</span>
            <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">expr </span><span class="s3">in </span><span class="s1">enumerate(exprs):</span>
                <span class="s3">if </span><span class="s1">expr </span><span class="s3">is </span><span class="s1">Ellipsis:</span>
                    <span class="s3">if </span><span class="s1">i &lt; len(exprs) - </span><span class="s4">1</span><span class="s1">:</span>
                        <span class="s1">skipto_arg = (Empty() + exprs[i + </span><span class="s4">1</span><span class="s1">]).exprs[-</span><span class="s4">1</span><span class="s1">]</span>
                        <span class="s1">tmp.append(SkipTo(skipto_arg)(</span><span class="s2">&quot;_skipped*&quot;</span><span class="s1">))</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;cannot construct And with sequence ending in ...&quot;</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">tmp.append(expr)</span>
            <span class="s1">exprs[:] = tmp</span>
        <span class="s1">super(And</span><span class="s3">, </span><span class="s1">self).__init__(exprs</span><span class="s3">, </span><span class="s1">savelist)</span>
        <span class="s1">self.mayReturnEmpty = all(e.mayReturnEmpty </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs)</span>
        <span class="s1">self.setWhitespaceChars(self.exprs[</span><span class="s4">0</span><span class="s1">].whiteChars)</span>
        <span class="s1">self.skipWhitespace = self.exprs[</span><span class="s4">0</span><span class="s1">].skipWhitespace</span>
        <span class="s1">self.callPreparse = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">streamline(self):</span>
        <span class="s0"># collapse any _PendingSkip's</span>
        <span class="s3">if </span><span class="s1">self.exprs:</span>
            <span class="s3">if </span><span class="s1">any(isinstance(e</span><span class="s3">, </span><span class="s1">ParseExpression) </span><span class="s3">and </span><span class="s1">e.exprs </span><span class="s3">and </span><span class="s1">isinstance(e.exprs[-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">_PendingSkip)</span>
                   <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs[:-</span><span class="s4">1</span><span class="s1">]):</span>
                <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">e </span><span class="s3">in </span><span class="s1">enumerate(self.exprs[:-</span><span class="s4">1</span><span class="s1">]):</span>
                    <span class="s3">if </span><span class="s1">e </span><span class="s3">is None</span><span class="s1">:</span>
                        <span class="s3">continue</span>
                    <span class="s3">if </span><span class="s1">(isinstance(e</span><span class="s3">, </span><span class="s1">ParseExpression)</span>
                            <span class="s3">and </span><span class="s1">e.exprs </span><span class="s3">and </span><span class="s1">isinstance(e.exprs[-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">_PendingSkip)):</span>
                        <span class="s1">e.exprs[-</span><span class="s4">1</span><span class="s1">] = e.exprs[-</span><span class="s4">1</span><span class="s1">] + self.exprs[i + </span><span class="s4">1</span><span class="s1">]</span>
                        <span class="s1">self.exprs[i + </span><span class="s4">1</span><span class="s1">] = </span><span class="s3">None</span>
                <span class="s1">self.exprs = [e </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs </span><span class="s3">if </span><span class="s1">e </span><span class="s3">is not None</span><span class="s1">]</span>

        <span class="s1">super(And</span><span class="s3">, </span><span class="s1">self).streamline()</span>
        <span class="s1">self.mayReturnEmpty = all(e.mayReturnEmpty </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0"># pass False as last arg to _parse for first element, since we already</span>
        <span class="s0"># pre-parsed the string as part of our And pre-parsing</span>
        <span class="s1">loc</span><span class="s3">, </span><span class="s1">resultlist = self.exprs[</span><span class="s4">0</span><span class="s1">]._parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions</span><span class="s3">, </span><span class="s1">callPreParse=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">errorStop = </span><span class="s3">False</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs[</span><span class="s4">1</span><span class="s1">:]:</span>
            <span class="s3">if </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">And._ErrorStop):</span>
                <span class="s1">errorStop = </span><span class="s3">True</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">errorStop:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">loc</span><span class="s3">, </span><span class="s1">exprtokens = e._parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions)</span>
                <span class="s3">except </span><span class="s1">ParseSyntaxException:</span>
                    <span class="s3">raise</span>
                <span class="s3">except </span><span class="s1">ParseBaseException </span><span class="s3">as </span><span class="s1">pe:</span>
                    <span class="s1">pe.__traceback__ = </span><span class="s3">None</span>
                    <span class="s3">raise </span><span class="s1">ParseSyntaxException._from_exception(pe)</span>
                <span class="s3">except </span><span class="s1">IndexError:</span>
                    <span class="s3">raise </span><span class="s1">ParseSyntaxException(instring</span><span class="s3">, </span><span class="s1">len(instring)</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">loc</span><span class="s3">, </span><span class="s1">exprtokens = e._parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions)</span>
            <span class="s3">if </span><span class="s1">exprtokens </span><span class="s3">or </span><span class="s1">exprtokens.haskeys():</span>
                <span class="s1">resultlist += exprtokens</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">resultlist</span>

    <span class="s3">def </span><span class="s1">__iadd__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">return </span><span class="s1">self.append(other)  </span><span class="s0"># And([self, other])</span>

    <span class="s3">def </span><span class="s1">checkRecursion(self</span><span class="s3">, </span><span class="s1">parseElementList):</span>
        <span class="s1">subRecCheckList = parseElementList[:] + [self]</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs:</span>
            <span class="s1">e.checkRecursion(subRecCheckList)</span>
            <span class="s3">if not </span><span class="s1">e.mayReturnEmpty:</span>
                <span class="s3">break</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.name</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.strRepr = </span><span class="s2">&quot;{&quot; </span><span class="s1">+ </span><span class="s2">&quot; &quot;</span><span class="s1">.join(_ustr(e) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs) + </span><span class="s2">&quot;}&quot;</span>

        <span class="s3">return </span><span class="s1">self.strRepr</span>


<span class="s3">class </span><span class="s1">Or(ParseExpression):</span>
    <span class="s5">&quot;&quot;&quot;Requires that at least one :class:`ParseExpression` is found. If 
    two expressions match, the expression that matches the longest 
    string will be used. May be constructed using the ``'^'`` 
    operator. 
 
    Example:: 
 
        # construct Or using '^' operator 
 
        number = Word(nums) ^ Combine(Word(nums) + '.' + Word(nums)) 
        print(number.searchString(&quot;123 3.1416 789&quot;)) 
 
    prints:: 
 
        [['123'], ['3.1416'], ['789']] 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">exprs</span><span class="s3">, </span><span class="s1">savelist=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">super(Or</span><span class="s3">, </span><span class="s1">self).__init__(exprs</span><span class="s3">, </span><span class="s1">savelist)</span>
        <span class="s3">if </span><span class="s1">self.exprs:</span>
            <span class="s1">self.mayReturnEmpty = any(e.mayReturnEmpty </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">streamline(self):</span>
        <span class="s1">super(Or</span><span class="s3">, </span><span class="s1">self).streamline()</span>
        <span class="s3">if </span><span class="s1">__compat__.collect_all_And_tokens:</span>
            <span class="s1">self.saveAsList = any(e.saveAsList </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">maxExcLoc = -</span><span class="s4">1</span>
        <span class="s1">maxException = </span><span class="s3">None</span>
        <span class="s1">matches = []</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">loc2 = e.tryParse(instring</span><span class="s3">, </span><span class="s1">loc)</span>
            <span class="s3">except </span><span class="s1">ParseException </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s1">err.__traceback__ = </span><span class="s3">None</span>
                <span class="s3">if </span><span class="s1">err.loc &gt; maxExcLoc:</span>
                    <span class="s1">maxException = err</span>
                    <span class="s1">maxExcLoc = err.loc</span>
            <span class="s3">except </span><span class="s1">IndexError:</span>
                <span class="s3">if </span><span class="s1">len(instring) &gt; maxExcLoc:</span>
                    <span class="s1">maxException = ParseException(instring</span><span class="s3">, </span><span class="s1">len(instring)</span><span class="s3">, </span><span class="s1">e.errmsg</span><span class="s3">, </span><span class="s1">self)</span>
                    <span class="s1">maxExcLoc = len(instring)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># save match among all matches, to retry longest to shortest</span>
                <span class="s1">matches.append((loc2</span><span class="s3">, </span><span class="s1">e))</span>

        <span class="s3">if </span><span class="s1">matches:</span>
            <span class="s0"># re-evaluate all matches in descending order of length of match, in case attached actions</span>
            <span class="s0"># might change whether or how much they match of the input.</span>
            <span class="s1">matches.sort(key=itemgetter(</span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">reverse=</span><span class="s3">True</span><span class="s1">)</span>

            <span class="s3">if not </span><span class="s1">doActions:</span>
                <span class="s0"># no further conditions or parse actions to change the selection of</span>
                <span class="s0"># alternative, so the first match will be the best match</span>
                <span class="s1">best_expr = matches[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s3">return </span><span class="s1">best_expr._parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions)</span>

            <span class="s1">longest = -</span><span class="s4">1</span><span class="s3">, None</span>
            <span class="s3">for </span><span class="s1">loc1</span><span class="s3">, </span><span class="s1">expr1 </span><span class="s3">in </span><span class="s1">matches:</span>
                <span class="s3">if </span><span class="s1">loc1 &lt;= longest[</span><span class="s4">0</span><span class="s1">]:</span>
                    <span class="s0"># already have a longer match than this one will deliver, we are done</span>
                    <span class="s3">return </span><span class="s1">longest</span>

                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">loc2</span><span class="s3">, </span><span class="s1">toks = expr1._parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions)</span>
                <span class="s3">except </span><span class="s1">ParseException </span><span class="s3">as </span><span class="s1">err:</span>
                    <span class="s1">err.__traceback__ = </span><span class="s3">None</span>
                    <span class="s3">if </span><span class="s1">err.loc &gt; maxExcLoc:</span>
                        <span class="s1">maxException = err</span>
                        <span class="s1">maxExcLoc = err.loc</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">loc2 &gt;= loc1:</span>
                        <span class="s3">return </span><span class="s1">loc2</span><span class="s3">, </span><span class="s1">toks</span>
                    <span class="s0"># didn't match as much as before</span>
                    <span class="s3">elif </span><span class="s1">loc2 &gt; longest[</span><span class="s4">0</span><span class="s1">]:</span>
                        <span class="s1">longest = loc2</span><span class="s3">, </span><span class="s1">toks</span>

            <span class="s3">if </span><span class="s1">longest != (-</span><span class="s4">1</span><span class="s3">, None</span><span class="s1">):</span>
                <span class="s3">return </span><span class="s1">longest</span>

        <span class="s3">if </span><span class="s1">maxException </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">maxException.msg = self.errmsg</span>
            <span class="s3">raise </span><span class="s1">maxException</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s2">&quot;no defined alternatives to match&quot;</span><span class="s3">, </span><span class="s1">self)</span>


    <span class="s3">def </span><span class="s1">__ixor__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">return </span><span class="s1">self.append(other)  </span><span class="s0"># Or([self, other])</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.name</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.strRepr = </span><span class="s2">&quot;{&quot; </span><span class="s1">+ </span><span class="s2">&quot; ^ &quot;</span><span class="s1">.join(_ustr(e) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs) + </span><span class="s2">&quot;}&quot;</span>

        <span class="s3">return </span><span class="s1">self.strRepr</span>

    <span class="s3">def </span><span class="s1">checkRecursion(self</span><span class="s3">, </span><span class="s1">parseElementList):</span>
        <span class="s1">subRecCheckList = parseElementList[:] + [self]</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs:</span>
            <span class="s1">e.checkRecursion(subRecCheckList)</span>

    <span class="s3">def </span><span class="s1">_setResultsName(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">listAllMatches=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">__compat__.collect_all_And_tokens</span>
                <span class="s3">and </span><span class="s1">__diag__.warn_multiple_tokens_in_named_alternation):</span>
            <span class="s3">if </span><span class="s1">any(isinstance(e</span><span class="s3">, </span><span class="s1">And) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs):</span>
                <span class="s1">warnings.warn(</span><span class="s2">&quot;{0}: setting results name {1!r} on {2} expression &quot;</span>
                              <span class="s2">&quot;may only return a single token for an And alternative, &quot;</span>
                              <span class="s2">&quot;in future will return the full list of tokens&quot;</span><span class="s1">.format(</span>
                    <span class="s2">&quot;warn_multiple_tokens_in_named_alternation&quot;</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">type(self).__name__)</span><span class="s3">,</span>
                    <span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">super(Or</span><span class="s3">, </span><span class="s1">self)._setResultsName(name</span><span class="s3">, </span><span class="s1">listAllMatches)</span>


<span class="s3">class </span><span class="s1">MatchFirst(ParseExpression):</span>
    <span class="s5">&quot;&quot;&quot;Requires that at least one :class:`ParseExpression` is found. If 
    two expressions match, the first one listed is the one that will 
    match. May be constructed using the ``'|'`` operator. 
 
    Example:: 
 
        # construct MatchFirst using '|' operator 
 
        # watch the order of expressions to match 
        number = Word(nums) | Combine(Word(nums) + '.' + Word(nums)) 
        print(number.searchString(&quot;123 3.1416 789&quot;)) #  Fail! -&gt; [['123'], ['3'], ['1416'], ['789']] 
 
        # put more selective expression first 
        number = Combine(Word(nums) + '.' + Word(nums)) | Word(nums) 
        print(number.searchString(&quot;123 3.1416 789&quot;)) #  Better -&gt; [['123'], ['3.1416'], ['789']] 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">exprs</span><span class="s3">, </span><span class="s1">savelist=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">super(MatchFirst</span><span class="s3">, </span><span class="s1">self).__init__(exprs</span><span class="s3">, </span><span class="s1">savelist)</span>
        <span class="s3">if </span><span class="s1">self.exprs:</span>
            <span class="s1">self.mayReturnEmpty = any(e.mayReturnEmpty </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">streamline(self):</span>
        <span class="s1">super(MatchFirst</span><span class="s3">, </span><span class="s1">self).streamline()</span>
        <span class="s3">if </span><span class="s1">__compat__.collect_all_And_tokens:</span>
            <span class="s1">self.saveAsList = any(e.saveAsList </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">maxExcLoc = -</span><span class="s4">1</span>
        <span class="s1">maxException = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">ret = e._parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions)</span>
                <span class="s3">return </span><span class="s1">ret</span>
            <span class="s3">except </span><span class="s1">ParseException </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s3">if </span><span class="s1">err.loc &gt; maxExcLoc:</span>
                    <span class="s1">maxException = err</span>
                    <span class="s1">maxExcLoc = err.loc</span>
            <span class="s3">except </span><span class="s1">IndexError:</span>
                <span class="s3">if </span><span class="s1">len(instring) &gt; maxExcLoc:</span>
                    <span class="s1">maxException = ParseException(instring</span><span class="s3">, </span><span class="s1">len(instring)</span><span class="s3">, </span><span class="s1">e.errmsg</span><span class="s3">, </span><span class="s1">self)</span>
                    <span class="s1">maxExcLoc = len(instring)</span>

        <span class="s0"># only got here if no expression matched, raise exception for match that made it the furthest</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">maxException </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">maxException.msg = self.errmsg</span>
                <span class="s3">raise </span><span class="s1">maxException</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s2">&quot;no defined alternatives to match&quot;</span><span class="s3">, </span><span class="s1">self)</span>

    <span class="s3">def </span><span class="s1">__ior__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s3">return </span><span class="s1">self.append(other)  </span><span class="s0"># MatchFirst([self, other])</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.name</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.strRepr = </span><span class="s2">&quot;{&quot; </span><span class="s1">+ </span><span class="s2">&quot; | &quot;</span><span class="s1">.join(_ustr(e) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs) + </span><span class="s2">&quot;}&quot;</span>

        <span class="s3">return </span><span class="s1">self.strRepr</span>

    <span class="s3">def </span><span class="s1">checkRecursion(self</span><span class="s3">, </span><span class="s1">parseElementList):</span>
        <span class="s1">subRecCheckList = parseElementList[:] + [self]</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs:</span>
            <span class="s1">e.checkRecursion(subRecCheckList)</span>

    <span class="s3">def </span><span class="s1">_setResultsName(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">listAllMatches=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">__compat__.collect_all_And_tokens</span>
                <span class="s3">and </span><span class="s1">__diag__.warn_multiple_tokens_in_named_alternation):</span>
            <span class="s3">if </span><span class="s1">any(isinstance(e</span><span class="s3">, </span><span class="s1">And) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs):</span>
                <span class="s1">warnings.warn(</span><span class="s2">&quot;{0}: setting results name {1!r} on {2} expression &quot;</span>
                              <span class="s2">&quot;may only return a single token for an And alternative, &quot;</span>
                              <span class="s2">&quot;in future will return the full list of tokens&quot;</span><span class="s1">.format(</span>
                    <span class="s2">&quot;warn_multiple_tokens_in_named_alternation&quot;</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">type(self).__name__)</span><span class="s3">,</span>
                    <span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">super(MatchFirst</span><span class="s3">, </span><span class="s1">self)._setResultsName(name</span><span class="s3">, </span><span class="s1">listAllMatches)</span>


<span class="s3">class </span><span class="s1">Each(ParseExpression):</span>
    <span class="s5">&quot;&quot;&quot;Requires all given :class:`ParseExpression` s to be found, but in 
    any order. Expressions may be separated by whitespace. 
 
    May be constructed using the ``'&amp;'`` operator. 
 
    Example:: 
 
        color = oneOf(&quot;RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN&quot;) 
        shape_type = oneOf(&quot;SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON&quot;) 
        integer = Word(nums) 
        shape_attr = &quot;shape:&quot; + shape_type(&quot;shape&quot;) 
        posn_attr = &quot;posn:&quot; + Group(integer(&quot;x&quot;) + ',' + integer(&quot;y&quot;))(&quot;posn&quot;) 
        color_attr = &quot;color:&quot; + color(&quot;color&quot;) 
        size_attr = &quot;size:&quot; + integer(&quot;size&quot;) 
 
        # use Each (using operator '&amp;') to accept attributes in any order 
        # (shape and posn are required, color and size are optional) 
        shape_spec = shape_attr &amp; posn_attr &amp; Optional(color_attr) &amp; Optional(size_attr) 
 
        shape_spec.runTests(''' 
            shape: SQUARE color: BLACK posn: 100, 120 
            shape: CIRCLE size: 50 color: BLUE posn: 50,80 
            color:GREEN size:20 shape:TRIANGLE posn:20,40 
            ''' 
            ) 
 
    prints:: 
 
        shape: SQUARE color: BLACK posn: 100, 120 
        ['shape:', 'SQUARE', 'color:', 'BLACK', 'posn:', ['100', ',', '120']] 
        - color: BLACK 
        - posn: ['100', ',', '120'] 
          - x: 100 
          - y: 120 
        - shape: SQUARE 
 
 
        shape: CIRCLE size: 50 color: BLUE posn: 50,80 
        ['shape:', 'CIRCLE', 'size:', '50', 'color:', 'BLUE', 'posn:', ['50', ',', '80']] 
        - color: BLUE 
        - posn: ['50', ',', '80'] 
          - x: 50 
          - y: 80 
        - shape: CIRCLE 
        - size: 50 
 
 
        color: GREEN size: 20 shape: TRIANGLE posn: 20,40 
        ['color:', 'GREEN', 'size:', '20', 'shape:', 'TRIANGLE', 'posn:', ['20', ',', '40']] 
        - color: GREEN 
        - posn: ['20', ',', '40'] 
          - x: 20 
          - y: 40 
        - shape: TRIANGLE 
        - size: 20 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">exprs</span><span class="s3">, </span><span class="s1">savelist=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">super(Each</span><span class="s3">, </span><span class="s1">self).__init__(exprs</span><span class="s3">, </span><span class="s1">savelist)</span>
        <span class="s1">self.mayReturnEmpty = all(e.mayReturnEmpty </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs)</span>
        <span class="s1">self.skipWhitespace = </span><span class="s3">True</span>
        <span class="s1">self.initExprGroups = </span><span class="s3">True</span>
        <span class="s1">self.saveAsList = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">streamline(self):</span>
        <span class="s1">super(Each</span><span class="s3">, </span><span class="s1">self).streamline()</span>
        <span class="s1">self.mayReturnEmpty = all(e.mayReturnEmpty </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">self.initExprGroups:</span>
            <span class="s1">self.opt1map = dict((id(e.expr)</span><span class="s3">, </span><span class="s1">e) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs </span><span class="s3">if </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">Optional))</span>
            <span class="s1">opt1 = [e.expr </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs </span><span class="s3">if </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">Optional)]</span>
            <span class="s1">opt2 = [e </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs </span><span class="s3">if </span><span class="s1">e.mayReturnEmpty </span><span class="s3">and not </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">(Optional</span><span class="s3">, </span><span class="s1">Regex))]</span>
            <span class="s1">self.optionals = opt1 + opt2</span>
            <span class="s1">self.multioptionals = [e.expr </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs </span><span class="s3">if </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">ZeroOrMore)]</span>
            <span class="s1">self.multirequired = [e.expr </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs </span><span class="s3">if </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">OneOrMore)]</span>
            <span class="s1">self.required = [e </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs </span><span class="s3">if not </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">(Optional</span><span class="s3">, </span><span class="s1">ZeroOrMore</span><span class="s3">, </span><span class="s1">OneOrMore))]</span>
            <span class="s1">self.required += self.multirequired</span>
            <span class="s1">self.initExprGroups = </span><span class="s3">False</span>
        <span class="s1">tmpLoc = loc</span>
        <span class="s1">tmpReqd = self.required[:]</span>
        <span class="s1">tmpOpt  = self.optionals[:]</span>
        <span class="s1">matchOrder = []</span>

        <span class="s1">keepMatching = </span><span class="s3">True</span>
        <span class="s3">while </span><span class="s1">keepMatching:</span>
            <span class="s1">tmpExprs = tmpReqd + tmpOpt + self.multioptionals + self.multirequired</span>
            <span class="s1">failed = []</span>
            <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">tmpExprs:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">tmpLoc = e.tryParse(instring</span><span class="s3">, </span><span class="s1">tmpLoc)</span>
                <span class="s3">except </span><span class="s1">ParseException:</span>
                    <span class="s1">failed.append(e)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">matchOrder.append(self.opt1map.get(id(e)</span><span class="s3">, </span><span class="s1">e))</span>
                    <span class="s3">if </span><span class="s1">e </span><span class="s3">in </span><span class="s1">tmpReqd:</span>
                        <span class="s1">tmpReqd.remove(e)</span>
                    <span class="s3">elif </span><span class="s1">e </span><span class="s3">in </span><span class="s1">tmpOpt:</span>
                        <span class="s1">tmpOpt.remove(e)</span>
            <span class="s3">if </span><span class="s1">len(failed) == len(tmpExprs):</span>
                <span class="s1">keepMatching = </span><span class="s3">False</span>

        <span class="s3">if </span><span class="s1">tmpReqd:</span>
            <span class="s1">missing = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(_ustr(e) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">tmpReqd)</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s2">&quot;Missing one or more required elements (%s)&quot; </span><span class="s1">% missing)</span>

        <span class="s0"># add any unmatched Optionals, in case they have default values defined</span>
        <span class="s1">matchOrder += [e </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs </span><span class="s3">if </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">Optional) </span><span class="s3">and </span><span class="s1">e.expr </span><span class="s3">in </span><span class="s1">tmpOpt]</span>

        <span class="s1">resultlist = []</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">matchOrder:</span>
            <span class="s1">loc</span><span class="s3">, </span><span class="s1">results = e._parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions)</span>
            <span class="s1">resultlist.append(results)</span>

        <span class="s1">finalResults = sum(resultlist</span><span class="s3">, </span><span class="s1">ParseResults([]))</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">finalResults</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.name</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.strRepr = </span><span class="s2">&quot;{&quot; </span><span class="s1">+ </span><span class="s2">&quot; &amp; &quot;</span><span class="s1">.join(_ustr(e) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs) + </span><span class="s2">&quot;}&quot;</span>

        <span class="s3">return </span><span class="s1">self.strRepr</span>

    <span class="s3">def </span><span class="s1">checkRecursion(self</span><span class="s3">, </span><span class="s1">parseElementList):</span>
        <span class="s1">subRecCheckList = parseElementList[:] + [self]</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.exprs:</span>
            <span class="s1">e.checkRecursion(subRecCheckList)</span>


<span class="s3">class </span><span class="s1">ParseElementEnhance(ParserElement):</span>
    <span class="s5">&quot;&quot;&quot;Abstract subclass of :class:`ParserElement`, for combining and 
    post-processing parsed tokens. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">savelist=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">super(ParseElementEnhance</span><span class="s3">, </span><span class="s1">self).__init__(savelist)</span>
        <span class="s3">if </span><span class="s1">isinstance(expr</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s3">if </span><span class="s1">issubclass(self._literalStringClass</span><span class="s3">, </span><span class="s1">Token):</span>
                <span class="s1">expr = self._literalStringClass(expr)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">expr = self._literalStringClass(Literal(expr))</span>
        <span class="s1">self.expr = expr</span>
        <span class="s1">self.strRepr = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">expr </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.mayIndexError = expr.mayIndexError</span>
            <span class="s1">self.mayReturnEmpty = expr.mayReturnEmpty</span>
            <span class="s1">self.setWhitespaceChars(expr.whiteChars)</span>
            <span class="s1">self.skipWhitespace = expr.skipWhitespace</span>
            <span class="s1">self.saveAsList = expr.saveAsList</span>
            <span class="s1">self.callPreparse = expr.callPreparse</span>
            <span class="s1">self.ignoreExprs.extend(expr.ignoreExprs)</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">self.expr </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.expr._parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions</span><span class="s3">, </span><span class="s1">callPreParse=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ParseException(</span><span class="s2">&quot;&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

    <span class="s3">def </span><span class="s1">leaveWhitespace(self):</span>
        <span class="s1">self.skipWhitespace = </span><span class="s3">False</span>
        <span class="s1">self.expr = self.expr.copy()</span>
        <span class="s3">if </span><span class="s1">self.expr </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.expr.leaveWhitespace()</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">ignore(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Suppress):</span>
            <span class="s3">if </span><span class="s1">other </span><span class="s3">not in </span><span class="s1">self.ignoreExprs:</span>
                <span class="s1">super(ParseElementEnhance</span><span class="s3">, </span><span class="s1">self).ignore(other)</span>
                <span class="s3">if </span><span class="s1">self.expr </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">self.expr.ignore(self.ignoreExprs[-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">super(ParseElementEnhance</span><span class="s3">, </span><span class="s1">self).ignore(other)</span>
            <span class="s3">if </span><span class="s1">self.expr </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.expr.ignore(self.ignoreExprs[-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">streamline(self):</span>
        <span class="s1">super(ParseElementEnhance</span><span class="s3">, </span><span class="s1">self).streamline()</span>
        <span class="s3">if </span><span class="s1">self.expr </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.expr.streamline()</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">checkRecursion(self</span><span class="s3">, </span><span class="s1">parseElementList):</span>
        <span class="s3">if </span><span class="s1">self </span><span class="s3">in </span><span class="s1">parseElementList:</span>
            <span class="s3">raise </span><span class="s1">RecursiveGrammarException(parseElementList + [self])</span>
        <span class="s1">subRecCheckList = parseElementList[:] + [self]</span>
        <span class="s3">if </span><span class="s1">self.expr </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.expr.checkRecursion(subRecCheckList)</span>

    <span class="s3">def </span><span class="s1">validate(self</span><span class="s3">, </span><span class="s1">validateTrace=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">validateTrace </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">validateTrace = []</span>
        <span class="s1">tmp = validateTrace[:] + [self]</span>
        <span class="s3">if </span><span class="s1">self.expr </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.expr.validate(tmp)</span>
        <span class="s1">self.checkRecursion([])</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">super(ParseElementEnhance</span><span class="s3">, </span><span class="s1">self).__str__()</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s3">pass</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None and </span><span class="s1">self.expr </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.strRepr = </span><span class="s2">&quot;%s:(%s)&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">_ustr(self.expr))</span>
        <span class="s3">return </span><span class="s1">self.strRepr</span>


<span class="s3">class </span><span class="s1">FollowedBy(ParseElementEnhance):</span>
    <span class="s5">&quot;&quot;&quot;Lookahead matching of the given parse expression. 
    ``FollowedBy`` does *not* advance the parsing position within 
    the input string, it only verifies that the specified parse 
    expression matches at the current position.  ``FollowedBy`` 
    always returns a null token list. If any results names are defined 
    in the lookahead expression, those *will* be returned for access by 
    name. 
 
    Example:: 
 
        # use FollowedBy to match a label only if it is followed by a ':' 
        data_word = Word(alphas) 
        label = data_word + FollowedBy(':') 
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join)) 
 
        OneOrMore(attr_expr).parseString(&quot;shape: SQUARE color: BLACK posn: upper left&quot;).pprint() 
 
    prints:: 
 
        [['shape', 'SQUARE'], ['color', 'BLACK'], ['posn', 'upper left']] 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr):</span>
        <span class="s1">super(FollowedBy</span><span class="s3">, </span><span class="s1">self).__init__(expr)</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0"># by using self._expr.parse and deleting the contents of the returned ParseResults list</span>
        <span class="s0"># we keep any named results that were defined in the FollowedBy expression</span>
        <span class="s1">_</span><span class="s3">, </span><span class="s1">ret = self.expr._parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=doActions)</span>
        <span class="s3">del </span><span class="s1">ret[:]</span>

        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">ret</span>


<span class="s3">class </span><span class="s1">PrecededBy(ParseElementEnhance):</span>
    <span class="s5">&quot;&quot;&quot;Lookbehind matching of the given parse expression. 
    ``PrecededBy`` does not advance the parsing position within the 
    input string, it only verifies that the specified parse expression 
    matches prior to the current position.  ``PrecededBy`` always 
    returns a null token list, but if a results name is defined on the 
    given expression, it is returned. 
 
    Parameters: 
 
     - expr - expression that must match prior to the current parse 
       location 
     - retreat - (default= ``None``) - (int) maximum number of characters 
       to lookbehind prior to the current parse location 
 
    If the lookbehind expression is a string, Literal, Keyword, or 
    a Word or CharsNotIn with a specified exact or maximum length, then 
    the retreat parameter is not required. Otherwise, retreat must be 
    specified to give a maximum number of characters to look back from 
    the current parse position for a lookbehind match. 
 
    Example:: 
 
        # VB-style variable names with type prefixes 
        int_var = PrecededBy(&quot;#&quot;) + pyparsing_common.identifier 
        str_var = PrecededBy(&quot;$&quot;) + pyparsing_common.identifier 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">retreat=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super(PrecededBy</span><span class="s3">, </span><span class="s1">self).__init__(expr)</span>
        <span class="s1">self.expr = self.expr().leaveWhitespace()</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">False</span>
        <span class="s1">self.exact = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">isinstance(expr</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">retreat = len(expr)</span>
            <span class="s1">self.exact = </span><span class="s3">True</span>
        <span class="s3">elif </span><span class="s1">isinstance(expr</span><span class="s3">, </span><span class="s1">(Literal</span><span class="s3">, </span><span class="s1">Keyword)):</span>
            <span class="s1">retreat = expr.matchLen</span>
            <span class="s1">self.exact = </span><span class="s3">True</span>
        <span class="s3">elif </span><span class="s1">isinstance(expr</span><span class="s3">, </span><span class="s1">(Word</span><span class="s3">, </span><span class="s1">CharsNotIn)) </span><span class="s3">and </span><span class="s1">expr.maxLen != _MAX_INT:</span>
            <span class="s1">retreat = expr.maxLen</span>
            <span class="s1">self.exact = </span><span class="s3">True</span>
        <span class="s3">elif </span><span class="s1">isinstance(expr</span><span class="s3">, </span><span class="s1">_PositionToken):</span>
            <span class="s1">retreat = </span><span class="s4">0</span>
            <span class="s1">self.exact = </span><span class="s3">True</span>
        <span class="s1">self.retreat = retreat</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;not preceded by &quot; </span><span class="s1">+ str(expr)</span>
        <span class="s1">self.skipWhitespace = </span><span class="s3">False</span>
        <span class="s1">self.parseAction.append(</span><span class="s3">lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t: t.__delitem__(slice(</span><span class="s3">None, None</span><span class="s1">)))</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">self.exact:</span>
            <span class="s3">if </span><span class="s1">loc &lt; self.retreat:</span>
                <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg)</span>
            <span class="s1">start = loc - self.retreat</span>
            <span class="s1">_</span><span class="s3">, </span><span class="s1">ret = self.expr._parse(instring</span><span class="s3">, </span><span class="s1">start)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># retreat specified a maximum lookbehind window, iterate</span>
            <span class="s1">test_expr = self.expr + StringEnd()</span>
            <span class="s1">instring_slice = instring[max(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">loc - self.retreat):loc]</span>
            <span class="s1">last_expr = ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg)</span>
            <span class="s3">for </span><span class="s1">offset </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">min(loc</span><span class="s3">, </span><span class="s1">self.retreat + </span><span class="s4">1</span><span class="s1">)+</span><span class="s4">1</span><span class="s1">):</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s0"># print('trying', offset, instring_slice, repr(instring_slice[loc - offset:]))</span>
                    <span class="s1">_</span><span class="s3">, </span><span class="s1">ret = test_expr._parse(instring_slice</span><span class="s3">, </span><span class="s1">len(instring_slice) - offset)</span>
                <span class="s3">except </span><span class="s1">ParseBaseException </span><span class="s3">as </span><span class="s1">pbe:</span>
                    <span class="s1">last_expr = pbe</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">break</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">last_expr</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">ret</span>


<span class="s3">class </span><span class="s1">NotAny(ParseElementEnhance):</span>
    <span class="s5">&quot;&quot;&quot;Lookahead to disallow matching with the given parse expression. 
    ``NotAny`` does *not* advance the parsing position within the 
    input string, it only verifies that the specified parse expression 
    does *not* match at the current position.  Also, ``NotAny`` does 
    *not* skip over leading whitespace. ``NotAny`` always returns 
    a null token list.  May be constructed using the '~' operator. 
 
    Example:: 
 
        AND, OR, NOT = map(CaselessKeyword, &quot;AND OR NOT&quot;.split()) 
 
        # take care not to mistake keywords for identifiers 
        ident = ~(AND | OR | NOT) + Word(alphas) 
        boolean_term = Optional(NOT) + ident 
 
        # very crude boolean expression - to support parenthesis groups and 
        # operation hierarchy, use infixNotation 
        boolean_expr = boolean_term + ZeroOrMore((AND | OR) + boolean_term) 
 
        # integers that are followed by &quot;.&quot; are actually floats 
        integer = Word(nums) + ~Char(&quot;.&quot;) 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr):</span>
        <span class="s1">super(NotAny</span><span class="s3">, </span><span class="s1">self).__init__(expr)</span>
        <span class="s0"># ~ self.leaveWhitespace()</span>
        <span class="s1">self.skipWhitespace = </span><span class="s3">False  </span><span class="s0"># do NOT use self.leaveWhitespace(), don't want to propagate to exprs</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;Found unwanted token, &quot; </span><span class="s1">+ _ustr(self.expr)</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">self.expr.canParseNext(instring</span><span class="s3">, </span><span class="s1">loc):</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">[]</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.name</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.strRepr = </span><span class="s2">&quot;~{&quot; </span><span class="s1">+ _ustr(self.expr) + </span><span class="s2">&quot;}&quot;</span>

        <span class="s3">return </span><span class="s1">self.strRepr</span>

<span class="s3">class </span><span class="s1">_MultipleMatch(ParseElementEnhance):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">stopOn=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super(_MultipleMatch</span><span class="s3">, </span><span class="s1">self).__init__(expr)</span>
        <span class="s1">self.saveAsList = </span><span class="s3">True</span>
        <span class="s1">ender = stopOn</span>
        <span class="s3">if </span><span class="s1">isinstance(ender</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">ender = self._literalStringClass(ender)</span>
        <span class="s1">self.stopOn(ender)</span>

    <span class="s3">def </span><span class="s1">stopOn(self</span><span class="s3">, </span><span class="s1">ender):</span>
        <span class="s3">if </span><span class="s1">isinstance(ender</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">ender = self._literalStringClass(ender)</span>
        <span class="s1">self.not_ender = ~ender </span><span class="s3">if </span><span class="s1">ender </span><span class="s3">is not None else None</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">self_expr_parse = self.expr._parse</span>
        <span class="s1">self_skip_ignorables = self._skipIgnorables</span>
        <span class="s1">check_ender = self.not_ender </span><span class="s3">is not None</span>
        <span class="s3">if </span><span class="s1">check_ender:</span>
            <span class="s1">try_not_ender = self.not_ender.tryParse</span>

        <span class="s0"># must be at least one (but first see if we are the stopOn sentinel;</span>
        <span class="s0"># if so, fail)</span>
        <span class="s3">if </span><span class="s1">check_ender:</span>
            <span class="s1">try_not_ender(instring</span><span class="s3">, </span><span class="s1">loc)</span>
        <span class="s1">loc</span><span class="s3">, </span><span class="s1">tokens = self_expr_parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions</span><span class="s3">, </span><span class="s1">callPreParse=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">hasIgnoreExprs = (</span><span class="s3">not not </span><span class="s1">self.ignoreExprs)</span>
            <span class="s3">while </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">check_ender:</span>
                    <span class="s1">try_not_ender(instring</span><span class="s3">, </span><span class="s1">loc)</span>
                <span class="s3">if </span><span class="s1">hasIgnoreExprs:</span>
                    <span class="s1">preloc = self_skip_ignorables(instring</span><span class="s3">, </span><span class="s1">loc)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">preloc = loc</span>
                <span class="s1">loc</span><span class="s3">, </span><span class="s1">tmptokens = self_expr_parse(instring</span><span class="s3">, </span><span class="s1">preloc</span><span class="s3">, </span><span class="s1">doActions)</span>
                <span class="s3">if </span><span class="s1">tmptokens </span><span class="s3">or </span><span class="s1">tmptokens.haskeys():</span>
                    <span class="s1">tokens += tmptokens</span>
        <span class="s3">except </span><span class="s1">(ParseException</span><span class="s3">, </span><span class="s1">IndexError):</span>
            <span class="s3">pass</span>

        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">tokens</span>

    <span class="s3">def </span><span class="s1">_setResultsName(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">listAllMatches=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">__diag__.warn_ungrouped_named_tokens_in_collection:</span>
            <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">[self.expr] + getattr(self.expr</span><span class="s3">, </span><span class="s2">'exprs'</span><span class="s3">, </span><span class="s1">[]):</span>
                <span class="s3">if </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">ParserElement) </span><span class="s3">and </span><span class="s1">e.resultsName:</span>
                    <span class="s1">warnings.warn(</span><span class="s2">&quot;{0}: setting results name {1!r} on {2} expression &quot;</span>
                                  <span class="s2">&quot;collides with {3!r} on contained expression&quot;</span><span class="s1">.format(</span><span class="s2">&quot;warn_ungrouped_named_tokens_in_collection&quot;</span><span class="s3">,</span>
                                                                                       <span class="s1">name</span><span class="s3">,</span>
                                                                                       <span class="s1">type(self).__name__</span><span class="s3">,</span>
                                                                                       <span class="s1">e.resultsName)</span><span class="s3">,</span>
                                  <span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">super(_MultipleMatch</span><span class="s3">, </span><span class="s1">self)._setResultsName(name</span><span class="s3">, </span><span class="s1">listAllMatches)</span>


<span class="s3">class </span><span class="s1">OneOrMore(_MultipleMatch):</span>
    <span class="s5">&quot;&quot;&quot;Repetition of one or more of the given expression. 
 
    Parameters: 
     - expr - expression that must match one or more times 
     - stopOn - (default= ``None``) - expression for a terminating sentinel 
          (only required if the sentinel would ordinarily match the repetition 
          expression) 
 
    Example:: 
 
        data_word = Word(alphas) 
        label = data_word + FollowedBy(':') 
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word).setParseAction(' '.join)) 
 
        text = &quot;shape: SQUARE posn: upper left color: BLACK&quot; 
        OneOrMore(attr_expr).parseString(text).pprint()  # Fail! read 'color' as data instead of next label -&gt; [['shape', 'SQUARE color']] 
 
        # use stopOn attribute for OneOrMore to avoid reading label string as part of the data 
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join)) 
        OneOrMore(attr_expr).parseString(text).pprint() # Better -&gt; [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'BLACK']] 
 
        # could also be written as 
        (attr_expr * (1,)).parseString(text).pprint() 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.name</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.strRepr = </span><span class="s2">&quot;{&quot; </span><span class="s1">+ _ustr(self.expr) + </span><span class="s2">&quot;}...&quot;</span>

        <span class="s3">return </span><span class="s1">self.strRepr</span>

<span class="s3">class </span><span class="s1">ZeroOrMore(_MultipleMatch):</span>
    <span class="s5">&quot;&quot;&quot;Optional repetition of zero or more of the given expression. 
 
    Parameters: 
     - expr - expression that must match zero or more times 
     - stopOn - (default= ``None``) - expression for a terminating sentinel 
          (only required if the sentinel would ordinarily match the repetition 
          expression) 
 
    Example: similar to :class:`OneOrMore` 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">stopOn=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super(ZeroOrMore</span><span class="s3">, </span><span class="s1">self).__init__(expr</span><span class="s3">, </span><span class="s1">stopOn=stopOn)</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">super(ZeroOrMore</span><span class="s3">, </span><span class="s1">self).parseImpl(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions)</span>
        <span class="s3">except </span><span class="s1">(ParseException</span><span class="s3">, </span><span class="s1">IndexError):</span>
            <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">[]</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.name</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.strRepr = </span><span class="s2">&quot;[&quot; </span><span class="s1">+ _ustr(self.expr) + </span><span class="s2">&quot;]...&quot;</span>

        <span class="s3">return </span><span class="s1">self.strRepr</span>


<span class="s3">class </span><span class="s1">_NullToken(object):</span>
    <span class="s3">def </span><span class="s1">__bool__(self):</span>
        <span class="s3">return False</span>
    <span class="s1">__nonzero__ = __bool__</span>
    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s2">&quot;&quot;</span>

<span class="s3">class </span><span class="s1">Optional(ParseElementEnhance):</span>
    <span class="s5">&quot;&quot;&quot;Optional matching of the given expression. 
 
    Parameters: 
     - expr - expression that must match zero or more times 
     - default (optional) - value to be returned if the optional expression is not found. 
 
    Example:: 
 
        # US postal code can be a 5-digit zip, plus optional 4-digit qualifier 
        zip = Combine(Word(nums, exact=5) + Optional('-' + Word(nums, exact=4))) 
        zip.runTests(''' 
            # traditional ZIP code 
            12345 
 
            # ZIP+4 form 
            12101-0001 
 
            # invalid ZIP 
            98765- 
            ''') 
 
    prints:: 
 
        # traditional ZIP code 
        12345 
        ['12345'] 
 
        # ZIP+4 form 
        12101-0001 
        ['12101-0001'] 
 
        # invalid ZIP 
        98765- 
             ^ 
        FAIL: Expected end of text (at char 5), (line:1, col:6) 
    &quot;&quot;&quot;</span>
    <span class="s1">__optionalNotMatched = _NullToken()</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">default=__optionalNotMatched):</span>
        <span class="s1">super(Optional</span><span class="s3">, </span><span class="s1">self).__init__(expr</span><span class="s3">, </span><span class="s1">savelist=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">self.saveAsList = self.expr.saveAsList</span>
        <span class="s1">self.defaultValue = default</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">loc</span><span class="s3">, </span><span class="s1">tokens = self.expr._parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions</span><span class="s3">, </span><span class="s1">callPreParse=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">(ParseException</span><span class="s3">, </span><span class="s1">IndexError):</span>
            <span class="s3">if </span><span class="s1">self.defaultValue </span><span class="s3">is not </span><span class="s1">self.__optionalNotMatched:</span>
                <span class="s3">if </span><span class="s1">self.expr.resultsName:</span>
                    <span class="s1">tokens = ParseResults([self.defaultValue])</span>
                    <span class="s1">tokens[self.expr.resultsName] = self.defaultValue</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">tokens = [self.defaultValue]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">tokens = []</span>
        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">tokens</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.name</span>

        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.strRepr = </span><span class="s2">&quot;[&quot; </span><span class="s1">+ _ustr(self.expr) + </span><span class="s2">&quot;]&quot;</span>

        <span class="s3">return </span><span class="s1">self.strRepr</span>

<span class="s3">class </span><span class="s1">SkipTo(ParseElementEnhance):</span>
    <span class="s5">&quot;&quot;&quot;Token for skipping over all undefined text until the matched 
    expression is found. 
 
    Parameters: 
     - expr - target expression marking the end of the data to be skipped 
     - include - (default= ``False``) if True, the target expression is also parsed 
          (the skipped text and target expression are returned as a 2-element list). 
     - ignore - (default= ``None``) used to define grammars (typically quoted strings and 
          comments) that might contain false matches to the target expression 
     - failOn - (default= ``None``) define expressions that are not allowed to be 
          included in the skipped test; if found before the target expression is found, 
          the SkipTo is not a match 
 
    Example:: 
 
        report = ''' 
            Outstanding Issues Report - 1 Jan 2000 
 
               # | Severity | Description                               |  Days Open 
            -----+----------+-------------------------------------------+----------- 
             101 | Critical | Intermittent system crash                 |          6 
              94 | Cosmetic | Spelling error on Login ('log|n')         |         14 
              79 | Minor    | System slow when running too many reports |         47 
            ''' 
        integer = Word(nums) 
        SEP = Suppress('|') 
        # use SkipTo to simply match everything up until the next SEP 
        # - ignore quoted strings, so that a '|' character inside a quoted string does not match 
        # - parse action will call token.strip() for each matched token, i.e., the description body 
        string_data = SkipTo(SEP, ignore=quotedString) 
        string_data.setParseAction(tokenMap(str.strip)) 
        ticket_expr = (integer(&quot;issue_num&quot;) + SEP 
                      + string_data(&quot;sev&quot;) + SEP 
                      + string_data(&quot;desc&quot;) + SEP 
                      + integer(&quot;days_open&quot;)) 
 
        for tkt in ticket_expr.searchString(report): 
            print tkt.dump() 
 
    prints:: 
 
        ['101', 'Critical', 'Intermittent system crash', '6'] 
        - days_open: 6 
        - desc: Intermittent system crash 
        - issue_num: 101 
        - sev: Critical 
        ['94', 'Cosmetic', &quot;Spelling error on Login ('log|n')&quot;, '14'] 
        - days_open: 14 
        - desc: Spelling error on Login ('log|n') 
        - issue_num: 94 
        - sev: Cosmetic 
        ['79', 'Minor', 'System slow when running too many reports', '47'] 
        - days_open: 47 
        - desc: System slow when running too many reports 
        - issue_num: 79 
        - sev: Minor 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">include=</span><span class="s3">False, </span><span class="s1">ignore=</span><span class="s3">None, </span><span class="s1">failOn=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super(SkipTo</span><span class="s3">, </span><span class="s1">self).__init__(other)</span>
        <span class="s1">self.ignoreExpr = ignore</span>
        <span class="s1">self.mayReturnEmpty = </span><span class="s3">True</span>
        <span class="s1">self.mayIndexError = </span><span class="s3">False</span>
        <span class="s1">self.includeMatch = include</span>
        <span class="s1">self.saveAsList = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">isinstance(failOn</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">self.failOn = self._literalStringClass(failOn)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.failOn = failOn</span>
        <span class="s1">self.errmsg = </span><span class="s2">&quot;No match found for &quot; </span><span class="s1">+ _ustr(self.expr)</span>

    <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">startloc = loc</span>
        <span class="s1">instrlen = len(instring)</span>
        <span class="s1">expr = self.expr</span>
        <span class="s1">expr_parse = self.expr._parse</span>
        <span class="s1">self_failOn_canParseNext = self.failOn.canParseNext </span><span class="s3">if </span><span class="s1">self.failOn </span><span class="s3">is not None else None</span>
        <span class="s1">self_ignoreExpr_tryParse = self.ignoreExpr.tryParse </span><span class="s3">if </span><span class="s1">self.ignoreExpr </span><span class="s3">is not None else None</span>

        <span class="s1">tmploc = loc</span>
        <span class="s3">while </span><span class="s1">tmploc &lt;= instrlen:</span>
            <span class="s3">if </span><span class="s1">self_failOn_canParseNext </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s0"># break if failOn expression matches</span>
                <span class="s3">if </span><span class="s1">self_failOn_canParseNext(instring</span><span class="s3">, </span><span class="s1">tmploc):</span>
                    <span class="s3">break</span>

            <span class="s3">if </span><span class="s1">self_ignoreExpr_tryParse </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s0"># advance past ignore expressions</span>
                <span class="s3">while </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">tmploc = self_ignoreExpr_tryParse(instring</span><span class="s3">, </span><span class="s1">tmploc)</span>
                    <span class="s3">except </span><span class="s1">ParseBaseException:</span>
                        <span class="s3">break</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">expr_parse(instring</span><span class="s3">, </span><span class="s1">tmploc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">False, </span><span class="s1">callPreParse=</span><span class="s3">False</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">(ParseException</span><span class="s3">, </span><span class="s1">IndexError):</span>
                <span class="s0"># no match, advance loc in string</span>
                <span class="s1">tmploc += </span><span class="s4">1</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># matched skipto expr, done</span>
                <span class="s3">break</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># ran off the end of the input string without matching skipto expr, fail</span>
            <span class="s3">raise </span><span class="s1">ParseException(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">self.errmsg</span><span class="s3">, </span><span class="s1">self)</span>

        <span class="s0"># build up return values</span>
        <span class="s1">loc = tmploc</span>
        <span class="s1">skiptext = instring[startloc:loc]</span>
        <span class="s1">skipresult = ParseResults(skiptext)</span>

        <span class="s3">if </span><span class="s1">self.includeMatch:</span>
            <span class="s1">loc</span><span class="s3">, </span><span class="s1">mat = expr_parse(instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions</span><span class="s3">, </span><span class="s1">callPreParse=</span><span class="s3">False</span><span class="s1">)</span>
            <span class="s1">skipresult += mat</span>

        <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">skipresult</span>

<span class="s3">class </span><span class="s1">Forward(ParseElementEnhance):</span>
    <span class="s5">&quot;&quot;&quot;Forward declaration of an expression to be defined later - 
    used for recursive grammars, such as algebraic infix notation. 
    When the expression is known, it is assigned to the ``Forward`` 
    variable using the '&lt;&lt;' operator. 
 
    Note: take care when assigning to ``Forward`` not to overlook 
    precedence of operators. 
 
    Specifically, '|' has a lower precedence than '&lt;&lt;', so that:: 
 
        fwdExpr &lt;&lt; a | b | c 
 
    will actually be evaluated as:: 
 
        (fwdExpr &lt;&lt; a) | b | c 
 
    thereby leaving b and c out as parseable alternatives.  It is recommended that you 
    explicitly group the values inserted into the ``Forward``:: 
 
        fwdExpr &lt;&lt; (a | b | c) 
 
    Converting to use the '&lt;&lt;=' operator instead will avoid this problem. 
 
    See :class:`ParseResults.pprint` for an example of a recursive 
    parser created using ``Forward``. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">other=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super(Forward</span><span class="s3">, </span><span class="s1">self).__init__(other</span><span class="s3">, </span><span class="s1">savelist=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__lshift__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">other = self._literalStringClass(other)</span>
        <span class="s1">self.expr = other</span>
        <span class="s1">self.strRepr = </span><span class="s3">None</span>
        <span class="s1">self.mayIndexError = self.expr.mayIndexError</span>
        <span class="s1">self.mayReturnEmpty = self.expr.mayReturnEmpty</span>
        <span class="s1">self.setWhitespaceChars(self.expr.whiteChars)</span>
        <span class="s1">self.skipWhitespace = self.expr.skipWhitespace</span>
        <span class="s1">self.saveAsList = self.expr.saveAsList</span>
        <span class="s1">self.ignoreExprs.extend(self.expr.ignoreExprs)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__ilshift__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return </span><span class="s1">self &lt;&lt; other</span>

    <span class="s3">def </span><span class="s1">leaveWhitespace(self):</span>
        <span class="s1">self.skipWhitespace = </span><span class="s3">False</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">streamline(self):</span>
        <span class="s3">if not </span><span class="s1">self.streamlined:</span>
            <span class="s1">self.streamlined = </span><span class="s3">True</span>
            <span class="s3">if </span><span class="s1">self.expr </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.expr.streamline()</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">validate(self</span><span class="s3">, </span><span class="s1">validateTrace=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">validateTrace </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">validateTrace = []</span>

        <span class="s3">if </span><span class="s1">self </span><span class="s3">not in </span><span class="s1">validateTrace:</span>
            <span class="s1">tmp = validateTrace[:] + [self]</span>
            <span class="s3">if </span><span class="s1">self.expr </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.expr.validate(tmp)</span>
        <span class="s1">self.checkRecursion([])</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.name</span>
        <span class="s3">if </span><span class="s1">self.strRepr </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.strRepr</span>

        <span class="s0"># Avoid infinite recursion by setting a temporary strRepr</span>
        <span class="s1">self.strRepr = </span><span class="s2">&quot;: ...&quot;</span>

        <span class="s0"># Use the string representation of main expression.</span>
        <span class="s1">retString = </span><span class="s2">'...'</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.expr </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">retString = _ustr(self.expr)[:</span><span class="s4">1000</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">retString = </span><span class="s2">&quot;None&quot;</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">self.strRepr = self.__class__.__name__ + </span><span class="s2">&quot;: &quot; </span><span class="s1">+ retString</span>
        <span class="s3">return </span><span class="s1">self.strRepr</span>

    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s3">if </span><span class="s1">self.expr </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">super(Forward</span><span class="s3">, </span><span class="s1">self).copy()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">ret = Forward()</span>
            <span class="s1">ret &lt;&lt;= self</span>
            <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">_setResultsName(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">listAllMatches=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">__diag__.warn_name_set_on_empty_Forward:</span>
            <span class="s3">if </span><span class="s1">self.expr </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">warnings.warn(</span><span class="s2">&quot;{0}: setting results name {0!r} on {1} expression &quot;</span>
                              <span class="s2">&quot;that has no contained expression&quot;</span><span class="s1">.format(</span><span class="s2">&quot;warn_name_set_on_empty_Forward&quot;</span><span class="s3">,</span>
                                                                        <span class="s1">name</span><span class="s3">,</span>
                                                                        <span class="s1">type(self).__name__)</span><span class="s3">,</span>
                              <span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">super(Forward</span><span class="s3">, </span><span class="s1">self)._setResultsName(name</span><span class="s3">, </span><span class="s1">listAllMatches)</span>

<span class="s3">class </span><span class="s1">TokenConverter(ParseElementEnhance):</span>
    <span class="s5">&quot;&quot;&quot; 
    Abstract subclass of :class:`ParseExpression`, for converting parsed results. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">savelist=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">super(TokenConverter</span><span class="s3">, </span><span class="s1">self).__init__(expr)  </span><span class="s0"># , savelist)</span>
        <span class="s1">self.saveAsList = </span><span class="s3">False</span>

<span class="s3">class </span><span class="s1">Combine(TokenConverter):</span>
    <span class="s5">&quot;&quot;&quot;Converter to concatenate all matching tokens to a single string. 
    By default, the matching patterns must also be contiguous in the 
    input string; this can be disabled by specifying 
    ``'adjacent=False'`` in the constructor. 
 
    Example:: 
 
        real = Word(nums) + '.' + Word(nums) 
        print(real.parseString('3.1416')) # -&gt; ['3', '.', '1416'] 
        # will also erroneously match the following 
        print(real.parseString('3. 1416')) # -&gt; ['3', '.', '1416'] 
 
        real = Combine(Word(nums) + '.' + Word(nums)) 
        print(real.parseString('3.1416')) # -&gt; ['3.1416'] 
        # no match when there are internal spaces 
        print(real.parseString('3. 1416')) # -&gt; Exception: Expected W:(0123...) 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">joinString=</span><span class="s2">&quot;&quot;</span><span class="s3">, </span><span class="s1">adjacent=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">super(Combine</span><span class="s3">, </span><span class="s1">self).__init__(expr)</span>
        <span class="s0"># suppress whitespace-stripping in contained parse expressions, but re-enable it on the Combine itself</span>
        <span class="s3">if </span><span class="s1">adjacent:</span>
            <span class="s1">self.leaveWhitespace()</span>
        <span class="s1">self.adjacent = adjacent</span>
        <span class="s1">self.skipWhitespace = </span><span class="s3">True</span>
        <span class="s1">self.joinString = joinString</span>
        <span class="s1">self.callPreparse = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">ignore(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">self.adjacent:</span>
            <span class="s1">ParserElement.ignore(self</span><span class="s3">, </span><span class="s1">other)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">super(Combine</span><span class="s3">, </span><span class="s1">self).ignore(other)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">postParse(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">tokenlist):</span>
        <span class="s1">retToks = tokenlist.copy()</span>
        <span class="s3">del </span><span class="s1">retToks[:]</span>
        <span class="s1">retToks += ParseResults([</span><span class="s2">&quot;&quot;</span><span class="s1">.join(tokenlist._asStringList(self.joinString))]</span><span class="s3">, </span><span class="s1">modal=self.modalResults)</span>

        <span class="s3">if </span><span class="s1">self.resultsName </span><span class="s3">and </span><span class="s1">retToks.haskeys():</span>
            <span class="s3">return </span><span class="s1">[retToks]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">retToks</span>

<span class="s3">class </span><span class="s1">Group(TokenConverter):</span>
    <span class="s5">&quot;&quot;&quot;Converter to return the matched tokens as a list - useful for 
    returning tokens of :class:`ZeroOrMore` and :class:`OneOrMore` expressions. 
 
    Example:: 
 
        ident = Word(alphas) 
        num = Word(nums) 
        term = ident | num 
        func = ident + Optional(delimitedList(term)) 
        print(func.parseString(&quot;fn a, b, 100&quot;))  # -&gt; ['fn', 'a', 'b', '100'] 
 
        func = ident + Group(Optional(delimitedList(term))) 
        print(func.parseString(&quot;fn a, b, 100&quot;))  # -&gt; ['fn', ['a', 'b', '100']] 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr):</span>
        <span class="s1">super(Group</span><span class="s3">, </span><span class="s1">self).__init__(expr)</span>
        <span class="s1">self.saveAsList = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">postParse(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">tokenlist):</span>
        <span class="s3">return </span><span class="s1">[tokenlist]</span>

<span class="s3">class </span><span class="s1">Dict(TokenConverter):</span>
    <span class="s5">&quot;&quot;&quot;Converter to return a repetitive expression as a list, but also 
    as a dictionary. Each element can also be referenced using the first 
    token in the expression as its key. Useful for tabular report 
    scraping when the first column can be used as a item key. 
 
    Example:: 
 
        data_word = Word(alphas) 
        label = data_word + FollowedBy(':') 
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word).setParseAction(' '.join)) 
 
        text = &quot;shape: SQUARE posn: upper left color: light blue texture: burlap&quot; 
        attr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join)) 
 
        # print attributes as plain groups 
        print(OneOrMore(attr_expr).parseString(text).dump()) 
 
        # instead of OneOrMore(expr), parse using Dict(OneOrMore(Group(expr))) - Dict will auto-assign names 
        result = Dict(OneOrMore(Group(attr_expr))).parseString(text) 
        print(result.dump()) 
 
        # access named fields as dict entries, or output as dict 
        print(result['shape']) 
        print(result.asDict()) 
 
    prints:: 
 
        ['shape', 'SQUARE', 'posn', 'upper left', 'color', 'light blue', 'texture', 'burlap'] 
        [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']] 
        - color: light blue 
        - posn: upper left 
        - shape: SQUARE 
        - texture: burlap 
        SQUARE 
        {'color': 'light blue', 'posn': 'upper left', 'texture': 'burlap', 'shape': 'SQUARE'} 
 
    See more examples at :class:`ParseResults` of accessing fields by results name. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr):</span>
        <span class="s1">super(Dict</span><span class="s3">, </span><span class="s1">self).__init__(expr)</span>
        <span class="s1">self.saveAsList = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">postParse(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">tokenlist):</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">tok </span><span class="s3">in </span><span class="s1">enumerate(tokenlist):</span>
            <span class="s3">if </span><span class="s1">len(tok) == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s3">continue</span>
            <span class="s1">ikey = tok[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">isinstance(ikey</span><span class="s3">, </span><span class="s1">int):</span>
                <span class="s1">ikey = _ustr(tok[</span><span class="s4">0</span><span class="s1">]).strip()</span>
            <span class="s3">if </span><span class="s1">len(tok) == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">tokenlist[ikey] = _ParseResultsWithOffset(</span><span class="s2">&quot;&quot;</span><span class="s3">, </span><span class="s1">i)</span>
            <span class="s3">elif </span><span class="s1">len(tok) == </span><span class="s4">2 </span><span class="s3">and not </span><span class="s1">isinstance(tok[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ParseResults):</span>
                <span class="s1">tokenlist[ikey] = _ParseResultsWithOffset(tok[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">i)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">dictvalue = tok.copy()  </span><span class="s0"># ParseResults(i)</span>
                <span class="s3">del </span><span class="s1">dictvalue[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s3">if </span><span class="s1">len(dictvalue) != </span><span class="s4">1 </span><span class="s3">or </span><span class="s1">(isinstance(dictvalue</span><span class="s3">, </span><span class="s1">ParseResults) </span><span class="s3">and </span><span class="s1">dictvalue.haskeys()):</span>
                    <span class="s1">tokenlist[ikey] = _ParseResultsWithOffset(dictvalue</span><span class="s3">, </span><span class="s1">i)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">tokenlist[ikey] = _ParseResultsWithOffset(dictvalue[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">i)</span>

        <span class="s3">if </span><span class="s1">self.resultsName:</span>
            <span class="s3">return </span><span class="s1">[tokenlist]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">tokenlist</span>


<span class="s3">class </span><span class="s1">Suppress(TokenConverter):</span>
    <span class="s5">&quot;&quot;&quot;Converter for ignoring the results of a parsed expression. 
 
    Example:: 
 
        source = &quot;a, b, c,d&quot; 
        wd = Word(alphas) 
        wd_list1 = wd + ZeroOrMore(',' + wd) 
        print(wd_list1.parseString(source)) 
 
        # often, delimiters that are useful during parsing are just in the 
        # way afterward - use Suppress to keep them out of the parsed output 
        wd_list2 = wd + ZeroOrMore(Suppress(',') + wd) 
        print(wd_list2.parseString(source)) 
 
    prints:: 
 
        ['a', ',', 'b', ',', 'c', ',', 'd'] 
        ['a', 'b', 'c', 'd'] 
 
    (See also :class:`delimitedList`.) 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">postParse(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">tokenlist):</span>
        <span class="s3">return </span><span class="s1">[]</span>

    <span class="s3">def </span><span class="s1">suppress(self):</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">OnlyOnce(object):</span>
    <span class="s5">&quot;&quot;&quot;Wrapper for parse actions, to ensure they are only called once. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">methodCall):</span>
        <span class="s1">self.callable = _trim_arity(methodCall)</span>
        <span class="s1">self.called = </span><span class="s3">False</span>
    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">if not </span><span class="s1">self.called:</span>
            <span class="s1">results = self.callable(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t)</span>
            <span class="s1">self.called = </span><span class="s3">True</span>
            <span class="s3">return </span><span class="s1">results</span>
        <span class="s3">raise </span><span class="s1">ParseException(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">reset(self):</span>
        <span class="s1">self.called = </span><span class="s3">False</span>

<span class="s3">def </span><span class="s1">traceParseAction(f):</span>
    <span class="s5">&quot;&quot;&quot;Decorator for debugging parse actions. 
 
    When the parse action is called, this decorator will print 
    ``&quot;&gt;&gt; entering method-name(line:&lt;current_source_line&gt;, &lt;parse_location&gt;, &lt;matched_tokens&gt;)&quot;``. 
    When the parse action completes, the decorator will print 
    ``&quot;&lt;&lt;&quot;`` followed by the returned value, or any exception that the parse action raised. 
 
    Example:: 
 
        wd = Word(alphas) 
 
        @traceParseAction 
        def remove_duplicate_chars(tokens): 
            return ''.join(sorted(set(''.join(tokens)))) 
 
        wds = OneOrMore(wd).setParseAction(remove_duplicate_chars) 
        print(wds.parseString(&quot;slkdjs sld sldd sdlf sdljf&quot;)) 
 
    prints:: 
 
        &gt;&gt;entering remove_duplicate_chars(line: 'slkdjs sld sldd sdlf sdljf', 0, (['slkdjs', 'sld', 'sldd', 'sdlf', 'sdljf'], {})) 
        &lt;&lt;leaving remove_duplicate_chars (ret: 'dfjkls') 
        ['dfjkls'] 
    &quot;&quot;&quot;</span>
    <span class="s1">f = _trim_arity(f)</span>
    <span class="s3">def </span><span class="s1">z(*paArgs):</span>
        <span class="s1">thisFunc = f.__name__</span>
        <span class="s1">s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t = paArgs[-</span><span class="s4">3</span><span class="s1">:]</span>
        <span class="s3">if </span><span class="s1">len(paArgs) &gt; </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s1">thisFunc = paArgs[</span><span class="s4">0</span><span class="s1">].__class__.__name__ + </span><span class="s2">'.' </span><span class="s1">+ thisFunc</span>
        <span class="s1">sys.stderr.write(</span><span class="s2">&quot;&gt;&gt;entering %s(line: '%s', %d, %r)</span><span class="s3">\n</span><span class="s2">&quot; </span><span class="s1">% (thisFunc</span><span class="s3">, </span><span class="s1">line(l</span><span class="s3">, </span><span class="s1">s)</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t))</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">ret = f(*paArgs)</span>
        <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">exc:</span>
            <span class="s1">sys.stderr.write(</span><span class="s2">&quot;&lt;&lt;leaving %s (exception: %s)</span><span class="s3">\n</span><span class="s2">&quot; </span><span class="s1">% (thisFunc</span><span class="s3">, </span><span class="s1">exc))</span>
            <span class="s3">raise</span>
        <span class="s1">sys.stderr.write(</span><span class="s2">&quot;&lt;&lt;leaving %s (ret: %r)</span><span class="s3">\n</span><span class="s2">&quot; </span><span class="s1">% (thisFunc</span><span class="s3">, </span><span class="s1">ret))</span>
        <span class="s3">return </span><span class="s1">ret</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">z.__name__ = f.__name__</span>
    <span class="s3">except </span><span class="s1">AttributeError:</span>
        <span class="s3">pass</span>
    <span class="s3">return </span><span class="s1">z</span>

<span class="s0">#</span>
<span class="s0"># global helpers</span>
<span class="s0">#</span>
<span class="s3">def </span><span class="s1">delimitedList(expr</span><span class="s3">, </span><span class="s1">delim=</span><span class="s2">&quot;,&quot;</span><span class="s3">, </span><span class="s1">combine=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Helper to define a delimited list of expressions - the delimiter 
    defaults to ','. By default, the list elements and delimiters can 
    have intervening whitespace, and comments, but this can be 
    overridden by passing ``combine=True`` in the constructor. If 
    ``combine`` is set to ``True``, the matching tokens are 
    returned as a single token string, with the delimiters included; 
    otherwise, the matching tokens are returned as a list of tokens, 
    with the delimiters suppressed. 
 
    Example:: 
 
        delimitedList(Word(alphas)).parseString(&quot;aa,bb,cc&quot;) # -&gt; ['aa', 'bb', 'cc'] 
        delimitedList(Word(hexnums), delim=':', combine=True).parseString(&quot;AA:BB:CC:DD:EE&quot;) # -&gt; ['AA:BB:CC:DD:EE'] 
    &quot;&quot;&quot;</span>
    <span class="s1">dlName = _ustr(expr) + </span><span class="s2">&quot; [&quot; </span><span class="s1">+ _ustr(delim) + </span><span class="s2">&quot; &quot; </span><span class="s1">+ _ustr(expr) + </span><span class="s2">&quot;]...&quot;</span>
    <span class="s3">if </span><span class="s1">combine:</span>
        <span class="s3">return </span><span class="s1">Combine(expr + ZeroOrMore(delim + expr)).setName(dlName)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">(expr + ZeroOrMore(Suppress(delim) + expr)).setName(dlName)</span>

<span class="s3">def </span><span class="s1">countedArray(expr</span><span class="s3">, </span><span class="s1">intExpr=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Helper to define a counted list of expressions. 
 
    This helper defines a pattern of the form:: 
 
        integer expr expr expr... 
 
    where the leading integer tells how many expr expressions follow. 
    The matched tokens returns the array of expr tokens as a list - the 
    leading count token is suppressed. 
 
    If ``intExpr`` is specified, it should be a pyparsing expression 
    that produces an integer value. 
 
    Example:: 
 
        countedArray(Word(alphas)).parseString('2 ab cd ef')  # -&gt; ['ab', 'cd'] 
 
        # in this parser, the leading integer value is given in binary, 
        # '10' indicating that 2 values are in the array 
        binaryConstant = Word('01').setParseAction(lambda t: int(t[0], 2)) 
        countedArray(Word(alphas), intExpr=binaryConstant).parseString('10 ab cd ef')  # -&gt; ['ab', 'cd'] 
    &quot;&quot;&quot;</span>
    <span class="s1">arrayExpr = Forward()</span>
    <span class="s3">def </span><span class="s1">countFieldParseAction(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s1">n = t[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">arrayExpr &lt;&lt; (n </span><span class="s3">and </span><span class="s1">Group(And([expr] * n)) </span><span class="s3">or </span><span class="s1">Group(empty))</span>
        <span class="s3">return </span><span class="s1">[]</span>
    <span class="s3">if </span><span class="s1">intExpr </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">intExpr = Word(nums).setParseAction(</span><span class="s3">lambda </span><span class="s1">t: int(t[</span><span class="s4">0</span><span class="s1">]))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">intExpr = intExpr.copy()</span>
    <span class="s1">intExpr.setName(</span><span class="s2">&quot;arrayLen&quot;</span><span class="s1">)</span>
    <span class="s1">intExpr.addParseAction(countFieldParseAction</span><span class="s3">, </span><span class="s1">callDuringTry=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">(intExpr + arrayExpr).setName(</span><span class="s2">'(len) ' </span><span class="s1">+ _ustr(expr) + </span><span class="s2">'...'</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_flatten(L):</span>
    <span class="s1">ret = []</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">L:</span>
        <span class="s3">if </span><span class="s1">isinstance(i</span><span class="s3">, </span><span class="s1">list):</span>
            <span class="s1">ret.extend(_flatten(i))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">ret.append(i)</span>
    <span class="s3">return </span><span class="s1">ret</span>

<span class="s3">def </span><span class="s1">matchPreviousLiteral(expr):</span>
    <span class="s5">&quot;&quot;&quot;Helper to define an expression that is indirectly defined from 
    the tokens matched in a previous expression, that is, it looks for 
    a 'repeat' of a previous expression.  For example:: 
 
        first = Word(nums) 
        second = matchPreviousLiteral(first) 
        matchExpr = first + &quot;:&quot; + second 
 
    will match ``&quot;1:1&quot;``, but not ``&quot;1:2&quot;``.  Because this 
    matches a previous literal, will also match the leading 
    ``&quot;1:1&quot;`` in ``&quot;1:10&quot;``. If this is not desired, use 
    :class:`matchPreviousExpr`. Do *not* use with packrat parsing 
    enabled. 
    &quot;&quot;&quot;</span>
    <span class="s1">rep = Forward()</span>
    <span class="s3">def </span><span class="s1">copyTokenToRepeater(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">if </span><span class="s1">t:</span>
            <span class="s3">if </span><span class="s1">len(t) == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">rep &lt;&lt; t[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># flatten t tokens</span>
                <span class="s1">tflat = _flatten(t.asList())</span>
                <span class="s1">rep &lt;&lt; And(Literal(tt) </span><span class="s3">for </span><span class="s1">tt </span><span class="s3">in </span><span class="s1">tflat)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">rep &lt;&lt; Empty()</span>
    <span class="s1">expr.addParseAction(copyTokenToRepeater</span><span class="s3">, </span><span class="s1">callDuringTry=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">rep.setName(</span><span class="s2">'(prev) ' </span><span class="s1">+ _ustr(expr))</span>
    <span class="s3">return </span><span class="s1">rep</span>

<span class="s3">def </span><span class="s1">matchPreviousExpr(expr):</span>
    <span class="s5">&quot;&quot;&quot;Helper to define an expression that is indirectly defined from 
    the tokens matched in a previous expression, that is, it looks for 
    a 'repeat' of a previous expression.  For example:: 
 
        first = Word(nums) 
        second = matchPreviousExpr(first) 
        matchExpr = first + &quot;:&quot; + second 
 
    will match ``&quot;1:1&quot;``, but not ``&quot;1:2&quot;``.  Because this 
    matches by expressions, will *not* match the leading ``&quot;1:1&quot;`` 
    in ``&quot;1:10&quot;``; the expressions are evaluated first, and then 
    compared, so ``&quot;1&quot;`` is compared with ``&quot;10&quot;``. Do *not* use 
    with packrat parsing enabled. 
    &quot;&quot;&quot;</span>
    <span class="s1">rep = Forward()</span>
    <span class="s1">e2 = expr.copy()</span>
    <span class="s1">rep &lt;&lt;= e2</span>
    <span class="s3">def </span><span class="s1">copyTokenToRepeater(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s1">matchTokens = _flatten(t.asList())</span>
        <span class="s3">def </span><span class="s1">mustMatchTheseTokens(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
            <span class="s1">theseTokens = _flatten(t.asList())</span>
            <span class="s3">if </span><span class="s1">theseTokens != matchTokens:</span>
                <span class="s3">raise </span><span class="s1">ParseException(</span><span class="s2">''</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s2">''</span><span class="s1">)</span>
        <span class="s1">rep.setParseAction(mustMatchTheseTokens</span><span class="s3">, </span><span class="s1">callDuringTry=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">expr.addParseAction(copyTokenToRepeater</span><span class="s3">, </span><span class="s1">callDuringTry=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">rep.setName(</span><span class="s2">'(prev) ' </span><span class="s1">+ _ustr(expr))</span>
    <span class="s3">return </span><span class="s1">rep</span>

<span class="s3">def </span><span class="s1">_escapeRegexRangeChars(s):</span>
    <span class="s0"># ~  escape these chars: ^-[]</span>
    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s2">r&quot;\^-[]&quot;</span><span class="s1">:</span>
        <span class="s1">s = s.replace(c</span><span class="s3">, </span><span class="s1">_bslash + c)</span>
    <span class="s1">s = s.replace(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s3">, </span><span class="s2">r&quot;\n&quot;</span><span class="s1">)</span>
    <span class="s1">s = s.replace(</span><span class="s2">&quot;</span><span class="s3">\t</span><span class="s2">&quot;</span><span class="s3">, </span><span class="s2">r&quot;\t&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_ustr(s)</span>

<span class="s3">def </span><span class="s1">oneOf(strs</span><span class="s3">, </span><span class="s1">caseless=</span><span class="s3">False, </span><span class="s1">useRegex=</span><span class="s3">True, </span><span class="s1">asKeyword=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Helper to quickly define a set of alternative Literals, and makes 
    sure to do longest-first testing when there is a conflict, 
    regardless of the input order, but returns 
    a :class:`MatchFirst` for best performance. 
 
    Parameters: 
 
     - strs - a string of space-delimited literals, or a collection of 
       string literals 
     - caseless - (default= ``False``) - treat all literals as 
       caseless 
     - useRegex - (default= ``True``) - as an optimization, will 
       generate a Regex object; otherwise, will generate 
       a :class:`MatchFirst` object (if ``caseless=True`` or ``asKeyword=True``, or if 
       creating a :class:`Regex` raises an exception) 
     - asKeyword - (default=``False``) - enforce Keyword-style matching on the 
       generated expressions 
 
    Example:: 
 
        comp_oper = oneOf(&quot;&lt; = &gt; &lt;= &gt;= !=&quot;) 
        var = Word(alphas) 
        number = Word(nums) 
        term = var | number 
        comparison_expr = term + comp_oper + term 
        print(comparison_expr.searchString(&quot;B = 12  AA=23 B&lt;=AA AA&gt;12&quot;)) 
 
    prints:: 
 
        [['B', '=', '12'], ['AA', '=', '23'], ['B', '&lt;=', 'AA'], ['AA', '&gt;', '12']] 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(caseless</span><span class="s3">, </span><span class="s1">basestring):</span>
        <span class="s1">warnings.warn(</span><span class="s2">&quot;More than one string argument passed to oneOf, pass &quot;</span>
                      <span class="s2">&quot;choices as a list or space-delimited string&quot;</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">caseless:</span>
        <span class="s1">isequal = (</span><span class="s3">lambda </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b: a.upper() == b.upper())</span>
        <span class="s1">masks = (</span><span class="s3">lambda </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b: b.upper().startswith(a.upper()))</span>
        <span class="s1">parseElementClass = CaselessKeyword </span><span class="s3">if </span><span class="s1">asKeyword </span><span class="s3">else </span><span class="s1">CaselessLiteral</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">isequal = (</span><span class="s3">lambda </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b: a == b)</span>
        <span class="s1">masks = (</span><span class="s3">lambda </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b: b.startswith(a))</span>
        <span class="s1">parseElementClass = Keyword </span><span class="s3">if </span><span class="s1">asKeyword </span><span class="s3">else </span><span class="s1">Literal</span>

    <span class="s1">symbols = []</span>
    <span class="s3">if </span><span class="s1">isinstance(strs</span><span class="s3">, </span><span class="s1">basestring):</span>
        <span class="s1">symbols = strs.split()</span>
    <span class="s3">elif </span><span class="s1">isinstance(strs</span><span class="s3">, </span><span class="s1">Iterable):</span>
        <span class="s1">symbols = list(strs)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span><span class="s2">&quot;Invalid argument to oneOf, expected string or iterable&quot;</span><span class="s3">,</span>
                      <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">symbols:</span>
        <span class="s3">return </span><span class="s1">NoMatch()</span>

    <span class="s3">if not </span><span class="s1">asKeyword:</span>
        <span class="s0"># if not producing keywords, need to reorder to take care to avoid masking</span>
        <span class="s0"># longer choices with shorter ones</span>
        <span class="s1">i = </span><span class="s4">0</span>
        <span class="s3">while </span><span class="s1">i &lt; len(symbols) - </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">cur = symbols[i]</span>
            <span class="s3">for </span><span class="s1">j</span><span class="s3">, </span><span class="s1">other </span><span class="s3">in </span><span class="s1">enumerate(symbols[i + </span><span class="s4">1</span><span class="s1">:]):</span>
                <span class="s3">if </span><span class="s1">isequal(other</span><span class="s3">, </span><span class="s1">cur):</span>
                    <span class="s3">del </span><span class="s1">symbols[i + j + </span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s3">break</span>
                <span class="s3">elif </span><span class="s1">masks(cur</span><span class="s3">, </span><span class="s1">other):</span>
                    <span class="s3">del </span><span class="s1">symbols[i + j + </span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s1">symbols.insert(i</span><span class="s3">, </span><span class="s1">other)</span>
                    <span class="s3">break</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">i += </span><span class="s4">1</span>

    <span class="s3">if not </span><span class="s1">(caseless </span><span class="s3">or </span><span class="s1">asKeyword) </span><span class="s3">and </span><span class="s1">useRegex:</span>
        <span class="s0"># ~ print (strs, &quot;-&gt;&quot;, &quot;|&quot;.join([_escapeRegexChars(sym) for sym in symbols]))</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">len(symbols) == len(</span><span class="s2">&quot;&quot;</span><span class="s1">.join(symbols)):</span>
                <span class="s3">return </span><span class="s1">Regex(</span><span class="s2">&quot;[%s]&quot; </span><span class="s1">% </span><span class="s2">&quot;&quot;</span><span class="s1">.join(_escapeRegexRangeChars(sym) </span><span class="s3">for </span><span class="s1">sym </span><span class="s3">in </span><span class="s1">symbols)).setName(</span><span class="s2">' | '</span><span class="s1">.join(symbols))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Regex(</span><span class="s2">&quot;|&quot;</span><span class="s1">.join(re.escape(sym) </span><span class="s3">for </span><span class="s1">sym </span><span class="s3">in </span><span class="s1">symbols)).setName(</span><span class="s2">' | '</span><span class="s1">.join(symbols))</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Exception creating Regex for oneOf, building MatchFirst&quot;</span><span class="s3">,</span>
                    <span class="s1">SyntaxWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s0"># last resort, just use MatchFirst</span>
    <span class="s3">return </span><span class="s1">MatchFirst(parseElementClass(sym) </span><span class="s3">for </span><span class="s1">sym </span><span class="s3">in </span><span class="s1">symbols).setName(</span><span class="s2">' | '</span><span class="s1">.join(symbols))</span>

<span class="s3">def </span><span class="s1">dictOf(key</span><span class="s3">, </span><span class="s1">value):</span>
    <span class="s5">&quot;&quot;&quot;Helper to easily and clearly define a dictionary by specifying 
    the respective patterns for the key and value.  Takes care of 
    defining the :class:`Dict`, :class:`ZeroOrMore`, and 
    :class:`Group` tokens in the proper order.  The key pattern 
    can include delimiting markers or punctuation, as long as they are 
    suppressed, thereby leaving the significant key text.  The value 
    pattern can include named results, so that the :class:`Dict` results 
    can include named token fields. 
 
    Example:: 
 
        text = &quot;shape: SQUARE posn: upper left color: light blue texture: burlap&quot; 
        attr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join)) 
        print(OneOrMore(attr_expr).parseString(text).dump()) 
 
        attr_label = label 
        attr_value = Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join) 
 
        # similar to Dict, but simpler call format 
        result = dictOf(attr_label, attr_value).parseString(text) 
        print(result.dump()) 
        print(result['shape']) 
        print(result.shape)  # object attribute access works too 
        print(result.asDict()) 
 
    prints:: 
 
        [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']] 
        - color: light blue 
        - posn: upper left 
        - shape: SQUARE 
        - texture: burlap 
        SQUARE 
        SQUARE 
        {'color': 'light blue', 'shape': 'SQUARE', 'posn': 'upper left', 'texture': 'burlap'} 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">Dict(OneOrMore(Group(key + value)))</span>

<span class="s3">def </span><span class="s1">originalTextFor(expr</span><span class="s3">, </span><span class="s1">asString=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Helper to return the original, untokenized text for a given 
    expression.  Useful to restore the parsed fields of an HTML start 
    tag into the raw tag text itself, or to revert separate tokens with 
    intervening whitespace back to the original matching input text. By 
    default, returns astring containing the original parsed text. 
 
    If the optional ``asString`` argument is passed as 
    ``False``, then the return value is 
    a :class:`ParseResults` containing any results names that 
    were originally matched, and a single token containing the original 
    matched text from the input string.  So if the expression passed to 
    :class:`originalTextFor` contains expressions with defined 
    results names, you must set ``asString`` to ``False`` if you 
    want to preserve those results name values. 
 
    Example:: 
 
        src = &quot;this is test &lt;b&gt; bold &lt;i&gt;text&lt;/i&gt; &lt;/b&gt; normal text &quot; 
        for tag in (&quot;b&quot;, &quot;i&quot;): 
            opener, closer = makeHTMLTags(tag) 
            patt = originalTextFor(opener + SkipTo(closer) + closer) 
            print(patt.searchString(src)[0]) 
 
    prints:: 
 
        ['&lt;b&gt; bold &lt;i&gt;text&lt;/i&gt; &lt;/b&gt;'] 
        ['&lt;i&gt;text&lt;/i&gt;'] 
    &quot;&quot;&quot;</span>
    <span class="s1">locMarker = Empty().setParseAction(</span><span class="s3">lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">t: loc)</span>
    <span class="s1">endlocMarker = locMarker.copy()</span>
    <span class="s1">endlocMarker.callPreparse = </span><span class="s3">False</span>
    <span class="s1">matchExpr = locMarker(</span><span class="s2">&quot;_original_start&quot;</span><span class="s1">) + expr + endlocMarker(</span><span class="s2">&quot;_original_end&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">asString:</span>
        <span class="s1">extractText = </span><span class="s3">lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t: s[t._original_start: t._original_end]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">def </span><span class="s1">extractText(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
            <span class="s1">t[:] = [s[t.pop(</span><span class="s2">'_original_start'</span><span class="s1">):t.pop(</span><span class="s2">'_original_end'</span><span class="s1">)]]</span>
    <span class="s1">matchExpr.setParseAction(extractText)</span>
    <span class="s1">matchExpr.ignoreExprs = expr.ignoreExprs</span>
    <span class="s3">return </span><span class="s1">matchExpr</span>

<span class="s3">def </span><span class="s1">ungroup(expr):</span>
    <span class="s5">&quot;&quot;&quot;Helper to undo pyparsing's default grouping of And expressions, 
    even if all but one are non-empty. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">TokenConverter(expr).addParseAction(</span><span class="s3">lambda </span><span class="s1">t: t[</span><span class="s4">0</span><span class="s1">])</span>

<span class="s3">def </span><span class="s1">locatedExpr(expr):</span>
    <span class="s5">&quot;&quot;&quot;Helper to decorate a returned token with its starting and ending 
    locations in the input string. 
 
    This helper adds the following results names: 
 
     - locn_start = location where matched expression begins 
     - locn_end = location where matched expression ends 
     - value = the actual parsed results 
 
    Be careful if the input text contains ``&lt;TAB&gt;`` characters, you 
    may want to call :class:`ParserElement.parseWithTabs` 
 
    Example:: 
 
        wd = Word(alphas) 
        for match in locatedExpr(wd).searchString(&quot;ljsdf123lksdjjf123lkkjj1222&quot;): 
            print(match) 
 
    prints:: 
 
        [[0, 'ljsdf', 5]] 
        [[8, 'lksdjjf', 15]] 
        [[18, 'lkkjj', 23]] 
    &quot;&quot;&quot;</span>
    <span class="s1">locator = Empty().setParseAction(</span><span class="s3">lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t: l)</span>
    <span class="s3">return </span><span class="s1">Group(locator(</span><span class="s2">&quot;locn_start&quot;</span><span class="s1">) + expr(</span><span class="s2">&quot;value&quot;</span><span class="s1">) + locator.copy().leaveWhitespace()(</span><span class="s2">&quot;locn_end&quot;</span><span class="s1">))</span>


<span class="s0"># convenience constants for positional expressions</span>
<span class="s1">empty       = Empty().setName(</span><span class="s2">&quot;empty&quot;</span><span class="s1">)</span>
<span class="s1">lineStart   = LineStart().setName(</span><span class="s2">&quot;lineStart&quot;</span><span class="s1">)</span>
<span class="s1">lineEnd     = LineEnd().setName(</span><span class="s2">&quot;lineEnd&quot;</span><span class="s1">)</span>
<span class="s1">stringStart = StringStart().setName(</span><span class="s2">&quot;stringStart&quot;</span><span class="s1">)</span>
<span class="s1">stringEnd   = StringEnd().setName(</span><span class="s2">&quot;stringEnd&quot;</span><span class="s1">)</span>

<span class="s1">_escapedPunc = Word(_bslash</span><span class="s3">, </span><span class="s2">r&quot;\[]-*.$+^?()~ &quot;</span><span class="s3">, </span><span class="s1">exact=</span><span class="s4">2</span><span class="s1">).setParseAction(</span><span class="s3">lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t: t[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">])</span>
<span class="s1">_escapedHexChar = Regex(</span><span class="s2">r&quot;\\0?[xX][0-9a-fA-F]+&quot;</span><span class="s1">).setParseAction(</span><span class="s3">lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t: unichr(int(t[</span><span class="s4">0</span><span class="s1">].lstrip(</span><span class="s2">r'\0x'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">16</span><span class="s1">)))</span>
<span class="s1">_escapedOctChar = Regex(</span><span class="s2">r&quot;\\0[0-7]+&quot;</span><span class="s1">).setParseAction(</span><span class="s3">lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t: unichr(int(t[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s4">8</span><span class="s1">)))</span>
<span class="s1">_singleChar = _escapedPunc | _escapedHexChar | _escapedOctChar | CharsNotIn(</span><span class="s2">r'\]'</span><span class="s3">, </span><span class="s1">exact=</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">_charRange = Group(_singleChar + Suppress(</span><span class="s2">&quot;-&quot;</span><span class="s1">) + _singleChar)</span>
<span class="s1">_reBracketExpr = Literal(</span><span class="s2">&quot;[&quot;</span><span class="s1">) + Optional(</span><span class="s2">&quot;^&quot;</span><span class="s1">).setResultsName(</span><span class="s2">&quot;negate&quot;</span><span class="s1">) + Group(OneOrMore(_charRange | _singleChar)).setResultsName(</span><span class="s2">&quot;body&quot;</span><span class="s1">) + </span><span class="s2">&quot;]&quot;</span>

<span class="s3">def </span><span class="s1">srange(s):</span>
    <span class="s5">r&quot;&quot;&quot;Helper to easily define string ranges for use in Word 
    construction. Borrows syntax from regexp '[]' string range 
    definitions:: 
 
        srange(&quot;[0-9]&quot;)   -&gt; &quot;0123456789&quot; 
        srange(&quot;[a-z]&quot;)   -&gt; &quot;abcdefghijklmnopqrstuvwxyz&quot; 
        srange(&quot;[a-z$_]&quot;) -&gt; &quot;abcdefghijklmnopqrstuvwxyz$_&quot; 
 
    The input string must be enclosed in []'s, and the returned string 
    is the expanded character set joined into a single string. The 
    values enclosed in the []'s may be: 
 
     - a single character 
     - an escaped character with a leading backslash (such as ``\-`` 
       or ``\]``) 
     - an escaped hex character with a leading ``'\x'`` 
       (``\x21``, which is a ``'!'`` character) (``\0x##`` 
       is also supported for backwards compatibility) 
     - an escaped octal character with a leading ``'\0'`` 
       (``\041``, which is a ``'!'`` character) 
     - a range of any of the above, separated by a dash (``'a-z'``, 
       etc.) 
     - any combination of the above (``'aeiouy'``, 
       ``'a-zA-Z0-9_$'``, etc.) 
    &quot;&quot;&quot;</span>
    <span class="s1">_expanded = </span><span class="s3">lambda </span><span class="s1">p: p </span><span class="s3">if not </span><span class="s1">isinstance(p</span><span class="s3">, </span><span class="s1">ParseResults) </span><span class="s3">else </span><span class="s2">''</span><span class="s1">.join(unichr(c) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">range(ord(p[</span><span class="s4">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">ord(p[</span><span class="s4">1</span><span class="s1">]) + </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">.join(_expanded(part) </span><span class="s3">for </span><span class="s1">part </span><span class="s3">in </span><span class="s1">_reBracketExpr.parseString(s).body)</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s3">return </span><span class="s2">&quot;&quot;</span>

<span class="s3">def </span><span class="s1">matchOnlyAtCol(n):</span>
    <span class="s5">&quot;&quot;&quot;Helper method for defining parse actions that require matching at 
    a specific column in the input text. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">verifyCol(strg</span><span class="s3">, </span><span class="s1">locn</span><span class="s3">, </span><span class="s1">toks):</span>
        <span class="s3">if </span><span class="s1">col(locn</span><span class="s3">, </span><span class="s1">strg) != n:</span>
            <span class="s3">raise </span><span class="s1">ParseException(strg</span><span class="s3">, </span><span class="s1">locn</span><span class="s3">, </span><span class="s2">&quot;matched token not at column %d&quot; </span><span class="s1">% n)</span>
    <span class="s3">return </span><span class="s1">verifyCol</span>

<span class="s3">def </span><span class="s1">replaceWith(replStr):</span>
    <span class="s5">&quot;&quot;&quot;Helper method for common parse actions that simply return 
    a literal value.  Especially useful when used with 
    :class:`transformString&lt;ParserElement.transformString&gt;` (). 
 
    Example:: 
 
        num = Word(nums).setParseAction(lambda toks: int(toks[0])) 
        na = oneOf(&quot;N/A NA&quot;).setParseAction(replaceWith(math.nan)) 
        term = na | num 
 
        OneOrMore(term).parseString(&quot;324 234 N/A 234&quot;) # -&gt; [324, 234, nan, 234] 
    &quot;&quot;&quot;</span>
    <span class="s3">return lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t: [replStr]</span>

<span class="s3">def </span><span class="s1">removeQuotes(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
    <span class="s5">&quot;&quot;&quot;Helper parse action for removing quotation marks from parsed 
    quoted strings. 
 
    Example:: 
 
        # by default, quotation marks are included in parsed results 
        quotedString.parseString(&quot;'Now is the Winter of our Discontent'&quot;) # -&gt; [&quot;'Now is the Winter of our Discontent'&quot;] 
 
        # use removeQuotes to strip quotation marks from parsed results 
        quotedString.setParseAction(removeQuotes) 
        quotedString.parseString(&quot;'Now is the Winter of our Discontent'&quot;) # -&gt; [&quot;Now is the Winter of our Discontent&quot;] 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">t[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>

<span class="s3">def </span><span class="s1">tokenMap(func</span><span class="s3">, </span><span class="s1">*args):</span>
    <span class="s5">&quot;&quot;&quot;Helper to define a parse action by mapping a function to all 
    elements of a ParseResults list. If any additional args are passed, 
    they are forwarded to the given function as additional arguments 
    after the token, as in 
    ``hex_integer = Word(hexnums).setParseAction(tokenMap(int, 16))``, 
    which will convert the parsed data to an integer using base 16. 
 
    Example (compare the last to example in :class:`ParserElement.transformString`:: 
 
        hex_ints = OneOrMore(Word(hexnums)).setParseAction(tokenMap(int, 16)) 
        hex_ints.runTests(''' 
            00 11 22 aa FF 0a 0d 1a 
            ''') 
 
        upperword = Word(alphas).setParseAction(tokenMap(str.upper)) 
        OneOrMore(upperword).runTests(''' 
            my kingdom for a horse 
            ''') 
 
        wd = Word(alphas).setParseAction(tokenMap(str.title)) 
        OneOrMore(wd).setParseAction(' '.join).runTests(''' 
            now is the winter of our discontent made glorious summer by this sun of york 
            ''') 
 
    prints:: 
 
        00 11 22 aa FF 0a 0d 1a 
        [0, 17, 34, 170, 255, 10, 13, 26] 
 
        my kingdom for a horse 
        ['MY', 'KINGDOM', 'FOR', 'A', 'HORSE'] 
 
        now is the winter of our discontent made glorious summer by this sun of york 
        ['Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York'] 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">pa(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s1">[func(tokn</span><span class="s3">, </span><span class="s1">*args) </span><span class="s3">for </span><span class="s1">tokn </span><span class="s3">in </span><span class="s1">t]</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">func_name = getattr(func</span><span class="s3">, </span><span class="s2">'__name__'</span><span class="s3">,</span>
                            <span class="s1">getattr(func</span><span class="s3">, </span><span class="s2">'__class__'</span><span class="s1">).__name__)</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s1">func_name = str(func)</span>
    <span class="s1">pa.__name__ = func_name</span>

    <span class="s3">return </span><span class="s1">pa</span>

<span class="s1">upcaseTokens = tokenMap(</span><span class="s3">lambda </span><span class="s1">t: _ustr(t).upper())</span>
<span class="s2">&quot;&quot;&quot;(Deprecated) Helper parse action to convert tokens to upper case. 
Deprecated in favor of :class:`pyparsing_common.upcaseTokens`&quot;&quot;&quot;</span>

<span class="s1">downcaseTokens = tokenMap(</span><span class="s3">lambda </span><span class="s1">t: _ustr(t).lower())</span>
<span class="s2">&quot;&quot;&quot;(Deprecated) Helper parse action to convert tokens to lower case. 
Deprecated in favor of :class:`pyparsing_common.downcaseTokens`&quot;&quot;&quot;</span>

<span class="s3">def </span><span class="s1">_makeTags(tagStr</span><span class="s3">, </span><span class="s1">xml</span><span class="s3">,</span>
              <span class="s1">suppress_LT=Suppress(</span><span class="s2">&quot;&lt;&quot;</span><span class="s1">)</span><span class="s3">,</span>
              <span class="s1">suppress_GT=Suppress(</span><span class="s2">&quot;&gt;&quot;</span><span class="s1">)):</span>
    <span class="s5">&quot;&quot;&quot;Internal helper to construct opening and closing tag expressions, given a tag name&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(tagStr</span><span class="s3">, </span><span class="s1">basestring):</span>
        <span class="s1">resname = tagStr</span>
        <span class="s1">tagStr = Keyword(tagStr</span><span class="s3">, </span><span class="s1">caseless=</span><span class="s3">not </span><span class="s1">xml)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">resname = tagStr.name</span>

    <span class="s1">tagAttrName = Word(alphas</span><span class="s3">, </span><span class="s1">alphanums + </span><span class="s2">&quot;_-:&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">xml:</span>
        <span class="s1">tagAttrValue = dblQuotedString.copy().setParseAction(removeQuotes)</span>
        <span class="s1">openTag = (suppress_LT</span>
                   <span class="s1">+ tagStr(</span><span class="s2">&quot;tag&quot;</span><span class="s1">)</span>
                   <span class="s1">+ Dict(ZeroOrMore(Group(tagAttrName + Suppress(</span><span class="s2">&quot;=&quot;</span><span class="s1">) + tagAttrValue)))</span>
                   <span class="s1">+ Optional(</span><span class="s2">&quot;/&quot;</span><span class="s3">, </span><span class="s1">default=[</span><span class="s3">False</span><span class="s1">])(</span><span class="s2">&quot;empty&quot;</span><span class="s1">).setParseAction(</span><span class="s3">lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t: t[</span><span class="s4">0</span><span class="s1">] == </span><span class="s2">'/'</span><span class="s1">)</span>
                   <span class="s1">+ suppress_GT)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">tagAttrValue = quotedString.copy().setParseAction(removeQuotes) | Word(printables</span><span class="s3">, </span><span class="s1">excludeChars=</span><span class="s2">&quot;&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">openTag = (suppress_LT</span>
                   <span class="s1">+ tagStr(</span><span class="s2">&quot;tag&quot;</span><span class="s1">)</span>
                   <span class="s1">+ Dict(ZeroOrMore(Group(tagAttrName.setParseAction(downcaseTokens)</span>
                                           <span class="s1">+ Optional(Suppress(</span><span class="s2">&quot;=&quot;</span><span class="s1">) + tagAttrValue))))</span>
                   <span class="s1">+ Optional(</span><span class="s2">&quot;/&quot;</span><span class="s3">, </span><span class="s1">default=[</span><span class="s3">False</span><span class="s1">])(</span><span class="s2">&quot;empty&quot;</span><span class="s1">).setParseAction(</span><span class="s3">lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t: t[</span><span class="s4">0</span><span class="s1">] == </span><span class="s2">'/'</span><span class="s1">)</span>
                   <span class="s1">+ suppress_GT)</span>
    <span class="s1">closeTag = Combine(_L(</span><span class="s2">&quot;&lt;/&quot;</span><span class="s1">) + tagStr + </span><span class="s2">&quot;&gt;&quot;</span><span class="s3">, </span><span class="s1">adjacent=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s1">openTag.setName(</span><span class="s2">&quot;&lt;%s&gt;&quot; </span><span class="s1">% resname)</span>
    <span class="s0"># add start&lt;tagname&gt; results name in parse action now that ungrouped names are not reported at two levels</span>
    <span class="s1">openTag.addParseAction(</span><span class="s3">lambda </span><span class="s1">t: t.__setitem__(</span><span class="s2">&quot;start&quot; </span><span class="s1">+ </span><span class="s2">&quot;&quot;</span><span class="s1">.join(resname.replace(</span><span class="s2">&quot;:&quot;</span><span class="s3">, </span><span class="s2">&quot; &quot;</span><span class="s1">).title().split())</span><span class="s3">, </span><span class="s1">t.copy()))</span>
    <span class="s1">closeTag = closeTag(</span><span class="s2">&quot;end&quot; </span><span class="s1">+ </span><span class="s2">&quot;&quot;</span><span class="s1">.join(resname.replace(</span><span class="s2">&quot;:&quot;</span><span class="s3">, </span><span class="s2">&quot; &quot;</span><span class="s1">).title().split())).setName(</span><span class="s2">&quot;&lt;/%s&gt;&quot; </span><span class="s1">% resname)</span>
    <span class="s1">openTag.tag = resname</span>
    <span class="s1">closeTag.tag = resname</span>
    <span class="s1">openTag.tag_body = SkipTo(closeTag())</span>
    <span class="s3">return </span><span class="s1">openTag</span><span class="s3">, </span><span class="s1">closeTag</span>

<span class="s3">def </span><span class="s1">makeHTMLTags(tagStr):</span>
    <span class="s5">&quot;&quot;&quot;Helper to construct opening and closing tag expressions for HTML, 
    given a tag name. Matches tags in either upper or lower case, 
    attributes with namespaces and with quoted or unquoted values. 
 
    Example:: 
 
        text = '&lt;td&gt;More info at the &lt;a href=&quot;https://github.com/pyparsing/pyparsing/wiki&quot;&gt;pyparsing&lt;/a&gt; wiki page&lt;/td&gt;' 
        # makeHTMLTags returns pyparsing expressions for the opening and 
        # closing tags as a 2-tuple 
        a, a_end = makeHTMLTags(&quot;A&quot;) 
        link_expr = a + SkipTo(a_end)(&quot;link_text&quot;) + a_end 
 
        for link in link_expr.searchString(text): 
            # attributes in the &lt;A&gt; tag (like &quot;href&quot; shown here) are 
            # also accessible as named results 
            print(link.link_text, '-&gt;', link.href) 
 
    prints:: 
 
        pyparsing -&gt; https://github.com/pyparsing/pyparsing/wiki 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_makeTags(tagStr</span><span class="s3">, False</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">makeXMLTags(tagStr):</span>
    <span class="s5">&quot;&quot;&quot;Helper to construct opening and closing tag expressions for XML, 
    given a tag name. Matches tags only in the given upper/lower case. 
 
    Example: similar to :class:`makeHTMLTags` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_makeTags(tagStr</span><span class="s3">, True</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">withAttribute(*args</span><span class="s3">, </span><span class="s1">**attrDict):</span>
    <span class="s5">&quot;&quot;&quot;Helper to create a validating parse action to be used with start 
    tags created with :class:`makeXMLTags` or 
    :class:`makeHTMLTags`. Use ``withAttribute`` to qualify 
    a starting tag with a required attribute value, to avoid false 
    matches on common tags such as ``&lt;TD&gt;`` or ``&lt;DIV&gt;``. 
 
    Call ``withAttribute`` with a series of attribute names and 
    values. Specify the list of filter attributes names and values as: 
 
     - keyword arguments, as in ``(align=&quot;right&quot;)``, or 
     - as an explicit dict with ``**`` operator, when an attribute 
       name is also a Python reserved word, as in ``**{&quot;class&quot;:&quot;Customer&quot;, &quot;align&quot;:&quot;right&quot;}`` 
     - a list of name-value tuples, as in ``((&quot;ns1:class&quot;, &quot;Customer&quot;), (&quot;ns2:align&quot;, &quot;right&quot;))`` 
 
    For attribute names with a namespace prefix, you must use the second 
    form.  Attribute names are matched insensitive to upper/lower case. 
 
    If just testing for ``class`` (with or without a namespace), use 
    :class:`withClass`. 
 
    To verify that the attribute exists, but without specifying a value, 
    pass ``withAttribute.ANY_VALUE`` as the value. 
 
    Example:: 
 
        html = ''' 
            &lt;div&gt; 
            Some text 
            &lt;div type=&quot;grid&quot;&gt;1 4 0 1 0&lt;/div&gt; 
            &lt;div type=&quot;graph&quot;&gt;1,3 2,3 1,1&lt;/div&gt; 
            &lt;div&gt;this has no type&lt;/div&gt; 
            &lt;/div&gt; 
 
        ''' 
        div,div_end = makeHTMLTags(&quot;div&quot;) 
 
        # only match div tag having a type attribute with value &quot;grid&quot; 
        div_grid = div().setParseAction(withAttribute(type=&quot;grid&quot;)) 
        grid_expr = div_grid + SkipTo(div | div_end)(&quot;body&quot;) 
        for grid_header in grid_expr.searchString(html): 
            print(grid_header.body) 
 
        # construct a match with any div tag having a type attribute, regardless of the value 
        div_any_type = div().setParseAction(withAttribute(type=withAttribute.ANY_VALUE)) 
        div_expr = div_any_type + SkipTo(div | div_end)(&quot;body&quot;) 
        for div_header in div_expr.searchString(html): 
            print(div_header.body) 
 
    prints:: 
 
        1 4 0 1 0 
 
        1 4 0 1 0 
        1,3 2,3 1,1 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">args:</span>
        <span class="s1">attrs = args[:]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">attrs = attrDict.items()</span>
    <span class="s1">attrs = [(k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">attrs]</span>
    <span class="s3">def </span><span class="s1">pa(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">tokens):</span>
        <span class="s3">for </span><span class="s1">attrName</span><span class="s3">, </span><span class="s1">attrValue </span><span class="s3">in </span><span class="s1">attrs:</span>
            <span class="s3">if </span><span class="s1">attrName </span><span class="s3">not in </span><span class="s1">tokens:</span>
                <span class="s3">raise </span><span class="s1">ParseException(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s2">&quot;no matching attribute &quot; </span><span class="s1">+ attrName)</span>
            <span class="s3">if </span><span class="s1">attrValue != withAttribute.ANY_VALUE </span><span class="s3">and </span><span class="s1">tokens[attrName] != attrValue:</span>
                <span class="s3">raise </span><span class="s1">ParseException(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s2">&quot;attribute '%s' has value '%s', must be '%s'&quot; </span><span class="s1">%</span>
                                            <span class="s1">(attrName</span><span class="s3">, </span><span class="s1">tokens[attrName]</span><span class="s3">, </span><span class="s1">attrValue))</span>
    <span class="s3">return </span><span class="s1">pa</span>
<span class="s1">withAttribute.ANY_VALUE = object()</span>

<span class="s3">def </span><span class="s1">withClass(classname</span><span class="s3">, </span><span class="s1">namespace=</span><span class="s2">''</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Simplified version of :class:`withAttribute` when 
    matching on a div class - made difficult because ``class`` is 
    a reserved word in Python. 
 
    Example:: 
 
        html = ''' 
            &lt;div&gt; 
            Some text 
            &lt;div class=&quot;grid&quot;&gt;1 4 0 1 0&lt;/div&gt; 
            &lt;div class=&quot;graph&quot;&gt;1,3 2,3 1,1&lt;/div&gt; 
            &lt;div&gt;this &amp;lt;div&amp;gt; has no class&lt;/div&gt; 
            &lt;/div&gt; 
 
        ''' 
        div,div_end = makeHTMLTags(&quot;div&quot;) 
        div_grid = div().setParseAction(withClass(&quot;grid&quot;)) 
 
        grid_expr = div_grid + SkipTo(div | div_end)(&quot;body&quot;) 
        for grid_header in grid_expr.searchString(html): 
            print(grid_header.body) 
 
        div_any_type = div().setParseAction(withClass(withAttribute.ANY_VALUE)) 
        div_expr = div_any_type + SkipTo(div | div_end)(&quot;body&quot;) 
        for div_header in div_expr.searchString(html): 
            print(div_header.body) 
 
    prints:: 
 
        1 4 0 1 0 
 
        1 4 0 1 0 
        1,3 2,3 1,1 
    &quot;&quot;&quot;</span>
    <span class="s1">classattr = </span><span class="s2">&quot;%s:class&quot; </span><span class="s1">% namespace </span><span class="s3">if </span><span class="s1">namespace </span><span class="s3">else </span><span class="s2">&quot;class&quot;</span>
    <span class="s3">return </span><span class="s1">withAttribute(**{classattr: classname})</span>

<span class="s1">opAssoc = SimpleNamespace()</span>
<span class="s1">opAssoc.LEFT = object()</span>
<span class="s1">opAssoc.RIGHT = object()</span>

<span class="s3">def </span><span class="s1">infixNotation(baseExpr</span><span class="s3">, </span><span class="s1">opList</span><span class="s3">, </span><span class="s1">lpar=Suppress(</span><span class="s2">'('</span><span class="s1">)</span><span class="s3">, </span><span class="s1">rpar=Suppress(</span><span class="s2">')'</span><span class="s1">)):</span>
    <span class="s5">&quot;&quot;&quot;Helper method for constructing grammars of expressions made up of 
    operators working in a precedence hierarchy.  Operators may be unary 
    or binary, left- or right-associative.  Parse actions can also be 
    attached to operator expressions. The generated parser will also 
    recognize the use of parentheses to override operator precedences 
    (see example below). 
 
    Note: if you define a deep operator list, you may see performance 
    issues when using infixNotation. See 
    :class:`ParserElement.enablePackrat` for a mechanism to potentially 
    improve your parser performance. 
 
    Parameters: 
     - baseExpr - expression representing the most basic element for the 
       nested 
     - opList - list of tuples, one for each operator precedence level 
       in the expression grammar; each tuple is of the form ``(opExpr, 
       numTerms, rightLeftAssoc, parseAction)``, where: 
 
       - opExpr is the pyparsing expression for the operator; may also 
         be a string, which will be converted to a Literal; if numTerms 
         is 3, opExpr is a tuple of two expressions, for the two 
         operators separating the 3 terms 
       - numTerms is the number of terms for this operator (must be 1, 
         2, or 3) 
       - rightLeftAssoc is the indicator whether the operator is right 
         or left associative, using the pyparsing-defined constants 
         ``opAssoc.RIGHT`` and ``opAssoc.LEFT``. 
       - parseAction is the parse action to be associated with 
         expressions matching this operator expression (the parse action 
         tuple member may be omitted); if the parse action is passed 
         a tuple or list of functions, this is equivalent to calling 
         ``setParseAction(*fn)`` 
         (:class:`ParserElement.setParseAction`) 
     - lpar - expression for matching left-parentheses 
       (default= ``Suppress('(')``) 
     - rpar - expression for matching right-parentheses 
       (default= ``Suppress(')')``) 
 
    Example:: 
 
        # simple example of four-function arithmetic with ints and 
        # variable names 
        integer = pyparsing_common.signed_integer 
        varname = pyparsing_common.identifier 
 
        arith_expr = infixNotation(integer | varname, 
            [ 
            ('-', 1, opAssoc.RIGHT), 
            (oneOf('* /'), 2, opAssoc.LEFT), 
            (oneOf('+ -'), 2, opAssoc.LEFT), 
            ]) 
 
        arith_expr.runTests(''' 
            5+3*6 
            (5+3)*6 
            -2--11 
            ''', fullDump=False) 
 
    prints:: 
 
        5+3*6 
        [[5, '+', [3, '*', 6]]] 
 
        (5+3)*6 
        [[[5, '+', 3], '*', 6]] 
 
        -2--11 
        [[['-', 2], '-', ['-', 11]]] 
    &quot;&quot;&quot;</span>
    <span class="s0"># captive version of FollowedBy that does not do parse actions or capture results names</span>
    <span class="s3">class </span><span class="s1">_FB(FollowedBy):</span>
        <span class="s3">def </span><span class="s1">parseImpl(self</span><span class="s3">, </span><span class="s1">instring</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">doActions=</span><span class="s3">True</span><span class="s1">):</span>
            <span class="s1">self.expr.tryParse(instring</span><span class="s3">, </span><span class="s1">loc)</span>
            <span class="s3">return </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">[]</span>

    <span class="s1">ret = Forward()</span>
    <span class="s1">lastExpr = baseExpr | (lpar + ret + rpar)</span>
    <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">operDef </span><span class="s3">in </span><span class="s1">enumerate(opList):</span>
        <span class="s1">opExpr</span><span class="s3">, </span><span class="s1">arity</span><span class="s3">, </span><span class="s1">rightLeftAssoc</span><span class="s3">, </span><span class="s1">pa = (operDef + (</span><span class="s3">None, </span><span class="s1">))[:</span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">termName = </span><span class="s2">&quot;%s term&quot; </span><span class="s1">% opExpr </span><span class="s3">if </span><span class="s1">arity &lt; </span><span class="s4">3 </span><span class="s3">else </span><span class="s2">&quot;%s%s term&quot; </span><span class="s1">% opExpr</span>
        <span class="s3">if </span><span class="s1">arity == </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">opExpr </span><span class="s3">is None or </span><span class="s1">len(opExpr) != </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;if numterms=3, opExpr must be a tuple or list of two expressions&quot;</span><span class="s1">)</span>
            <span class="s1">opExpr1</span><span class="s3">, </span><span class="s1">opExpr2 = opExpr</span>
        <span class="s1">thisExpr = Forward().setName(termName)</span>
        <span class="s3">if </span><span class="s1">rightLeftAssoc == opAssoc.LEFT:</span>
            <span class="s3">if </span><span class="s1">arity == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">matchExpr = _FB(lastExpr + opExpr) + Group(lastExpr + OneOrMore(opExpr))</span>
            <span class="s3">elif </span><span class="s1">arity == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">opExpr </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">matchExpr = _FB(lastExpr + opExpr + lastExpr) + Group(lastExpr + OneOrMore(opExpr + lastExpr))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">matchExpr = _FB(lastExpr + lastExpr) + Group(lastExpr + OneOrMore(lastExpr))</span>
            <span class="s3">elif </span><span class="s1">arity == </span><span class="s4">3</span><span class="s1">:</span>
                <span class="s1">matchExpr = (_FB(lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr)</span>
                             <span class="s1">+ Group(lastExpr + OneOrMore(opExpr1 + lastExpr + opExpr2 + lastExpr)))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;operator must be unary (1), binary (2), or ternary (3)&quot;</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">rightLeftAssoc == opAssoc.RIGHT:</span>
            <span class="s3">if </span><span class="s1">arity == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s0"># try to avoid LR with this extra test</span>
                <span class="s3">if not </span><span class="s1">isinstance(opExpr</span><span class="s3">, </span><span class="s1">Optional):</span>
                    <span class="s1">opExpr = Optional(opExpr)</span>
                <span class="s1">matchExpr = _FB(opExpr.expr + thisExpr) + Group(opExpr + thisExpr)</span>
            <span class="s3">elif </span><span class="s1">arity == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">opExpr </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">matchExpr = _FB(lastExpr + opExpr + thisExpr) + Group(lastExpr + OneOrMore(opExpr + thisExpr))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">matchExpr = _FB(lastExpr + thisExpr) + Group(lastExpr + OneOrMore(thisExpr))</span>
            <span class="s3">elif </span><span class="s1">arity == </span><span class="s4">3</span><span class="s1">:</span>
                <span class="s1">matchExpr = (_FB(lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr)</span>
                             <span class="s1">+ Group(lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;operator must be unary (1), binary (2), or ternary (3)&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;operator must indicate right or left associativity&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">pa:</span>
            <span class="s3">if </span><span class="s1">isinstance(pa</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list)):</span>
                <span class="s1">matchExpr.setParseAction(*pa)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">matchExpr.setParseAction(pa)</span>
        <span class="s1">thisExpr &lt;&lt;= (matchExpr.setName(termName) | lastExpr)</span>
        <span class="s1">lastExpr = thisExpr</span>
    <span class="s1">ret &lt;&lt;= lastExpr</span>
    <span class="s3">return </span><span class="s1">ret</span>

<span class="s1">operatorPrecedence = infixNotation</span>
<span class="s2">&quot;&quot;&quot;(Deprecated) Former name of :class:`infixNotation`, will be 
dropped in a future release.&quot;&quot;&quot;</span>

<span class="s1">dblQuotedString = Combine(Regex(</span><span class="s2">r'&quot;(?:[^&quot;\n\r\\]|(?:&quot;&quot;)|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*'</span><span class="s1">) + </span><span class="s2">'&quot;'</span><span class="s1">).setName(</span><span class="s2">&quot;string enclosed in double quotes&quot;</span><span class="s1">)</span>
<span class="s1">sglQuotedString = Combine(Regex(</span><span class="s2">r&quot;'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*&quot;</span><span class="s1">) + </span><span class="s2">&quot;'&quot;</span><span class="s1">).setName(</span><span class="s2">&quot;string enclosed in single quotes&quot;</span><span class="s1">)</span>
<span class="s1">quotedString = Combine(Regex(</span><span class="s2">r'&quot;(?:[^&quot;\n\r\\]|(?:&quot;&quot;)|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*'</span><span class="s1">) + </span><span class="s2">'&quot;'</span>
                       <span class="s1">| Regex(</span><span class="s2">r&quot;'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*&quot;</span><span class="s1">) + </span><span class="s2">&quot;'&quot;</span><span class="s1">).setName(</span><span class="s2">&quot;quotedString using single or double quotes&quot;</span><span class="s1">)</span>
<span class="s1">unicodeString = Combine(_L(</span><span class="s2">'u'</span><span class="s1">) + quotedString.copy()).setName(</span><span class="s2">&quot;unicode string literal&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">nestedExpr(opener=</span><span class="s2">&quot;(&quot;</span><span class="s3">, </span><span class="s1">closer=</span><span class="s2">&quot;)&quot;</span><span class="s3">, </span><span class="s1">content=</span><span class="s3">None, </span><span class="s1">ignoreExpr=quotedString.copy()):</span>
    <span class="s5">&quot;&quot;&quot;Helper method for defining nested lists enclosed in opening and 
    closing delimiters (&quot;(&quot; and &quot;)&quot; are the default). 
 
    Parameters: 
     - opener - opening character for a nested list 
       (default= ``&quot;(&quot;``); can also be a pyparsing expression 
     - closer - closing character for a nested list 
       (default= ``&quot;)&quot;``); can also be a pyparsing expression 
     - content - expression for items within the nested lists 
       (default= ``None``) 
     - ignoreExpr - expression for ignoring opening and closing 
       delimiters (default= :class:`quotedString`) 
 
    If an expression is not provided for the content argument, the 
    nested expression will capture all whitespace-delimited content 
    between delimiters as a list of separate values. 
 
    Use the ``ignoreExpr`` argument to define expressions that may 
    contain opening or closing characters that should not be treated as 
    opening or closing characters for nesting, such as quotedString or 
    a comment expression.  Specify multiple expressions using an 
    :class:`Or` or :class:`MatchFirst`. The default is 
    :class:`quotedString`, but if no expressions are to be ignored, then 
    pass ``None`` for this argument. 
 
    Example:: 
 
        data_type = oneOf(&quot;void int short long char float double&quot;) 
        decl_data_type = Combine(data_type + Optional(Word('*'))) 
        ident = Word(alphas+'_', alphanums+'_') 
        number = pyparsing_common.number 
        arg = Group(decl_data_type + ident) 
        LPAR, RPAR = map(Suppress, &quot;()&quot;) 
 
        code_body = nestedExpr('{', '}', ignoreExpr=(quotedString | cStyleComment)) 
 
        c_function = (decl_data_type(&quot;type&quot;) 
                      + ident(&quot;name&quot;) 
                      + LPAR + Optional(delimitedList(arg), [])(&quot;args&quot;) + RPAR 
                      + code_body(&quot;body&quot;)) 
        c_function.ignore(cStyleComment) 
 
        source_code = ''' 
            int is_odd(int x) { 
                return (x%2); 
            } 
 
            int dec_to_hex(char hchar) { 
                if (hchar &gt;= '0' &amp;&amp; hchar &lt;= '9') { 
                    return (ord(hchar)-ord('0')); 
                } else { 
                    return (10+ord(hchar)-ord('A')); 
                } 
            } 
        ''' 
        for func in c_function.searchString(source_code): 
            print(&quot;%(name)s (%(type)s) args: %(args)s&quot; % func) 
 
 
    prints:: 
 
        is_odd (int) args: [['int', 'x']] 
        dec_to_hex (int) args: [['char', 'hchar']] 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">opener == closer:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;opening and closing strings cannot be the same&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">content </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">isinstance(opener</span><span class="s3">, </span><span class="s1">basestring) </span><span class="s3">and </span><span class="s1">isinstance(closer</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s3">if </span><span class="s1">len(opener) == </span><span class="s4">1 </span><span class="s3">and </span><span class="s1">len(closer) == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">ignoreExpr </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">content = (Combine(OneOrMore(~ignoreExpr</span>
                                                 <span class="s1">+ CharsNotIn(opener</span>
                                                              <span class="s1">+ closer</span>
                                                              <span class="s1">+ ParserElement.DEFAULT_WHITE_CHARS</span><span class="s3">, </span><span class="s1">exact=</span><span class="s4">1</span><span class="s1">)</span>
                                                 <span class="s1">)</span>
                                       <span class="s1">).setParseAction(</span><span class="s3">lambda </span><span class="s1">t: t[</span><span class="s4">0</span><span class="s1">].strip()))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">content = (empty.copy() + CharsNotIn(opener</span>
                                                         <span class="s1">+ closer</span>
                                                         <span class="s1">+ ParserElement.DEFAULT_WHITE_CHARS</span>
                                                         <span class="s1">).setParseAction(</span><span class="s3">lambda </span><span class="s1">t: t[</span><span class="s4">0</span><span class="s1">].strip()))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">ignoreExpr </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">content = (Combine(OneOrMore(~ignoreExpr</span>
                                                 <span class="s1">+ ~Literal(opener)</span>
                                                 <span class="s1">+ ~Literal(closer)</span>
                                                 <span class="s1">+ CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS</span><span class="s3">, </span><span class="s1">exact=</span><span class="s4">1</span><span class="s1">))</span>
                                       <span class="s1">).setParseAction(</span><span class="s3">lambda </span><span class="s1">t: t[</span><span class="s4">0</span><span class="s1">].strip()))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">content = (Combine(OneOrMore(~Literal(opener)</span>
                                                 <span class="s1">+ ~Literal(closer)</span>
                                                 <span class="s1">+ CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS</span><span class="s3">, </span><span class="s1">exact=</span><span class="s4">1</span><span class="s1">))</span>
                                       <span class="s1">).setParseAction(</span><span class="s3">lambda </span><span class="s1">t: t[</span><span class="s4">0</span><span class="s1">].strip()))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;opening and closing arguments must be strings if no content expression is given&quot;</span><span class="s1">)</span>
    <span class="s1">ret = Forward()</span>
    <span class="s3">if </span><span class="s1">ignoreExpr </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">ret &lt;&lt;= Group(Suppress(opener) + ZeroOrMore(ignoreExpr | ret | content) + Suppress(closer))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">ret &lt;&lt;= Group(Suppress(opener) + ZeroOrMore(ret | content)  + Suppress(closer))</span>
    <span class="s1">ret.setName(</span><span class="s2">'nested %s%s expression' </span><span class="s1">% (opener</span><span class="s3">, </span><span class="s1">closer))</span>
    <span class="s3">return </span><span class="s1">ret</span>

<span class="s3">def </span><span class="s1">indentedBlock(blockStatementExpr</span><span class="s3">, </span><span class="s1">indentStack</span><span class="s3">, </span><span class="s1">indent=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Helper method for defining space-delimited indentation blocks, 
    such as those used to define block statements in Python source code. 
 
    Parameters: 
 
     - blockStatementExpr - expression defining syntax of statement that 
       is repeated within the indented block 
     - indentStack - list created by caller to manage indentation stack 
       (multiple statementWithIndentedBlock expressions within a single 
       grammar should share a common indentStack) 
     - indent - boolean indicating whether block must be indented beyond 
       the current level; set to False for block of left-most 
       statements (default= ``True``) 
 
    A valid block must contain at least one ``blockStatement``. 
 
    Example:: 
 
        data = ''' 
        def A(z): 
          A1 
          B = 100 
          G = A2 
          A2 
          A3 
        B 
        def BB(a,b,c): 
          BB1 
          def BBA(): 
            bba1 
            bba2 
            bba3 
        C 
        D 
        def spam(x,y): 
             def eggs(z): 
                 pass 
        ''' 
 
 
        indentStack = [1] 
        stmt = Forward() 
 
        identifier = Word(alphas, alphanums) 
        funcDecl = (&quot;def&quot; + identifier + Group(&quot;(&quot; + Optional(delimitedList(identifier)) + &quot;)&quot;) + &quot;:&quot;) 
        func_body = indentedBlock(stmt, indentStack) 
        funcDef = Group(funcDecl + func_body) 
 
        rvalue = Forward() 
        funcCall = Group(identifier + &quot;(&quot; + Optional(delimitedList(rvalue)) + &quot;)&quot;) 
        rvalue &lt;&lt; (funcCall | identifier | Word(nums)) 
        assignment = Group(identifier + &quot;=&quot; + rvalue) 
        stmt &lt;&lt; (funcDef | assignment | identifier) 
 
        module_body = OneOrMore(stmt) 
 
        parseTree = module_body.parseString(data) 
        parseTree.pprint() 
 
    prints:: 
 
        [['def', 
          'A', 
          ['(', 'z', ')'], 
          ':', 
          [['A1'], [['B', '=', '100']], [['G', '=', 'A2']], ['A2'], ['A3']]], 
         'B', 
         ['def', 
          'BB', 
          ['(', 'a', 'b', 'c', ')'], 
          ':', 
          [['BB1'], [['def', 'BBA', ['(', ')'], ':', [['bba1'], ['bba2'], ['bba3']]]]]], 
         'C', 
         'D', 
         ['def', 
          'spam', 
          ['(', 'x', 'y', ')'], 
          ':', 
          [[['def', 'eggs', ['(', 'z', ')'], ':', [['pass']]]]]]] 
    &quot;&quot;&quot;</span>
    <span class="s1">backup_stack = indentStack[:]</span>

    <span class="s3">def </span><span class="s1">reset_stack():</span>
        <span class="s1">indentStack[:] = backup_stack</span>

    <span class="s3">def </span><span class="s1">checkPeerIndent(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">if </span><span class="s1">l &gt;= len(s): </span><span class="s3">return</span>
        <span class="s1">curCol = col(l</span><span class="s3">, </span><span class="s1">s)</span>
        <span class="s3">if </span><span class="s1">curCol != indentStack[-</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">curCol &gt; indentStack[-</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s3">raise </span><span class="s1">ParseException(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s2">&quot;illegal nesting&quot;</span><span class="s1">)</span>
            <span class="s3">raise </span><span class="s1">ParseException(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s2">&quot;not a peer entry&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">checkSubIndent(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s1">curCol = col(l</span><span class="s3">, </span><span class="s1">s)</span>
        <span class="s3">if </span><span class="s1">curCol &gt; indentStack[-</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">indentStack.append(curCol)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ParseException(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s2">&quot;not a subentry&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">checkUnindent(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">if </span><span class="s1">l &gt;= len(s): </span><span class="s3">return</span>
        <span class="s1">curCol = col(l</span><span class="s3">, </span><span class="s1">s)</span>
        <span class="s3">if not</span><span class="s1">(indentStack </span><span class="s3">and </span><span class="s1">curCol </span><span class="s3">in </span><span class="s1">indentStack):</span>
            <span class="s3">raise </span><span class="s1">ParseException(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s2">&quot;not an unindent&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">curCol &lt; indentStack[-</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">indentStack.pop()</span>

    <span class="s1">NL = OneOrMore(LineEnd().setWhitespaceChars(</span><span class="s2">&quot;</span><span class="s3">\t </span><span class="s2">&quot;</span><span class="s1">).suppress()</span><span class="s3">, </span><span class="s1">stopOn=StringEnd())</span>
    <span class="s1">INDENT = (Empty() + Empty().setParseAction(checkSubIndent)).setName(</span><span class="s2">'INDENT'</span><span class="s1">)</span>
    <span class="s1">PEER   = Empty().setParseAction(checkPeerIndent).setName(</span><span class="s2">''</span><span class="s1">)</span>
    <span class="s1">UNDENT = Empty().setParseAction(checkUnindent).setName(</span><span class="s2">'UNINDENT'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">indent:</span>
        <span class="s1">smExpr = Group(Optional(NL)</span>
                       <span class="s1">+ INDENT</span>
                       <span class="s1">+ OneOrMore(PEER + Group(blockStatementExpr) + Optional(NL)</span><span class="s3">, </span><span class="s1">stopOn=StringEnd())</span>
                       <span class="s1">+ UNDENT)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">smExpr = Group(Optional(NL)</span>
                       <span class="s1">+ OneOrMore(PEER + Group(blockStatementExpr) + Optional(NL)</span><span class="s3">, </span><span class="s1">stopOn=StringEnd())</span>
                       <span class="s1">+ UNDENT)</span>
    <span class="s1">smExpr.setFailAction(</span><span class="s3">lambda </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d: reset_stack())</span>
    <span class="s1">blockStatementExpr.ignore(_bslash + LineEnd())</span>
    <span class="s3">return </span><span class="s1">smExpr.setName(</span><span class="s2">'indented block'</span><span class="s1">)</span>

<span class="s1">alphas8bit = srange(</span><span class="s2">r&quot;[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]&quot;</span><span class="s1">)</span>
<span class="s1">punc8bit = srange(</span><span class="s2">r&quot;[\0xa1-\0xbf\0xd7\0xf7]&quot;</span><span class="s1">)</span>

<span class="s1">anyOpenTag</span><span class="s3">, </span><span class="s1">anyCloseTag = makeHTMLTags(Word(alphas</span><span class="s3">, </span><span class="s1">alphanums + </span><span class="s2">&quot;_:&quot;</span><span class="s1">).setName(</span><span class="s2">'any tag'</span><span class="s1">))</span>
<span class="s1">_htmlEntityMap = dict(zip(</span><span class="s2">&quot;gt lt amp nbsp quot apos&quot;</span><span class="s1">.split()</span><span class="s3">, </span><span class="s2">'&gt;&lt;&amp; &quot;</span><span class="s3">\'</span><span class="s2">'</span><span class="s1">))</span>
<span class="s1">commonHTMLEntity = Regex(</span><span class="s2">'&amp;(?P&lt;entity&gt;' </span><span class="s1">+ </span><span class="s2">'|'</span><span class="s1">.join(_htmlEntityMap.keys()) +</span><span class="s2">&quot;);&quot;</span><span class="s1">).setName(</span><span class="s2">&quot;common HTML entity&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">replaceHTMLEntity(t):</span>
    <span class="s5">&quot;&quot;&quot;Helper parser action to replace common HTML entities with their special characters&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_htmlEntityMap.get(t.entity)</span>

<span class="s0"># it's easy to get these comment structures wrong - they're very common, so may as well make them available</span>
<span class="s1">cStyleComment = Combine(Regex(</span><span class="s2">r&quot;/\*(?:[^*]|\*(?!/))*&quot;</span><span class="s1">) + </span><span class="s2">'*/'</span><span class="s1">).setName(</span><span class="s2">&quot;C style comment&quot;</span><span class="s1">)</span>
<span class="s2">&quot;Comment of the form ``/* ... */``&quot;</span>

<span class="s1">htmlComment = Regex(</span><span class="s2">r&quot;&lt;!--[\s\S]*?--&gt;&quot;</span><span class="s1">).setName(</span><span class="s2">&quot;HTML comment&quot;</span><span class="s1">)</span>
<span class="s2">&quot;Comment of the form ``&lt;!-- ... --&gt;``&quot;</span>

<span class="s1">restOfLine = Regex(</span><span class="s2">r&quot;.*&quot;</span><span class="s1">).leaveWhitespace().setName(</span><span class="s2">&quot;rest of line&quot;</span><span class="s1">)</span>
<span class="s1">dblSlashComment = Regex(</span><span class="s2">r&quot;//(?:\\\n|[^\n])*&quot;</span><span class="s1">).setName(</span><span class="s2">&quot;// comment&quot;</span><span class="s1">)</span>
<span class="s2">&quot;Comment of the form ``// ... (to end of line)``&quot;</span>

<span class="s1">cppStyleComment = Combine(Regex(</span><span class="s2">r&quot;/\*(?:[^*]|\*(?!/))*&quot;</span><span class="s1">) + </span><span class="s2">'*/' </span><span class="s1">| dblSlashComment).setName(</span><span class="s2">&quot;C++ style comment&quot;</span><span class="s1">)</span>
<span class="s2">&quot;Comment of either form :class:`cStyleComment` or :class:`dblSlashComment`&quot;</span>

<span class="s1">javaStyleComment = cppStyleComment</span>
<span class="s2">&quot;Same as :class:`cppStyleComment`&quot;</span>

<span class="s1">pythonStyleComment = Regex(</span><span class="s2">r&quot;#.*&quot;</span><span class="s1">).setName(</span><span class="s2">&quot;Python style comment&quot;</span><span class="s1">)</span>
<span class="s2">&quot;Comment of the form ``# ... (to end of line)``&quot;</span>

<span class="s1">_commasepitem = Combine(OneOrMore(Word(printables</span><span class="s3">, </span><span class="s1">excludeChars=</span><span class="s2">','</span><span class="s1">)</span>
                                  <span class="s1">+ Optional(Word(</span><span class="s2">&quot; </span><span class="s3">\t</span><span class="s2">&quot;</span><span class="s1">)</span>
                                             <span class="s1">+ ~Literal(</span><span class="s2">&quot;,&quot;</span><span class="s1">) + ~LineEnd()))).streamline().setName(</span><span class="s2">&quot;commaItem&quot;</span><span class="s1">)</span>
<span class="s1">commaSeparatedList = delimitedList(Optional(quotedString.copy() | _commasepitem</span><span class="s3">, </span><span class="s1">default=</span><span class="s2">&quot;&quot;</span><span class="s1">)).setName(</span><span class="s2">&quot;commaSeparatedList&quot;</span><span class="s1">)</span>
<span class="s2">&quot;&quot;&quot;(Deprecated) Predefined expression of 1 or more printable words or 
quoted strings, separated by commas. 
 
This expression is deprecated in favor of :class:`pyparsing_common.comma_separated_list`. 
&quot;&quot;&quot;</span>

<span class="s0"># some other useful expressions - using lower-case class name since we are really using this as a namespace</span>
<span class="s3">class </span><span class="s1">pyparsing_common:</span>
    <span class="s5">&quot;&quot;&quot;Here are some common low-level expressions that may be useful in 
    jump-starting parser development: 
 
     - numeric forms (:class:`integers&lt;integer&gt;`, :class:`reals&lt;real&gt;`, 
       :class:`scientific notation&lt;sci_real&gt;`) 
     - common :class:`programming identifiers&lt;identifier&gt;` 
     - network addresses (:class:`MAC&lt;mac_address&gt;`, 
       :class:`IPv4&lt;ipv4_address&gt;`, :class:`IPv6&lt;ipv6_address&gt;`) 
     - ISO8601 :class:`dates&lt;iso8601_date&gt;` and 
       :class:`datetime&lt;iso8601_datetime&gt;` 
     - :class:`UUID&lt;uuid&gt;` 
     - :class:`comma-separated list&lt;comma_separated_list&gt;` 
 
    Parse actions: 
 
     - :class:`convertToInteger` 
     - :class:`convertToFloat` 
     - :class:`convertToDate` 
     - :class:`convertToDatetime` 
     - :class:`stripHTMLTags` 
     - :class:`upcaseTokens` 
     - :class:`downcaseTokens` 
 
    Example:: 
 
        pyparsing_common.number.runTests(''' 
            # any int or real number, returned as the appropriate type 
            100 
            -100 
            +100 
            3.14159 
            6.02e23 
            1e-12 
            ''') 
 
        pyparsing_common.fnumber.runTests(''' 
            # any int or real number, returned as float 
            100 
            -100 
            +100 
            3.14159 
            6.02e23 
            1e-12 
            ''') 
 
        pyparsing_common.hex_integer.runTests(''' 
            # hex numbers 
            100 
            FF 
            ''') 
 
        pyparsing_common.fraction.runTests(''' 
            # fractions 
            1/2 
            -3/4 
            ''') 
 
        pyparsing_common.mixed_integer.runTests(''' 
            # mixed fractions 
            1 
            1/2 
            -3/4 
            1-3/4 
            ''') 
 
        import uuid 
        pyparsing_common.uuid.setParseAction(tokenMap(uuid.UUID)) 
        pyparsing_common.uuid.runTests(''' 
            # uuid 
            12345678-1234-5678-1234-567812345678 
            ''') 
 
    prints:: 
 
        # any int or real number, returned as the appropriate type 
        100 
        [100] 
 
        -100 
        [-100] 
 
        +100 
        [100] 
 
        3.14159 
        [3.14159] 
 
        6.02e23 
        [6.02e+23] 
 
        1e-12 
        [1e-12] 
 
        # any int or real number, returned as float 
        100 
        [100.0] 
 
        -100 
        [-100.0] 
 
        +100 
        [100.0] 
 
        3.14159 
        [3.14159] 
 
        6.02e23 
        [6.02e+23] 
 
        1e-12 
        [1e-12] 
 
        # hex numbers 
        100 
        [256] 
 
        FF 
        [255] 
 
        # fractions 
        1/2 
        [0.5] 
 
        -3/4 
        [-0.75] 
 
        # mixed fractions 
        1 
        [1] 
 
        1/2 
        [0.5] 
 
        -3/4 
        [-0.75] 
 
        1-3/4 
        [1.75] 
 
        # uuid 
        12345678-1234-5678-1234-567812345678 
        [UUID('12345678-1234-5678-1234-567812345678')] 
    &quot;&quot;&quot;</span>

    <span class="s1">convertToInteger = tokenMap(int)</span>
    <span class="s2">&quot;&quot;&quot; 
    Parse action for converting parsed integers to Python int 
    &quot;&quot;&quot;</span>

    <span class="s1">convertToFloat = tokenMap(float)</span>
    <span class="s2">&quot;&quot;&quot; 
    Parse action for converting parsed numbers to Python float 
    &quot;&quot;&quot;</span>

    <span class="s1">integer = Word(nums).setName(</span><span class="s2">&quot;integer&quot;</span><span class="s1">).setParseAction(convertToInteger)</span>
    <span class="s2">&quot;&quot;&quot;expression that parses an unsigned integer, returns an int&quot;&quot;&quot;</span>

    <span class="s1">hex_integer = Word(hexnums).setName(</span><span class="s2">&quot;hex integer&quot;</span><span class="s1">).setParseAction(tokenMap(int</span><span class="s3">, </span><span class="s4">16</span><span class="s1">))</span>
    <span class="s2">&quot;&quot;&quot;expression that parses a hexadecimal integer, returns an int&quot;&quot;&quot;</span>

    <span class="s1">signed_integer = Regex(</span><span class="s2">r'[+-]?\d+'</span><span class="s1">).setName(</span><span class="s2">&quot;signed integer&quot;</span><span class="s1">).setParseAction(convertToInteger)</span>
    <span class="s2">&quot;&quot;&quot;expression that parses an integer with optional leading sign, returns an int&quot;&quot;&quot;</span>

    <span class="s1">fraction = (signed_integer().setParseAction(convertToFloat) + </span><span class="s2">'/' </span><span class="s1">+ signed_integer().setParseAction(convertToFloat)).setName(</span><span class="s2">&quot;fraction&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;fractional expression of an integer divided by an integer, returns a float&quot;&quot;&quot;</span>
    <span class="s1">fraction.addParseAction(</span><span class="s3">lambda </span><span class="s1">t: t[</span><span class="s4">0</span><span class="s1">]/t[-</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s1">mixed_integer = (fraction | signed_integer + Optional(Optional(</span><span class="s2">'-'</span><span class="s1">).suppress() + fraction)).setName(</span><span class="s2">&quot;fraction or mixed integer-fraction&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;mixed integer of the form 'integer - fraction', with optional leading integer, returns float&quot;&quot;&quot;</span>
    <span class="s1">mixed_integer.addParseAction(sum)</span>

    <span class="s1">real = Regex(</span><span class="s2">r'[+-]?(?:\d+\.\d*|\.\d+)'</span><span class="s1">).setName(</span><span class="s2">&quot;real number&quot;</span><span class="s1">).setParseAction(convertToFloat)</span>
    <span class="s2">&quot;&quot;&quot;expression that parses a floating point number and returns a float&quot;&quot;&quot;</span>

    <span class="s1">sci_real = Regex(</span><span class="s2">r'[+-]?(?:\d+(?:[eE][+-]?\d+)|(?:\d+\.\d*|\.\d+)(?:[eE][+-]?\d+)?)'</span><span class="s1">).setName(</span><span class="s2">&quot;real number with scientific notation&quot;</span><span class="s1">).setParseAction(convertToFloat)</span>
    <span class="s2">&quot;&quot;&quot;expression that parses a floating point number with optional 
    scientific notation and returns a float&quot;&quot;&quot;</span>

    <span class="s0"># streamlining this expression makes the docs nicer-looking</span>
    <span class="s1">number = (sci_real | real | signed_integer).streamline()</span>
    <span class="s2">&quot;&quot;&quot;any numeric expression, returns the corresponding Python type&quot;&quot;&quot;</span>

    <span class="s1">fnumber = Regex(</span><span class="s2">r'[+-]?\d+\.?\d*([eE][+-]?\d+)?'</span><span class="s1">).setName(</span><span class="s2">&quot;fnumber&quot;</span><span class="s1">).setParseAction(convertToFloat)</span>
    <span class="s2">&quot;&quot;&quot;any int or real number, returned as float&quot;&quot;&quot;</span>

    <span class="s1">identifier = Word(alphas + </span><span class="s2">'_'</span><span class="s3">, </span><span class="s1">alphanums + </span><span class="s2">'_'</span><span class="s1">).setName(</span><span class="s2">&quot;identifier&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;typical code identifier (leading alpha or '_', followed by 0 or more alphas, nums, or '_')&quot;&quot;&quot;</span>

    <span class="s1">ipv4_address = Regex(</span><span class="s2">r'(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})){3}'</span><span class="s1">).setName(</span><span class="s2">&quot;IPv4 address&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;IPv4 address (``0.0.0.0 - 255.255.255.255``)&quot;</span>

    <span class="s1">_ipv6_part = Regex(</span><span class="s2">r'[0-9a-fA-F]{1,4}'</span><span class="s1">).setName(</span><span class="s2">&quot;hex_integer&quot;</span><span class="s1">)</span>
    <span class="s1">_full_ipv6_address = (_ipv6_part + (</span><span class="s2">':' </span><span class="s1">+ _ipv6_part) * </span><span class="s4">7</span><span class="s1">).setName(</span><span class="s2">&quot;full IPv6 address&quot;</span><span class="s1">)</span>
    <span class="s1">_short_ipv6_address = (Optional(_ipv6_part + (</span><span class="s2">':' </span><span class="s1">+ _ipv6_part) * (</span><span class="s4">0</span><span class="s3">, </span><span class="s4">6</span><span class="s1">))</span>
                           <span class="s1">+ </span><span class="s2">&quot;::&quot;</span>
                           <span class="s1">+ Optional(_ipv6_part + (</span><span class="s2">':' </span><span class="s1">+ _ipv6_part) * (</span><span class="s4">0</span><span class="s3">, </span><span class="s4">6</span><span class="s1">))</span>
                           <span class="s1">).setName(</span><span class="s2">&quot;short IPv6 address&quot;</span><span class="s1">)</span>
    <span class="s1">_short_ipv6_address.addCondition(</span><span class="s3">lambda </span><span class="s1">t: sum(</span><span class="s4">1 </span><span class="s3">for </span><span class="s1">tt </span><span class="s3">in </span><span class="s1">t </span><span class="s3">if </span><span class="s1">pyparsing_common._ipv6_part.matches(tt)) &lt; </span><span class="s4">8</span><span class="s1">)</span>
    <span class="s1">_mixed_ipv6_address = (</span><span class="s2">&quot;::ffff:&quot; </span><span class="s1">+ ipv4_address).setName(</span><span class="s2">&quot;mixed IPv6 address&quot;</span><span class="s1">)</span>
    <span class="s1">ipv6_address = Combine((_full_ipv6_address | _mixed_ipv6_address | _short_ipv6_address).setName(</span><span class="s2">&quot;IPv6 address&quot;</span><span class="s1">)).setName(</span><span class="s2">&quot;IPv6 address&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;IPv6 address (long, short, or mixed form)&quot;</span>

    <span class="s1">mac_address = Regex(</span><span class="s2">r'[0-9a-fA-F]{2}([:.-])[0-9a-fA-F]{2}(?:\1[0-9a-fA-F]{2}){4}'</span><span class="s1">).setName(</span><span class="s2">&quot;MAC address&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;MAC address xx:xx:xx:xx:xx (may also have '-' or '.' delimiters)&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">convertToDate(fmt=</span><span class="s2">&quot;%Y-%m-%d&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Helper to create a parse action for converting parsed date string to Python datetime.date 
 
        Params - 
         - fmt - format to be passed to datetime.strptime (default= ``&quot;%Y-%m-%d&quot;``) 
 
        Example:: 
 
            date_expr = pyparsing_common.iso8601_date.copy() 
            date_expr.setParseAction(pyparsing_common.convertToDate()) 
            print(date_expr.parseString(&quot;1999-12-31&quot;)) 
 
        prints:: 
 
            [datetime.date(1999, 12, 31)] 
        &quot;&quot;&quot;</span>
        <span class="s3">def </span><span class="s1">cvt_fn(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">datetime.strptime(t[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">fmt).date()</span>
            <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">ve:</span>
                <span class="s3">raise </span><span class="s1">ParseException(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">str(ve))</span>
        <span class="s3">return </span><span class="s1">cvt_fn</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">convertToDatetime(fmt=</span><span class="s2">&quot;%Y-%m-%dT%H:%M:%S.%f&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Helper to create a parse action for converting parsed 
        datetime string to Python datetime.datetime 
 
        Params - 
         - fmt - format to be passed to datetime.strptime (default= ``&quot;%Y-%m-%dT%H:%M:%S.%f&quot;``) 
 
        Example:: 
 
            dt_expr = pyparsing_common.iso8601_datetime.copy() 
            dt_expr.setParseAction(pyparsing_common.convertToDatetime()) 
            print(dt_expr.parseString(&quot;1999-12-31T23:59:59.999&quot;)) 
 
        prints:: 
 
            [datetime.datetime(1999, 12, 31, 23, 59, 59, 999000)] 
        &quot;&quot;&quot;</span>
        <span class="s3">def </span><span class="s1">cvt_fn(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">datetime.strptime(t[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">fmt)</span>
            <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">ve:</span>
                <span class="s3">raise </span><span class="s1">ParseException(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">str(ve))</span>
        <span class="s3">return </span><span class="s1">cvt_fn</span>

    <span class="s1">iso8601_date = Regex(</span><span class="s2">r'(?P&lt;year&gt;\d{4})(?:-(?P&lt;month&gt;\d\d)(?:-(?P&lt;day&gt;\d\d))?)?'</span><span class="s1">).setName(</span><span class="s2">&quot;ISO8601 date&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;ISO8601 date (``yyyy-mm-dd``)&quot;</span>

    <span class="s1">iso8601_datetime = Regex(</span><span class="s2">r'(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d\d)-(?P&lt;day&gt;\d\d)[T ](?P&lt;hour&gt;\d\d):(?P&lt;minute&gt;\d\d)(:(?P&lt;second&gt;\d\d(\.\d*)?)?)?(?P&lt;tz&gt;Z|[+-]\d\d:?\d\d)?'</span><span class="s1">).setName(</span><span class="s2">&quot;ISO8601 datetime&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;ISO8601 datetime (``yyyy-mm-ddThh:mm:ss.s(Z|+-00:00)``) - trailing seconds, milliseconds, and timezone optional; accepts separating ``'T'`` or ``' '``&quot;</span>

    <span class="s1">uuid = Regex(</span><span class="s2">r'[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}'</span><span class="s1">).setName(</span><span class="s2">&quot;UUID&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;UUID (``xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx``)&quot;</span>

    <span class="s1">_html_stripper = anyOpenTag.suppress() | anyCloseTag.suppress()</span>
    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">stripHTMLTags(s</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">tokens):</span>
        <span class="s5">&quot;&quot;&quot;Parse action to remove HTML tags from web page HTML source 
 
        Example:: 
 
            # strip HTML links from normal text 
            text = '&lt;td&gt;More info at the &lt;a href=&quot;https://github.com/pyparsing/pyparsing/wiki&quot;&gt;pyparsing&lt;/a&gt; wiki page&lt;/td&gt;' 
            td, td_end = makeHTMLTags(&quot;TD&quot;) 
            table_text = td + SkipTo(td_end).setParseAction(pyparsing_common.stripHTMLTags)(&quot;body&quot;) + td_end 
            print(table_text.parseString(text).body) 
 
        Prints:: 
 
            More info at the pyparsing wiki page 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">pyparsing_common._html_stripper.transformString(tokens[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s1">_commasepitem = Combine(OneOrMore(~Literal(</span><span class="s2">&quot;,&quot;</span><span class="s1">)</span>
                                      <span class="s1">+ ~LineEnd()</span>
                                      <span class="s1">+ Word(printables</span><span class="s3">, </span><span class="s1">excludeChars=</span><span class="s2">','</span><span class="s1">)</span>
                                      <span class="s1">+ Optional(White(</span><span class="s2">&quot; </span><span class="s3">\t</span><span class="s2">&quot;</span><span class="s1">)))).streamline().setName(</span><span class="s2">&quot;commaItem&quot;</span><span class="s1">)</span>
    <span class="s1">comma_separated_list = delimitedList(Optional(quotedString.copy()</span>
                                                  <span class="s1">| _commasepitem</span><span class="s3">, </span><span class="s1">default=</span><span class="s2">''</span><span class="s1">)</span>
                                         <span class="s1">).setName(</span><span class="s2">&quot;comma separated list&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;Predefined expression of 1 or more printable words or quoted strings, separated by commas.&quot;&quot;&quot;</span>

    <span class="s1">upcaseTokens = staticmethod(tokenMap(</span><span class="s3">lambda </span><span class="s1">t: _ustr(t).upper()))</span>
    <span class="s2">&quot;&quot;&quot;Parse action to convert tokens to upper case.&quot;&quot;&quot;</span>

    <span class="s1">downcaseTokens = staticmethod(tokenMap(</span><span class="s3">lambda </span><span class="s1">t: _ustr(t).lower()))</span>
    <span class="s2">&quot;&quot;&quot;Parse action to convert tokens to lower case.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">_lazyclassproperty(object):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">fn):</span>
        <span class="s1">self.fn = fn</span>
        <span class="s1">self.__doc__ = fn.__doc__</span>
        <span class="s1">self.__name__ = fn.__name__</span>

    <span class="s3">def </span><span class="s1">__get__(self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">cls):</span>
        <span class="s3">if </span><span class="s1">cls </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">cls = type(obj)</span>
        <span class="s3">if not </span><span class="s1">hasattr(cls</span><span class="s3">, </span><span class="s2">'_intern'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">any(cls._intern </span><span class="s3">is </span><span class="s1">getattr(superclass</span><span class="s3">, </span><span class="s2">'_intern'</span><span class="s3">, </span><span class="s1">[])</span>
                                              <span class="s3">for </span><span class="s1">superclass </span><span class="s3">in </span><span class="s1">cls.__mro__[</span><span class="s4">1</span><span class="s1">:]):</span>
            <span class="s1">cls._intern = {}</span>
        <span class="s1">attrname = self.fn.__name__</span>
        <span class="s3">if </span><span class="s1">attrname </span><span class="s3">not in </span><span class="s1">cls._intern:</span>
            <span class="s1">cls._intern[attrname] = self.fn(cls)</span>
        <span class="s3">return </span><span class="s1">cls._intern[attrname]</span>


<span class="s3">class </span><span class="s1">unicode_set(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    A set of Unicode characters, for language-specific strings for 
    ``alphas``, ``nums``, ``alphanums``, and ``printables``. 
    A unicode_set is defined by a list of ranges in the Unicode character 
    set, in a class attribute ``_ranges``, such as:: 
 
        _ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),] 
 
    A unicode set can also be defined using multiple inheritance of other unicode sets:: 
 
        class CJK(Chinese, Japanese, Korean): 
            pass 
    &quot;&quot;&quot;</span>
    <span class="s1">_ranges = []</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_get_chars_for_ranges(cls):</span>
        <span class="s1">ret = []</span>
        <span class="s3">for </span><span class="s1">cc </span><span class="s3">in </span><span class="s1">cls.__mro__:</span>
            <span class="s3">if </span><span class="s1">cc </span><span class="s3">is </span><span class="s1">unicode_set:</span>
                <span class="s3">break</span>
            <span class="s3">for </span><span class="s1">rr </span><span class="s3">in </span><span class="s1">cc._ranges:</span>
                <span class="s1">ret.extend(range(rr[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">rr[-</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s3">return </span><span class="s1">[unichr(c) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">sorted(set(ret))]</span>

    <span class="s1">@_lazyclassproperty</span>
    <span class="s3">def </span><span class="s1">printables(cls):</span>
        <span class="s5">&quot;all non-whitespace characters in this range&quot;</span>
        <span class="s3">return </span><span class="s2">u''</span><span class="s1">.join(filterfalse(unicode.isspace</span><span class="s3">, </span><span class="s1">cls._get_chars_for_ranges()))</span>

    <span class="s1">@_lazyclassproperty</span>
    <span class="s3">def </span><span class="s1">alphas(cls):</span>
        <span class="s5">&quot;all alphabetic characters in this range&quot;</span>
        <span class="s3">return </span><span class="s2">u''</span><span class="s1">.join(filter(unicode.isalpha</span><span class="s3">, </span><span class="s1">cls._get_chars_for_ranges()))</span>

    <span class="s1">@_lazyclassproperty</span>
    <span class="s3">def </span><span class="s1">nums(cls):</span>
        <span class="s5">&quot;all numeric digit characters in this range&quot;</span>
        <span class="s3">return </span><span class="s2">u''</span><span class="s1">.join(filter(unicode.isdigit</span><span class="s3">, </span><span class="s1">cls._get_chars_for_ranges()))</span>

    <span class="s1">@_lazyclassproperty</span>
    <span class="s3">def </span><span class="s1">alphanums(cls):</span>
        <span class="s5">&quot;all alphanumeric characters in this range&quot;</span>
        <span class="s3">return </span><span class="s1">cls.alphas + cls.nums</span>


<span class="s3">class </span><span class="s1">pyparsing_unicode(unicode_set):</span>
    <span class="s5">&quot;&quot;&quot; 
    A namespace class for defining common language unicode_sets. 
    &quot;&quot;&quot;</span>
    <span class="s1">_ranges = [(</span><span class="s4">32</span><span class="s3">, </span><span class="s1">sys.maxunicode)]</span>

    <span class="s3">class </span><span class="s1">Latin1(unicode_set):</span>
        <span class="s5">&quot;Unicode set for Latin-1 Unicode Character Range&quot;</span>
        <span class="s1">_ranges = [(</span><span class="s4">0x0020</span><span class="s3">, </span><span class="s4">0x007e</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x00a0</span><span class="s3">, </span><span class="s4">0x00ff</span><span class="s1">)</span><span class="s3">,</span><span class="s1">]</span>

    <span class="s3">class </span><span class="s1">LatinA(unicode_set):</span>
        <span class="s5">&quot;Unicode set for Latin-A Unicode Character Range&quot;</span>
        <span class="s1">_ranges = [(</span><span class="s4">0x0100</span><span class="s3">, </span><span class="s4">0x017f</span><span class="s1">)</span><span class="s3">,</span><span class="s1">]</span>

    <span class="s3">class </span><span class="s1">LatinB(unicode_set):</span>
        <span class="s5">&quot;Unicode set for Latin-B Unicode Character Range&quot;</span>
        <span class="s1">_ranges = [(</span><span class="s4">0x0180</span><span class="s3">, </span><span class="s4">0x024f</span><span class="s1">)</span><span class="s3">,</span><span class="s1">]</span>

    <span class="s3">class </span><span class="s1">Greek(unicode_set):</span>
        <span class="s5">&quot;Unicode set for Greek Unicode Character Ranges&quot;</span>
        <span class="s1">_ranges = [</span>
            <span class="s1">(</span><span class="s4">0x0370</span><span class="s3">, </span><span class="s4">0x03ff</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1f00</span><span class="s3">, </span><span class="s4">0x1f15</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1f18</span><span class="s3">, </span><span class="s4">0x1f1d</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1f20</span><span class="s3">, </span><span class="s4">0x1f45</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1f48</span><span class="s3">, </span><span class="s4">0x1f4d</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0x1f50</span><span class="s3">, </span><span class="s4">0x1f57</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1f59</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1f5b</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1f5d</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1f5f</span><span class="s3">, </span><span class="s4">0x1f7d</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1f80</span><span class="s3">, </span><span class="s4">0x1fb4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1fb6</span><span class="s3">, </span><span class="s4">0x1fc4</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0x1fc6</span><span class="s3">, </span><span class="s4">0x1fd3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1fd6</span><span class="s3">, </span><span class="s4">0x1fdb</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1fdd</span><span class="s3">, </span><span class="s4">0x1fef</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1ff2</span><span class="s3">, </span><span class="s4">0x1ff4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1ff6</span><span class="s3">, </span><span class="s4">0x1ffe</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">]</span>

    <span class="s3">class </span><span class="s1">Cyrillic(unicode_set):</span>
        <span class="s5">&quot;Unicode set for Cyrillic Unicode Character Range&quot;</span>
        <span class="s1">_ranges = [(</span><span class="s4">0x0400</span><span class="s3">, </span><span class="s4">0x04ff</span><span class="s1">)]</span>

    <span class="s3">class </span><span class="s1">Chinese(unicode_set):</span>
        <span class="s5">&quot;Unicode set for Chinese Unicode Character Range&quot;</span>
        <span class="s1">_ranges = [(</span><span class="s4">0x4e00</span><span class="s3">, </span><span class="s4">0x9fff</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x3000</span><span class="s3">, </span><span class="s4">0x303f</span><span class="s1">)</span><span class="s3">,</span><span class="s1">]</span>

    <span class="s3">class </span><span class="s1">Japanese(unicode_set):</span>
        <span class="s5">&quot;Unicode set for Japanese Unicode Character Range, combining Kanji, Hiragana, and Katakana ranges&quot;</span>
        <span class="s1">_ranges = []</span>

        <span class="s3">class </span><span class="s1">Kanji(unicode_set):</span>
            <span class="s5">&quot;Unicode set for Kanji Unicode Character Range&quot;</span>
            <span class="s1">_ranges = [(</span><span class="s4">0x4E00</span><span class="s3">, </span><span class="s4">0x9Fbf</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x3000</span><span class="s3">, </span><span class="s4">0x303f</span><span class="s1">)</span><span class="s3">,</span><span class="s1">]</span>

        <span class="s3">class </span><span class="s1">Hiragana(unicode_set):</span>
            <span class="s5">&quot;Unicode set for Hiragana Unicode Character Range&quot;</span>
            <span class="s1">_ranges = [(</span><span class="s4">0x3040</span><span class="s3">, </span><span class="s4">0x309f</span><span class="s1">)</span><span class="s3">,</span><span class="s1">]</span>

        <span class="s3">class </span><span class="s1">Katakana(unicode_set):</span>
            <span class="s5">&quot;Unicode set for Katakana  Unicode Character Range&quot;</span>
            <span class="s1">_ranges = [(</span><span class="s4">0x30a0</span><span class="s3">, </span><span class="s4">0x30ff</span><span class="s1">)</span><span class="s3">,</span><span class="s1">]</span>

    <span class="s3">class </span><span class="s1">Korean(unicode_set):</span>
        <span class="s5">&quot;Unicode set for Korean Unicode Character Range&quot;</span>
        <span class="s1">_ranges = [(</span><span class="s4">0xac00</span><span class="s3">, </span><span class="s4">0xd7af</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x1100</span><span class="s3">, </span><span class="s4">0x11ff</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x3130</span><span class="s3">, </span><span class="s4">0x318f</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0xa960</span><span class="s3">, </span><span class="s4">0xa97f</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0xd7b0</span><span class="s3">, </span><span class="s4">0xd7ff</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x3000</span><span class="s3">, </span><span class="s4">0x303f</span><span class="s1">)</span><span class="s3">,</span><span class="s1">]</span>

    <span class="s3">class </span><span class="s1">CJK(Chinese</span><span class="s3">, </span><span class="s1">Japanese</span><span class="s3">, </span><span class="s1">Korean):</span>
        <span class="s5">&quot;Unicode set for combined Chinese, Japanese, and Korean (CJK) Unicode Character Range&quot;</span>
        <span class="s3">pass</span>

    <span class="s3">class </span><span class="s1">Thai(unicode_set):</span>
        <span class="s5">&quot;Unicode set for Thai Unicode Character Range&quot;</span>
        <span class="s1">_ranges = [(</span><span class="s4">0x0e01</span><span class="s3">, </span><span class="s4">0x0e3a</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x0e3f</span><span class="s3">, </span><span class="s4">0x0e5b</span><span class="s1">)</span><span class="s3">,</span><span class="s1">]</span>

    <span class="s3">class </span><span class="s1">Arabic(unicode_set):</span>
        <span class="s5">&quot;Unicode set for Arabic Unicode Character Range&quot;</span>
        <span class="s1">_ranges = [(</span><span class="s4">0x0600</span><span class="s3">, </span><span class="s4">0x061b</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x061e</span><span class="s3">, </span><span class="s4">0x06ff</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0x0700</span><span class="s3">, </span><span class="s4">0x077f</span><span class="s1">)</span><span class="s3">,</span><span class="s1">]</span>

    <span class="s3">class </span><span class="s1">Hebrew(unicode_set):</span>
        <span class="s5">&quot;Unicode set for Hebrew Unicode Character Range&quot;</span>
        <span class="s1">_ranges = [(</span><span class="s4">0x0590</span><span class="s3">, </span><span class="s4">0x05ff</span><span class="s1">)</span><span class="s3">,</span><span class="s1">]</span>

    <span class="s3">class </span><span class="s1">Devanagari(unicode_set):</span>
        <span class="s5">&quot;Unicode set for Devanagari Unicode Character Range&quot;</span>
        <span class="s1">_ranges = [(</span><span class="s4">0x0900</span><span class="s3">, </span><span class="s4">0x097f</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">0xa8e0</span><span class="s3">, </span><span class="s4">0xa8ff</span><span class="s1">)]</span>

<span class="s1">pyparsing_unicode.Japanese._ranges = (pyparsing_unicode.Japanese.Kanji._ranges</span>
                                      <span class="s1">+ pyparsing_unicode.Japanese.Hiragana._ranges</span>
                                      <span class="s1">+ pyparsing_unicode.Japanese.Katakana._ranges)</span>

<span class="s0"># define ranges in language character sets</span>
<span class="s3">if </span><span class="s1">PY_3:</span>
    <span class="s1">setattr(pyparsing_unicode</span><span class="s3">, </span><span class="s2">u&quot;العربية&quot;</span><span class="s3">, </span><span class="s1">pyparsing_unicode.Arabic)</span>
    <span class="s1">setattr(pyparsing_unicode</span><span class="s3">, </span><span class="s2">u&quot;中文&quot;</span><span class="s3">, </span><span class="s1">pyparsing_unicode.Chinese)</span>
    <span class="s1">setattr(pyparsing_unicode</span><span class="s3">, </span><span class="s2">u&quot;кириллица&quot;</span><span class="s3">, </span><span class="s1">pyparsing_unicode.Cyrillic)</span>
    <span class="s1">setattr(pyparsing_unicode</span><span class="s3">, </span><span class="s2">u&quot;Ελληνικά&quot;</span><span class="s3">, </span><span class="s1">pyparsing_unicode.Greek)</span>
    <span class="s1">setattr(pyparsing_unicode</span><span class="s3">, </span><span class="s2">u&quot;עִברִית&quot;</span><span class="s3">, </span><span class="s1">pyparsing_unicode.Hebrew)</span>
    <span class="s1">setattr(pyparsing_unicode</span><span class="s3">, </span><span class="s2">u&quot;日本語&quot;</span><span class="s3">, </span><span class="s1">pyparsing_unicode.Japanese)</span>
    <span class="s1">setattr(pyparsing_unicode.Japanese</span><span class="s3">, </span><span class="s2">u&quot;漢字&quot;</span><span class="s3">, </span><span class="s1">pyparsing_unicode.Japanese.Kanji)</span>
    <span class="s1">setattr(pyparsing_unicode.Japanese</span><span class="s3">, </span><span class="s2">u&quot;カタカナ&quot;</span><span class="s3">, </span><span class="s1">pyparsing_unicode.Japanese.Katakana)</span>
    <span class="s1">setattr(pyparsing_unicode.Japanese</span><span class="s3">, </span><span class="s2">u&quot;ひらがな&quot;</span><span class="s3">, </span><span class="s1">pyparsing_unicode.Japanese.Hiragana)</span>
    <span class="s1">setattr(pyparsing_unicode</span><span class="s3">, </span><span class="s2">u&quot;한국어&quot;</span><span class="s3">, </span><span class="s1">pyparsing_unicode.Korean)</span>
    <span class="s1">setattr(pyparsing_unicode</span><span class="s3">, </span><span class="s2">u&quot;ไทย&quot;</span><span class="s3">, </span><span class="s1">pyparsing_unicode.Thai)</span>
    <span class="s1">setattr(pyparsing_unicode</span><span class="s3">, </span><span class="s2">u&quot;देवनागरी&quot;</span><span class="s3">, </span><span class="s1">pyparsing_unicode.Devanagari)</span>


<span class="s3">class </span><span class="s1">pyparsing_test:</span>
    <span class="s5">&quot;&quot;&quot; 
    namespace class for classes useful in writing unit tests 
    &quot;&quot;&quot;</span>

    <span class="s3">class </span><span class="s1">reset_pyparsing_context:</span>
        <span class="s5">&quot;&quot;&quot; 
        Context manager to be used when writing unit tests that modify pyparsing config values: 
         - packrat parsing 
         - default whitespace characters. 
         - default keyword characters 
         - literal string auto-conversion class 
         - __diag__ settings 
 
        Example: 
            with reset_pyparsing_context(): 
                # test that literals used to construct a grammar are automatically suppressed 
                ParserElement.inlineLiteralsUsing(Suppress) 
 
                term = Word(alphas) | Word(nums) 
                group = Group('(' + term[...] + ')') 
 
                # assert that the '()' characters are not included in the parsed tokens 
                self.assertParseAndCheckLisst(group, &quot;(abc 123 def)&quot;, ['abc', '123', 'def']) 
 
            # after exiting context manager, literals are converted to Literal expressions again 
        &quot;&quot;&quot;</span>

        <span class="s3">def </span><span class="s1">__init__(self):</span>
            <span class="s1">self._save_context = {}</span>

        <span class="s3">def </span><span class="s1">save(self):</span>
            <span class="s1">self._save_context[</span><span class="s2">&quot;default_whitespace&quot;</span><span class="s1">] = ParserElement.DEFAULT_WHITE_CHARS</span>
            <span class="s1">self._save_context[</span><span class="s2">&quot;default_keyword_chars&quot;</span><span class="s1">] = Keyword.DEFAULT_KEYWORD_CHARS</span>
            <span class="s1">self._save_context[</span>
                <span class="s2">&quot;literal_string_class&quot;</span>
            <span class="s1">] = ParserElement._literalStringClass</span>
            <span class="s1">self._save_context[</span><span class="s2">&quot;packrat_enabled&quot;</span><span class="s1">] = ParserElement._packratEnabled</span>
            <span class="s1">self._save_context[</span><span class="s2">&quot;packrat_parse&quot;</span><span class="s1">] = ParserElement._parse</span>
            <span class="s1">self._save_context[</span><span class="s2">&quot;__diag__&quot;</span><span class="s1">] = {</span>
                <span class="s1">name: getattr(__diag__</span><span class="s3">, </span><span class="s1">name) </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">__diag__._all_names</span>
            <span class="s1">}</span>
            <span class="s1">self._save_context[</span><span class="s2">&quot;__compat__&quot;</span><span class="s1">] = {</span>
                <span class="s2">&quot;collect_all_And_tokens&quot;</span><span class="s1">: __compat__.collect_all_And_tokens</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">self</span>

        <span class="s3">def </span><span class="s1">restore(self):</span>
            <span class="s0"># reset pyparsing global state</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">ParserElement.DEFAULT_WHITE_CHARS</span>
                <span class="s1">!= self._save_context[</span><span class="s2">&quot;default_whitespace&quot;</span><span class="s1">]</span>
            <span class="s1">):</span>
                <span class="s1">ParserElement.setDefaultWhitespaceChars(</span>
                    <span class="s1">self._save_context[</span><span class="s2">&quot;default_whitespace&quot;</span><span class="s1">]</span>
                <span class="s1">)</span>
            <span class="s1">Keyword.DEFAULT_KEYWORD_CHARS = self._save_context[</span><span class="s2">&quot;default_keyword_chars&quot;</span><span class="s1">]</span>
            <span class="s1">ParserElement.inlineLiteralsUsing(</span>
                <span class="s1">self._save_context[</span><span class="s2">&quot;literal_string_class&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self._save_context[</span><span class="s2">&quot;__diag__&quot;</span><span class="s1">].items():</span>
                <span class="s1">setattr(__diag__</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value)</span>
            <span class="s1">ParserElement._packratEnabled = self._save_context[</span><span class="s2">&quot;packrat_enabled&quot;</span><span class="s1">]</span>
            <span class="s1">ParserElement._parse = self._save_context[</span><span class="s2">&quot;packrat_parse&quot;</span><span class="s1">]</span>
            <span class="s1">__compat__.collect_all_And_tokens = self._save_context[</span><span class="s2">&quot;__compat__&quot;</span><span class="s1">]</span>

        <span class="s3">def </span><span class="s1">__enter__(self):</span>
            <span class="s3">return </span><span class="s1">self.save()</span>

        <span class="s3">def </span><span class="s1">__exit__(self</span><span class="s3">, </span><span class="s1">*args):</span>
            <span class="s3">return </span><span class="s1">self.restore()</span>

    <span class="s3">class </span><span class="s1">TestParseResultsAsserts:</span>
        <span class="s5">&quot;&quot;&quot; 
        A mixin class to add parse results assertion methods to normal unittest.TestCase classes. 
        &quot;&quot;&quot;</span>
        <span class="s3">def </span><span class="s1">assertParseResultsEquals(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">result</span><span class="s3">, </span><span class="s1">expected_list=</span><span class="s3">None, </span><span class="s1">expected_dict=</span><span class="s3">None, </span><span class="s1">msg=</span><span class="s3">None</span>
        <span class="s1">):</span>
            <span class="s5">&quot;&quot;&quot; 
            Unit test assertion to compare a ParseResults object with an optional expected_list, 
            and compare any defined results names with an optional expected_dict. 
            &quot;&quot;&quot;</span>
            <span class="s3">if </span><span class="s1">expected_list </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.assertEqual(expected_list</span><span class="s3">, </span><span class="s1">result.asList()</span><span class="s3">, </span><span class="s1">msg=msg)</span>
            <span class="s3">if </span><span class="s1">expected_dict </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.assertEqual(expected_dict</span><span class="s3">, </span><span class="s1">result.asDict()</span><span class="s3">, </span><span class="s1">msg=msg)</span>

        <span class="s3">def </span><span class="s1">assertParseAndCheckList(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">test_string</span><span class="s3">, </span><span class="s1">expected_list</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None, </span><span class="s1">verbose=</span><span class="s3">True</span>
        <span class="s1">):</span>
            <span class="s5">&quot;&quot;&quot; 
            Convenience wrapper assert to test a parser element and input string, and assert that 
            the resulting ParseResults.asList() is equal to the expected_list. 
            &quot;&quot;&quot;</span>
            <span class="s1">result = expr.parseString(test_string</span><span class="s3">, </span><span class="s1">parseAll=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">verbose:</span>
                <span class="s1">print(result.dump())</span>
            <span class="s1">self.assertParseResultsEquals(result</span><span class="s3">, </span><span class="s1">expected_list=expected_list</span><span class="s3">, </span><span class="s1">msg=msg)</span>

        <span class="s3">def </span><span class="s1">assertParseAndCheckDict(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">test_string</span><span class="s3">, </span><span class="s1">expected_dict</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None, </span><span class="s1">verbose=</span><span class="s3">True</span>
        <span class="s1">):</span>
            <span class="s5">&quot;&quot;&quot; 
            Convenience wrapper assert to test a parser element and input string, and assert that 
            the resulting ParseResults.asDict() is equal to the expected_dict. 
            &quot;&quot;&quot;</span>
            <span class="s1">result = expr.parseString(test_string</span><span class="s3">, </span><span class="s1">parseAll=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">verbose:</span>
                <span class="s1">print(result.dump())</span>
            <span class="s1">self.assertParseResultsEquals(result</span><span class="s3">, </span><span class="s1">expected_dict=expected_dict</span><span class="s3">, </span><span class="s1">msg=msg)</span>

        <span class="s3">def </span><span class="s1">assertRunTestResults(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">run_tests_report</span><span class="s3">, </span><span class="s1">expected_parse_results=</span><span class="s3">None, </span><span class="s1">msg=</span><span class="s3">None</span>
        <span class="s1">):</span>
            <span class="s5">&quot;&quot;&quot; 
            Unit test assertion to evaluate output of ParserElement.runTests(). If a list of 
            list-dict tuples is given as the expected_parse_results argument, then these are zipped 
            with the report tuples returned by runTests and evaluated using assertParseResultsEquals. 
            Finally, asserts that the overall runTests() success value is True. 
 
            :param run_tests_report: tuple(bool, [tuple(str, ParseResults or Exception)]) returned from runTests 
            :param expected_parse_results (optional): [tuple(str, list, dict, Exception)] 
            &quot;&quot;&quot;</span>
            <span class="s1">run_test_success</span><span class="s3">, </span><span class="s1">run_test_results = run_tests_report</span>

            <span class="s3">if </span><span class="s1">expected_parse_results </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">merged = [</span>
                    <span class="s1">(rpt[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">rpt[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">expected)</span>
                    <span class="s3">for </span><span class="s1">rpt</span><span class="s3">, </span><span class="s1">expected </span><span class="s3">in </span><span class="s1">zip(run_test_results</span><span class="s3">, </span><span class="s1">expected_parse_results)</span>
                <span class="s1">]</span>
                <span class="s3">for </span><span class="s1">test_string</span><span class="s3">, </span><span class="s1">result</span><span class="s3">, </span><span class="s1">expected </span><span class="s3">in </span><span class="s1">merged:</span>
                    <span class="s0"># expected should be a tuple containing a list and/or a dict or an exception,</span>
                    <span class="s0"># and optional failure message string</span>
                    <span class="s0"># an empty tuple will skip any result validation</span>
                    <span class="s1">fail_msg = next(</span>
                        <span class="s1">(exp </span><span class="s3">for </span><span class="s1">exp </span><span class="s3">in </span><span class="s1">expected </span><span class="s3">if </span><span class="s1">isinstance(exp</span><span class="s3">, </span><span class="s1">str))</span><span class="s3">, None</span>
                    <span class="s1">)</span>
                    <span class="s1">expected_exception = next(</span>
                        <span class="s1">(</span>
                            <span class="s1">exp</span>
                            <span class="s3">for </span><span class="s1">exp </span><span class="s3">in </span><span class="s1">expected</span>
                            <span class="s3">if </span><span class="s1">isinstance(exp</span><span class="s3">, </span><span class="s1">type) </span><span class="s3">and </span><span class="s1">issubclass(exp</span><span class="s3">, </span><span class="s1">Exception)</span>
                        <span class="s1">)</span><span class="s3">,</span>
                        <span class="s3">None,</span>
                    <span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">expected_exception </span><span class="s3">is not None</span><span class="s1">:</span>
                        <span class="s3">with </span><span class="s1">self.assertRaises(</span>
                            <span class="s1">expected_exception=expected_exception</span><span class="s3">, </span><span class="s1">msg=fail_msg </span><span class="s3">or </span><span class="s1">msg</span>
                        <span class="s1">):</span>
                            <span class="s3">if </span><span class="s1">isinstance(result</span><span class="s3">, </span><span class="s1">Exception):</span>
                                <span class="s3">raise </span><span class="s1">result</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">expected_list = next(</span>
                            <span class="s1">(exp </span><span class="s3">for </span><span class="s1">exp </span><span class="s3">in </span><span class="s1">expected </span><span class="s3">if </span><span class="s1">isinstance(exp</span><span class="s3">, </span><span class="s1">list))</span><span class="s3">, None</span>
                        <span class="s1">)</span>
                        <span class="s1">expected_dict = next(</span>
                            <span class="s1">(exp </span><span class="s3">for </span><span class="s1">exp </span><span class="s3">in </span><span class="s1">expected </span><span class="s3">if </span><span class="s1">isinstance(exp</span><span class="s3">, </span><span class="s1">dict))</span><span class="s3">, None</span>
                        <span class="s1">)</span>
                        <span class="s3">if </span><span class="s1">(expected_list</span><span class="s3">, </span><span class="s1">expected_dict) != (</span><span class="s3">None, None</span><span class="s1">):</span>
                            <span class="s1">self.assertParseResultsEquals(</span>
                                <span class="s1">result</span><span class="s3">,</span>
                                <span class="s1">expected_list=expected_list</span><span class="s3">,</span>
                                <span class="s1">expected_dict=expected_dict</span><span class="s3">,</span>
                                <span class="s1">msg=fail_msg </span><span class="s3">or </span><span class="s1">msg</span><span class="s3">,</span>
                            <span class="s1">)</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s0"># warning here maybe?</span>
                            <span class="s1">print(</span><span class="s2">&quot;no validation for {!r}&quot;</span><span class="s1">.format(test_string))</span>

            <span class="s0"># do this last, in case some specific test results can be reported instead</span>
            <span class="s1">self.assertTrue(</span>
                <span class="s1">run_test_success</span><span class="s3">, </span><span class="s1">msg=msg </span><span class="s3">if </span><span class="s1">msg </span><span class="s3">is not None else </span><span class="s2">&quot;failed runTests&quot;</span>
            <span class="s1">)</span>

        <span class="s1">@contextmanager</span>
        <span class="s3">def </span><span class="s1">assertRaisesParseException(self</span><span class="s3">, </span><span class="s1">exc_type=ParseException</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">with </span><span class="s1">self.assertRaises(exc_type</span><span class="s3">, </span><span class="s1">msg=msg):</span>
                <span class="s3">yield</span>


<span class="s3">if </span><span class="s1">__name__ == </span><span class="s2">&quot;__main__&quot;</span><span class="s1">:</span>

    <span class="s1">selectToken    = CaselessLiteral(</span><span class="s2">&quot;select&quot;</span><span class="s1">)</span>
    <span class="s1">fromToken      = CaselessLiteral(</span><span class="s2">&quot;from&quot;</span><span class="s1">)</span>

    <span class="s1">ident          = Word(alphas</span><span class="s3">, </span><span class="s1">alphanums + </span><span class="s2">&quot;_$&quot;</span><span class="s1">)</span>

    <span class="s1">columnName     = delimitedList(ident</span><span class="s3">, </span><span class="s2">&quot;.&quot;</span><span class="s3">, </span><span class="s1">combine=</span><span class="s3">True</span><span class="s1">).setParseAction(upcaseTokens)</span>
    <span class="s1">columnNameList = Group(delimitedList(columnName)).setName(</span><span class="s2">&quot;columns&quot;</span><span class="s1">)</span>
    <span class="s1">columnSpec     = (</span><span class="s2">'*' </span><span class="s1">| columnNameList)</span>

    <span class="s1">tableName      = delimitedList(ident</span><span class="s3">, </span><span class="s2">&quot;.&quot;</span><span class="s3">, </span><span class="s1">combine=</span><span class="s3">True</span><span class="s1">).setParseAction(upcaseTokens)</span>
    <span class="s1">tableNameList  = Group(delimitedList(tableName)).setName(</span><span class="s2">&quot;tables&quot;</span><span class="s1">)</span>

    <span class="s1">simpleSQL      = selectToken(</span><span class="s2">&quot;command&quot;</span><span class="s1">) + columnSpec(</span><span class="s2">&quot;columns&quot;</span><span class="s1">) + fromToken + tableNameList(</span><span class="s2">&quot;tables&quot;</span><span class="s1">)</span>

    <span class="s0"># demo runTests method, including embedded comments in test string</span>
    <span class="s1">simpleSQL.runTests(</span><span class="s2">&quot;&quot;&quot; 
        # '*' as column list and dotted table name 
        select * from SYS.XYZZY 
 
        # caseless match on &quot;SELECT&quot;, and casts back to &quot;select&quot; 
        SELECT * from XYZZY, ABC 
 
        # list of column names, and mixed case SELECT keyword 
        Select AA,BB,CC from Sys.dual 
 
        # multiple tables 
        Select A, B, C from Sys.dual, Table2 
 
        # invalid SELECT keyword - should fail 
        Xelect A, B, C from Sys.dual 
 
        # incomplete command - should fail 
        Select 
 
        # invalid column name - should fail 
        Select ^^^ frox Sys.dual 
 
        &quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s1">pyparsing_common.number.runTests(</span><span class="s2">&quot;&quot;&quot; 
        100 
        -100 
        +100 
        3.14159 
        6.02e23 
        1e-12 
        &quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s0"># any int or real number, returned as float</span>
    <span class="s1">pyparsing_common.fnumber.runTests(</span><span class="s2">&quot;&quot;&quot; 
        100 
        -100 
        +100 
        3.14159 
        6.02e23 
        1e-12 
        &quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s1">pyparsing_common.hex_integer.runTests(</span><span class="s2">&quot;&quot;&quot; 
        100 
        FF 
        &quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s3">import </span><span class="s1">uuid</span>
    <span class="s1">pyparsing_common.uuid.setParseAction(tokenMap(uuid.UUID))</span>
    <span class="s1">pyparsing_common.uuid.runTests(</span><span class="s2">&quot;&quot;&quot; 
        12345678-1234-5678-1234-567812345678 
        &quot;&quot;&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>